#lang scribble/lp2

@require[scribble/manual]

@require[@for-label[racket
                    racket/match
                    syntax/parse
                    racket/pretty]]

@title[#:style manual-doc-style]{Stochastic LISP 1.5 musicalization}

@chunk[<*>
       (module LISP15 racket
         (provide <provisions/l15>)
         (require <requirements/l15>)
         <l15>)]

In order to generate variety in the musical output, the
musicalizer passes around some state:

@itemlist[
 @item{@code{log} is the current “default” duration; notes
  generally get their @code{log} field from this value}
 @item{@code{dots} is the current number of dots}
 @item{@code{octave} is the octave in which pitches will be
  generated}
 @item{@code{dynamic} is the current dynamic level}
 @item{@code{setq-parity} is @code{#t} if an even number of
  @code{SETQ} forms have been encountered in the course of
  processing a function}
 @item{@code{tonic} is the current key center}
 @item{@code{mode} is the name of the scale from which notes
  are drawn, when generating tonal music}
 @item{@code{pitcher} is a procedure called to turn strings into pitches}]

Sometimes the state is varied by creating a new structure to
pass down to recursive calls. However, some fields need to
exist across levels of recursion; for example, even if a
dynamics change happens deep within the call stack, it will
still affect subsequent music generated by outer calls. Thus
the fields @code{dynamic}, @code{setq-parity}, @code{tonic},
and @code{mode} are kept in mutable boxes.

Another aspect of the state is the @code{depth} parameter,
which tracks the syntactic nesting of function calls (reset
every @code{LAMBDA}).

Both @code{depth} and @code{setq-parity} are somewhat
random; these specific values were chosen because they vary
quickly and unpredictably. As calls become more nested, the
rhythmic subdivision (i.e., @code{log}) generally increases,
based on @code{depth}. Part of the translation of
@code{SETQ} adds dynamics, whose precise nature depends upon
the @code{setq-parity}.

@chunk[<l15>
       (struct State
         (log
          dots
          octave
          dynamic
          setq-parity
          tonic
          mode
          pitcher))

       (define depth (make-parameter 0))

       (define (default-state pitcher)
         (State 8 0 4 (box 'mf) (box #f) (box 'a) (box 'major) pitcher))
       
       (define (make-state state
                           #:log [log (State-log state)]
                           #:dots [dots (State-dots state)]
                           #:octave [octave (State-octave state)]
                           #:dynamic [dynamic (State-dynamic state)]
                           #:setq-parity [setq-parity (State-setq-parity state)]
                           #:tonic [tonic (State-tonic state)]
                           #:mode [mode (State-mode state)]
                           #:pitcher [pitcher (State-pitcher state)])
         (State log dots octave dynamic setq-parity tonic mode pitcher))

       (define-syntax-rule (with-state e (field ...) body ...)
         (match e
           [(State field ...)
            body ...]))]

Here are some ways of turning strings into pitches. The
character set in @code{character-code} is ordered
numerically according to the IBM machines LISP 1.5 ran on,
with the exception of the last dozen, added to support
REDUCE (they are in a random order).

@chunk[<l15>
       (define (character-code c)
         (string-find "0123456789=\"+abcdefghi.)-jklmnopqr$* /stuvwxyz,(|&;~:<>!'?"
                      (make-string 1 (char-downcase c))))
       
       (define (atonal-pitcher text state)
         (map (λ (c)
                (add-interval (make-pitch (unbox (State-tonic state))
                                          (State-octave state))
                              (modulo (character-code c)
                                      31)))
              (string->list text)))]

For tonal music, we need to choose intervals from a certain
scale. To spice the output up a bit, an octave displacement
(relative to the @code{octave} field of the state) is also
added depending on the specific character.

@chunk[<l15>
       (define (make-scale-selector . r)
         (let loop ([pairs '()]
                    [items r])
           (if (null? items)
               (λ (code state)
                 (define intervals (cdr (assoc (unbox (State-mode state)) pairs)))
                 (list-ref intervals
                           (modulo code (length intervals))))
               (loop (cons (cons (first items)
                                 (second items))
                           pairs)
                     (rest (rest items))))))

       (define major-intervals '(0 5 10 13 18 23 28))
       (define minor-intervals '(0 5 8 13 15 20 26))
       (define major-pentatonic-intervals '(0 5 10 18 23))
       (define minor-pentatonic-intervals '(0 8 13 15 26))

       (define (octave-displacement code)
         (cond [(<= 0 code 24)
                -1]
               [(<= 24 code 42)
                0]
               [else
                +1]))

       (define (make-scale-pitcher . r)
         (λ (text state)
           (map (λ (c)
                  (define code (character-code c))
                  (add-interval (make-pitch (unbox (State-tonic state))
                                            (+ (State-octave state)
                                               (octave-displacement code)))
                                ((apply make-scale-selector r)
                                 code
                                 state)))
                (string->list text))))

       (define pentatonic-pitcher
         (make-scale-pitcher 'major major-pentatonic-intervals
                             'minor minor-pentatonic-intervals))
       
       (define tonal-pitcher
         (make-scale-pitcher 'major major-intervals
                             'minor minor-intervals))]

@chunk[<provisions/l15>
       atonal-pitcher
       tonal-pitcher
       pentatonic-pitcher]

The general entry point to this LISP 1.5 musicalizer is
@code{musicalize-file}. It pretends to be @code{EVALQUOTE},
collecting doublets and rewriting them into normal
s-expressions. (However, both halves of the doublet are
treated as evaluated.) The Overlord monitor is not
simulated, so Overlord cards should be expunged from the
input.

@chunk[<l15>
       (define (musicalize-file in pitcher)
         (parameterize ([read-case-sensitive #f])
           (let loop ([forms '()])
             (let* ([operator (read in)]
                    [operands (read in)])
               (if (eof-object? operator)
                   (musicalize-top-level (reverse forms) pitcher)
                   (loop (cons (cons operator operands)
                               forms)))))))]

@chunk[<provisions/l15>
       musicalize-file]

Expressions that act as “declarations” are ignored, though
comments are transferred to the score.

@chunk[<l15>
       (define (musicalize-top-level forms pitcher)
         (let ([state (default-state pitcher)])
           (map (λ (form)
                  (match form
                    [`(define (,things ...))
                     (map (λ (thing)
                            (match thing
                              [`(,name ,e)
                               (Measure 0 0 (musicalize-expression e (make-state state)) (symbol->string name))]))
                          things)]
                    [`(comment ,stuff ...)
                     (Measure 0 0 '() (~a stuff))]
                    [`(special ,stuff ...)
                     '()]
                    [_
                     (Measure 0 0 (musicalize-expression form state)
                              (~a form))]))
                forms)))]

Like a compiler, the musicalizer traverses the code mostly
in evaluation order.

@chunk[<l15>
       (define (musicalize-expression e state)
         (with-state state (log dots octave dynamic setq-parity tonic mode pitcher)
           (match e
             <musicalize-atomic/constants>
             <musicalize-prog>
             <musicalize-functionals>
             <musicalize-setq>
             <musicalize-cond>
             <musicalize-application>
             <musicalize-built-ins>
             [`(,h . ,t)
              (musicalize-constant e state)])))]

@chunk[<musicalize-atomic/constants>
       [(? symbol?)
        (musicalize-symbol e state)]
       [(? number?)
        (musicalize-constant e state)]
       ['()
        (Note '() log dots '())]
       [`(quote ,thing)
        (musicalize-constant thing state)]]

Most of the pitches in the output come from
@code{musicalize-symbol}.

@chunk[<l15>
       (define (musicalize-symbol s state)
         (with-state state (log dots octave dynamic setq-parity tonic mode pitcher)
           (if (eqv? s 'nil)
               (Note '() log dots '())
               (let* ([text (symbol->string s)]
                      [l (string-length text)]
                      [pitches (pitcher text state)])
                 (if (and (>= l 1)
                          (<= (State-log state) 8)
                          (<= l 5))
                     (list (Note pitches log dots '()))
                     (list (let ([i 0])
                             (map (λ (p)
                                    (set! i (+ i 1))
                                    (Note (list p)
                                          (* log 2)
                                          dots
                                          (cond [(and (> l 1) (= i 1))
                                                 '(beam-begin)]
                                                [(and (> l 1) (= i l))
                                                 '(beam-end)]
                                                [else
                                                 '()])))
                                  pitches))))))))]

@chunk[<l15>       
       (define (musicalize-constant c state)
         (with-state state (log dots octave dynamic setq-parity tonic mode pitcher)
           (match c
             [(? exact-integer?)
              (Note (list (make-pitch (integer->pitch-class (modulo c 31)) 4))
                    log
                    dots
                    '())]
             [(? number?)
              (Note (list (make-pitch (integer->pitch-class (modulo (exact-floor c) 31)) 4))
                    log
                    (+ dots 1)
                    '())]
             [(? symbol?)
              (musicalize-symbol c (make-state state #:octave 4))]
             [(? null?)
              (Note '() log dots '())]
             [`(,h . ,t)
              (list (musicalize-constant h state)
                    (musicalize-constant t state))])))]

The @code{FUNCTION} operator creates a sort of
pseudo-closure, by storing the association list along with
the lambda expression. Musically, I represent the
environment capture with the sustain pedal.

@chunk[<musicalize-functionals>
       [`(function ,e)
        (add-event-first-last! (musicalize-expression e state)
                               'sustain-begin
                               'sustain-end)]
       [`(lambda (,vs ...) ,e)
        (let* ([count (length vs)]
               [ratio (cond [(= count 1)
                             3/2]
                            [(odd? count)
                             (/ count (nearest-power-of-two count))]
                            [else
                             1])])
          (parameterize ([depth 0])
            (cond [(= count 1)
                   (musicalize-expression e state)]
                  [(even? count)
                   (musicalize-expression e state)]
                  [else
                   (Tuplet ratio
                           (musicalize-expression e state))])))]]

@chunk[<musicalize-setq>
       [`(setq ,v ,e)
        (define text (symbol->string v))
        (define size (string-length text))
        (set-box! (State-setq-parity state) (not (unbox setq-parity)))
        (let loop ([d (unbox dynamic)]
                   [i size])
          (if (= i 0)
              (list (musicalize-symbol v state)
                    (add-event-first-last! (musicalize-expression e state)
                                           (if (unbox setq-parity)
                                               'crescendo-begin
                                               'diminuendo-begin)
                                           d))
              (loop ((if (unbox setq-parity)
                         increase-dynamic
                         decrease-dynamic)
                     d)
                    (- i 1))))]]

LISP 1.5 code uses @code{PROG} with great frequency, so we
should try to wring as much musical interest out of it as
possible. To this end, we take @code{PROG} as a gateway to
polyphony. First, the body of the @code{PROG}, if it has any tags,
is split up according to those tags; thus the body of

@verbatim{
   (PROG (V W)
         (COND ((AND OFL* (OR *FORT (NOT *NAT))) (GO D)))
       (TERPRI*)
    A    (SETQ V U)
       (PRINC Y)
       (PRINC **BLANK)
    B    (COND ((NULL V) (GO C)))
       (PRINC (CAR V))
       (PRINC **BLANK)
       (SETQ V (CDR V))
       (GO B)
    C    (COND (X (TERPRI)))
       (COND ((NULL OFL*) (RETURN NIL)) (W (RETURN (WRS OFL*))))
     D (WRS NIL)
       (SETQ W T)
       (GO A))
}

(@code{LPRIW}, from REDUCE) yields the items @code{((COND …)
 (TERPRI*))}, @code{(A (SETQ V U) (PRINC Y) (PRINC …))}, etc.
Then these groups are split into two parts, whence come the
two voices in the music. This procedure is quite janky.

@chunk[<musicalize-prog>
       [`(return ,e)
        (musicalize-expression e (make-state state
                                             #:log (/ log 2)
                                             #:tonic (box 'a)))]
       [`(go ,tag)
        (set-box! tonic (pitch-class-of (add-interval (make-pitch (unbox tonic) 0) 5)))
        (add-event-first! (musicalize-symbol tag state)
                          (increase-dynamic (unbox dynamic)))]
       [`(prog (,vs ...) ,body ...)
        (let* ([variable-count (length vs)]
               [ratio (if (>= variable-count 3)
                          (/ variable-count (- variable-count 1))
                          3/2)])
          <prog/preprocess>
          <prog/go>
          <prog/final>)]]

@chunk[<prog/preprocess>
       (define (preprocess-body body)
         (define fake-tag (gensym))
         (if (zero? (count symbol? body))
             (list (list* fake-tag #f body))
             (let loop ([xs (list* fake-tag #f body)])
               (match xs
                 [(list* (? symbol? x) (? (negate symbol?) a) ... more)
                  (cons (cons x a)
                        (loop more))]
                 ['() '()]))))
       (define-values (tag-count stuff) (let ([pairs (preprocess-body body)])
                                          (cond [(and (null? (rest pairs))
                                                      (not (symbol-interned? (car (first pairs)))))
                                                 (values 0 (cdr (first pairs)))]
                                                [(eqv? (first (cdr (first pairs))) #f)
                                                 (values (- (length pairs) 1) (rest pairs))]
                                                [else
                                                 (values (length pairs) pairs)])))]

@chunk[<prog/go>
       (define (go-one pair)
         (let ([name (car pair)]
               [expressions (cdr pair)])
           (if name
               (list (musicalize-symbol name (make-state state #:log (* log 2)))
                     (map (λ (e)
                            (musicalize-expression e state))
                          expressions))
               (map (λ (e)
                      (musicalize-expression e state))
                    expressions))))
       (define (go pairs n)
         (define-values (upper lower) (split-at pairs (/ n 2)))
         (Polyphony (map go-one upper)
                    (transpose (map go-one lower) -62)))]

@chunk[<prog/final>
       (Tuplet ratio (cond [(zero? tag-count)
                            (map (λ (e)
                                   (musicalize-expression e state))
                                 (rest (rest stuff)))]
                           [(odd? tag-count)
                            (cons (go-one (first stuff))
                                  (if (null? (rest stuff))
                                      '()
                                      (list (go (rest stuff) (- tag-count 1)))))]
                           [else
                            (go stuff tag-count)]))]

The test part of a @code{COND} clause is raised an octave
from the surrounding music.

@chunk[<musicalize-cond>
       [`(cond ((,test ,result)))
        (list (add-event-first! (musicalize-expression test (make-state state #:dynamic (increase-dynamic (unbox dynamic))))
                                (increase-dynamic dynamic))
              (musicalize-expression result state))]
       [`(cond ((,tests ,results) ...))
        (define count (length tests))
        (define (clause c)
          (list (musicalize-expression (first c) (make-state state
                                                             #:octave (+ octave 1)
                                                             #:tonic (box (pitch-class-of (add-interval (make-pitch (unbox tonic) 0)
                                                                                                        7)))))
                (musicalize-expression (second c) state)))
        (define (go clauses count)
          (define-values (upper lower) (split-at clauses (/ count 2)))
          #;(Polyphony (map clause upper)
                     (transpose (map clause lower) -62))
          (map clause clauses))
        (Tuplet (if (odd? count)
                    (/ count (nearest-power-of-two count))
                    (/ (+ count 1) count))
                (if (odd? count)
                    (list (clause (first tests)
                                  (first results))
                          (go (map list (rest tests) (rest results)) (- count 1)))
                    (go (map list tests results) count)))]]

@chunk[<musicalize-application>
       [`(,operator ,operands ...)
        (parameterize ([depth (+ (depth) 1)])
          (let* ([state (make-state state #:log (cond [(zero? (modulo (depth) 5))
                                                       (* log 2)]
                                                      [(and (zero? (modulo (depth) 9))
                                                            (>= log 32))
                                                       (/ log 2)]
                                                      [(zero? (modulo (depth) 7))
                                                       (/ log 2)]
                                                      [else
                                                       log]))]
                 [music (append (map (λ (o)
                                       (musicalize-expression o state))
                                     operands)
                                (list (musicalize-expression operator state)))])
            (cond [(zero? (modulo (depth) 7))
                   (Tuplet (/ (depth) (nearest-power-of-two (depth)))
                           music)]
                  [else
                   music])))]]

Some built-in functions are handled specially.

@chunk[<musicalize-built-ins>
       [`(not ,e)
        (musicalize-expression e (make-state state #:mode (box 'minor)))]
       [`(cons ,e1 ,e2)
        (list (musicalize-expression e1 state)
              (musicalize-expression e2 (make-state state #:dots (min 3 (+ dots 1)))))]]

@chunk[<requirements/l15>
       (submod "music.rkt" Music)]

@chunk[<l15>
       (define (lily measures out [score? #t])
         (fprintf out "\\version \"2.25.26\"

%#(set-default-paper-size \"a1\")

#(define (naturalize-pitch p)
   (let ((o (ly:pitch-octave p))
         (a (* 4 (ly:pitch-alteration p)))
         (n (ly:pitch-notename p)))
     (cond
      ((and (> a 1) (or (eqv? n 6) (eqv? n 2)))
       (set! a (- a 2))
       (set! n (+ n 1)))
      ((and (< a -1) (or (eqv? n 0) (eqv? n 3)))
       (set! a (+ a 2))
       (set! n (- n 1))))
     (cond
      ((> a 2) (set! a (- a 4)) (set! n (+ n 1)))
      ((< a -2) (set! a (+ a 4)) (set! n (- n 1))))
     (if (< n 0) (begin (set! o (- o 1)) (set! n (+ n 7))))
     (if (> n 6) (begin (set! o (+ o 1)) (set! n (- n 7))))
     (ly:make-pitch o n (/ a 4))))

#(define (naturalize music)
   (let ((es (ly:music-property music 'elements))
         (e (ly:music-property music 'element))
         (p (ly:music-property music 'pitch)))
     (if (pair? es)
         (ly:music-set-property!
          music 'elements
          (map naturalize es)))
     (if (ly:music? e)
         (ly:music-set-property!
          music 'element
          (naturalize e)))
     (if (ly:pitch? p)
         (begin
           (set! p (naturalize-pitch p))
           (ly:music-set-property! music 'pitch p)))
     music))

naturalizeMusic =
#(define-music-function (m)
   (ly:music?)
   (naturalize m))

music = \\naturalizeMusic {
~A
}

\\score {
  ~A
  <<
    \\new PianoStaff \\autoChange {
        \\tempo 4 = 60
        \\cadenzaOn
        \\music
    }
  >>
  
  \\midi { }
}
"
                  (let ([out (open-output-string)])
                    (output-music measures out)
                    (get-output-string out))
                  (if score?
                      "  \\layout {
    \\set Score.measureBarType = \"\"
    \\accidentalStyle Staff.dodecaphonic
    \\context {
      \\Voice
      \\remove Forbid_line_break_engraver
      \\override TupletBracket.bracket-visibility = ##t
      \\override TupletNumber.text = #tuplet-number::calc-fraction-text
      \\override Beam.breakable = ##t
   }
    \\context {
      \\Score
      \\override SpacingSpanner.uniform-stretching = ##t
      %proportionalNotationDuration = #1/8
    }
  }"
                      "")))]

@chunk[<requirements/l15>
       (submod "output.rkt" Output)]

@chunk[<provisions/l15>
       lily]