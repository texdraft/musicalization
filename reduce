OPEN (COMPILE SYSFILE INPUT) RESTORE (COMPILE)
DEFLIST (((COMMENT (LAMBDA (U A) NIL))) FEXPR)
COMMENT (***** DATE OF LAST SYSTEM UPDATE *****)
DEFLIST (((DATE* (
$$$15-SEP-72 (UM 1-JUNE-73)$
))) SPECIAL)
COMMENT (THE FOLLOWING COMMANDS ARE USED BY THE COMPILER)
OPTIMIZE (T) BPSUSED (T)
COMMENT((R E D U C E    P R E P R O C E S S O R   F O R   L I S P /360))
OVOFF NIL
COMMENT ((REDUCE CONVERTOR))
REMPROP (DEFINE SUBR)
SPECIAL ((NOCMP*))
(LAMBDA (U) (COMPILE (DEFLIST U (QUOTE EXPR)))) ((
(DEFINE (LAMBDA (U)
   (DEF1 U (QUOTE EXPR))))
 
(DEFEXPR (LAMBDA (U) 
   (DEF1 U (QUOTE FEXPR))))
(DEF1 (LAMBDA (U V)
  (PROG (X Y)
   A   (COND ((NULL U) (RETURN Y))
             ((FLAGP (SETQ X (CAAR U)) (QUOTE LOSE)) (GO B))
             ((GETD (SETQ X (TRANS X NIL)))
               (PRINT (LIST (QUOTE *****) X (QUOTE REDEFINED)))))
       (SETQ Y (NCONC Y (LIST X)))
       (COND (NOCMP* (DEFLIST (LIST (TRANS (CAR U) T)) V))
             ((EQ V (QUOTE EXPR))
               (COM1 X (TRANS (CADAR U) NIL) NIL))
             (T (COM1 X NIL (TRANS (CADAR U) NIL))))
   B   (SETQ U (CDR U)) (GO A))))
(TRANS (LAMBDA (U V)
   (COND   ((NULL U) NIL)
           ((ATOM U) (COND   ((NUMBERP U) U)
                             (T
                              ((LAMBDA(X)
                                (COND   (X
                                         (LIST
                                          (QUOTE QUOTE)
                                          X))
                                        (T ((LAMBDA (Y)
                                            (COND (Y Y)
   ((AND V (GET U (QUOTE SPECIAL))) 
       (LIST (QUOTE GTS) (LIST (QUOTE QUOTE) U)))
                                                  (T U)))
                                         (GET U (QUOTE NEWNAM))))))
                                  (GET U (QUOTE CONSTANT))))))
           ((ATOM (CAR U))
            (COND   ((EQ (CAR U) (QUOTE QUOTE)) U)
                    ((NUMBERP (CAR U))
                     (CONS (CAR U) (MAPTR (CDR U))))
   ((AND V (EQ (CAR U) (QUOTE SETQ)) 
      (GET (CADR U) (QUOTE SPECIAL)))
     (LIST (QUOTE PTS) (LIST (QUOTE QUOTE) (CADR U)) (TRANS
        (CADDR U) V)))
                    (T
                     ((LAMBDA(X)
                       (COND   (X
                                (SUBLIS
                                 (PAIR (CADR X) (MAPTR (CDR U) V))
                                 (CADDR X)))
                              (T (CONS (TRANS (CAR U) V) 
                                 (MAPTR (CDR U) V)))))
                      (GET (CAR U) (QUOTE NEWFORM))))))
           (T (MAPTR U V)))))
(MAPTR (LAMBDA (U V)
   (COND   ((ATOM U) (TRANS U V))
           (T (CONS (TRANS (CAR U) V) (MAPTR (CDR U) V))))))
(GETD(LAMBDA(U)
    (OR (GET U (QUOTE EXPR))
        (GET U (QUOTE FEXPR))
        (GET U (QUOTE SUBR))
        (GET U (QUOTE FSUBR))
        (GET U (QUOTE MACRO)))))
))
(LAMBDA NIL (PROG NIL (DEFLIST (LIST (LIST (QUOTE CONVRT)
           (GET (QUOTE TRANS) (QUOTE SUBR)))) (QUOTE SUBR)))) NIL
(LAMBDA (U) (DEFLIST U (QUOTE EXPR))) ((
(CONSTANT (LAMBDA (U)
   (DEFLIST U (QUOTE CONSTANT))))
(LOSE (LAMBDA (U)
   (FLAG U (QUOTE LOSE))))
(NEWFORM (LAMBDA (U)
   (DEFLIST U (QUOTE NEWFORM))))
(NEWNAM (LAMBDA (U)
   (DEFLIST U (QUOTE NEWNAM))))
))
(LAMBDA (U) (COMPILE (DEFLIST U (QUOTE EXPR)))) ((
(SUBLIS (LAMBDA (U V) (COND
  ((NULL U) V)
        (T ((LAMBDA (X) (COND
      (X (CDR X))
      ((ATOM V) V)
      (T (CONS (SUBLIS U (CAR V)) (SUBLIS U (CDR V))))))
     (SASSOC V U (FUNCTION (LAMBDA NIL NIL))))))))
))
CONSTANT ((
 (**BLANK | |)
 (**COMMA |,|)
 (**DOLLAR $)
 (**ESC |?|) 
 (**LPAR |(|)
 (**MILLION 1000000)
 (**DASH |-|)
 (**DOT |.|)
 (**RPAR |)|)
 (**SEMICOL |;|)
 (**STAR |*|)
(**EMARK $)
 (**FMARK |&|)
 (**QMARK |'|)
 (**SMARK |"|)
 (**XMARK |!|)
 (**EOF EOF)
 (**PLUSS |+|)
 (**ENDMSG |LEAVING REDUCE ...|)
))
NEWNAM ((
 (DIGIT DIGP)
 (EVENP *EVENP)
 (EXPLODE *EXPLODE)
 (LITER LETP)
 (OPEN *OPEN)
(PAIR PAIRX)
 (PRINC PRIN1)
 (RDS *RDS)
 (SPACES XTAB)
 (WRS *WRS)
))
NEWFORM ((
 (*APPLY (LAMBDA (U V) (APPLY U V ALIST)))
 (CAAAAR (LAMBDA (U) (CAAR (CAAR U))))
 (CAAADR (LAMBDA (U) (CAAR (CADR U))))
 (CAADAR (LAMBDA (U) (CAAR (CDAR U))))
 (CAADDR (LAMBDA (U) (CAAR (CDDR U))))
 (CADAAR (LAMBDA (U) (CADR (CAAR U))))
 (CADADR (LAMBDA (U) (CADR (CADR U))))
 (CADDAR (LAMBDA (U) (CADR (CDAR U))))
 (CADDDR (LAMBDA (U) (CADR (CDDR U))))
 (CDAAAR (LAMBDA (U) (CDAR (CAAR U))))
 (CDAADR (LAMBDA (U) (CDAR (CADR U))))
 (CDADAR (LAMBDA (U) (CDAR (CDAR U))))
 (CDDAAR (LAMBDA (U) (CDDR (CAAR U))))
 (CDDADR (LAMBDA (U) (CDDR (CADR U))))
 (CDDDAR (LAMBDA (U) (CDDR (CDAR U))))
 (CDDDDR (LAMBDA (U) (CDDR (CDDR U))))
 (DIVIDE (LAMBDA (U V) (CONS (QUOTIENT U V) (REMAINDER U V))))
 (GENSYM (LAMBDA NIL (GENSYM1 (QUOTE $$$   G$))))
 (ONEP (LAMBDA (N) (EQUAL N 1)))
 (READCH (LAMBDA NIL (READCH NIL)))
))
COMMENT ((DECLARATION OF SPECIAL AND GLOBAL VARIABLES))
COMMENT ((THE FOLLOWING ARE EXTENDED SPECIAL VARIABLES))
SPECIAL ((*S* *S1*))
COMMENT ((THE FOLLOWING VARIABLES ARE GLOBAL TO ALL FUNCTIONS))
SPECIAL((
 IFL* OFL* IPL* OPL* PRI* CRCHAR* SV* MCOND*
 *FORT *ECHO *INT PRECLIS* ORIG* POSN* *NAT YCOORD*
 YMIN* YMAX* *LIST COUNT* *CARDNO ECHO* FORTVAR*
 LLENGTH* PLINE* CURSYM* *MODE MATP* DEFN*
 SEMIC* SYMFG* VARS* TMODE* *SQVAR* PROGRAM* PROGRAML*
 *GCD *EXP *MCD *FLOAT MATCH* *DIV *RAT *SUPER *MSG
 *ALLFAC *NCMP SUBFG* FRLIS1* FRLIS* GAMIDEN* SUB2*
 RPLIS* SUBL* DSUBL* FACTORS* FRASC* VREP* INDICES*
 WTP* SNO* *RAT *OUTP DIAG*
 MCHFG* SYMFG* *ANS *RESUBS *NERO EXLIST* ORDN*
NAT**
))
COMMENT ((THE FOLLOWING VARIABLE IS USED AS A FUNCTIONAL ARGUMENT))
COMMON ((*PI*))
REMPROP (F APVAL)
COMMENT ((REDUCE FUNCTIONS WITH SYSTEM DEPENDENT PROPERTIES))
DEFLIST ((
(INIT (LAMBDA NIL (PROG NIL
 (PTS (QUOTE NOCMP*) T)
 (RECLAIM)
 (REMPROP (QUOTE INIT) (QUOTE EXPR))
 (RETURN (QUOTE ***)))))
) EXPR)
(LAMBDA (U) (COMPILE (DEFLIST U (QUOTE EXPR)))) ((
(PRINTTY (LAMBDA (U)
   (AND *NAT (PRINT U))))
(READCH* (LAMBDA NIL
   (SETQ CRCHAR* (READCH NIL))))
))
 
DEFINE (( 
(MKSTRING (LAMBDA (U) 
   (LIST (QUOTE QUOTE) (COMPRESS (DELETE **SMARK (CDR U)))))) 
)) 
 
COMMENT ((FUNCTIONS FOR MTS IMPLEMENTATION ONLY)) 
 
DEFLIST (((PAUSE NORLIS) (CONT NORLIS)) STAT) 
 
DEFINE (( 
 
(PAUSE (LAMBDA NIL 
   (PROG (Y Z) 
   (COND ((BATCH) (RETURN NIL))) 
   (PRINM (QUOTE ($$$CONT?$))) 
   (COND ((YORN) (RETURN NIL))) 
   (COND ((AND IFL* (NOT (EQ IFL* (CAR IPL*)))) 
           (SETQ IPL* (CONS IFL* IPL*)))) 
   (SETQ IFL* NIL) 
   (SETQ Y *INT) 
   (SETQ *INT T) 
   (SETQ Z *ECHO) 
   (SETQ *ECHO NIL) 
   (RDS (OPEN (QUOTE GUSER) (QUOTE INPUT))) 
   (BEGIN1 T) 
   (SETQ *INT Y) 
   (SETQ *ECHO Z) 
   ))) 
 
(REDMSG1 (LAMBDA (U V) 
   (PROG NIL 
        (PRINM (LIST (QUOTE SHOULD) U (QUOTE BE) 
           (QUOTE DECLARED) V (QUOTE $$$?$))) 
        (RETURN (YORN)) ))) 
 
(PRINM (LAMBDA (U) 
   (PROG (V) 
        (WRS (OPEN (QUOTE SERCOM) (QUOTE OUTPUT))) 
        (SETQ V U) 
A       (PRINC (CAR V)) 
        (PRINC **BLANK) 
        (COND ((SETQ V (CDR V)) (GO A))) 
        (TERPRI) 
        (WRS OFL*) ))) 
 
(READM (LAMBDA NIL 
   (PROG (U) 
        (CLOSE (QUOTE GUSER)) 
        (RDS (OPEN (QUOTE GUSER) (QUOTE INPUT))) 
        (SETQ U (READ)) 
        (RDS IFL*) 
        (RETURN U) ))) 
 
(YORN (LAMBDA NIL 
   (PROG (U) 
A       (SETQ U (READM)) 
        (COND ((EQ U (QUOTE Y)) (RETURN T)) 
              ((EQ U (QUOTE N)) (RETURN NIL))) 
        (PRINM (QUOTE (ILLEGAL $$$RESPONSE.$ ENTER Y OR N))) 
        (GO A) ))) 
))
(LAMBDA (U) (COMPILE (DEFLIST U (QUOTE EXPR)))) ((
(BEGIN (LAMBDA NIL (PROG NIL
 (OVOFF)
 (SETQ NOCMP* T)
 (SETQ *INT (NULL (BATCH))) 
 (SETQ *ECHO (BATCH)) 
 (*WRS NIL) 
 (SETQ ORIG* 0)
 (SETP)
 (SETQ *MODE (QUOTE ALGEBRAIC))
         (COND ((NULL DATE*) (GO A0)))
 (VERBOS NIL)
 (EXCISE T)
 (EXITERR (BATCH)) 
         (EJECT)
         (PRIN1 (QUOTE $$$REDUCE2($))
         (PRIN1 DATE*)
         (PRIN1 (QUOTE $$$) ...$))
         (TERPRI) (SETQ DATE* NIL)
 A0  (SETQ IFL* NIL)
 (SETQ OFL* NIL)
 (RETURN (BEGIN1 NIL)))))
))
COMMENT ((REDUCE FUNCTIONS DEFINED IN TERMS OF SYSTEM FUNCTIONS
          OF THE SAME NAME))
COMMENT ((THE FOLLOWING LIST IS USED BY EXPLODN1 DEFINED BELOW))
DEFLIST (((NASL* (((0 . $$$0$) (1 . $$$1$) (2 . $$$2$) (3 . $$$3$)
            (4 . $$$4$) (5 . $$$5$) (6 . $$$6$) (7 . $$$7$)
            (8 . $$$8$) (9 . $$$9$))))) SPECIAL)
(LAMBDA (U) (COMPILE (DEFLIST U (QUOTE EXPR)))) ((
(*EXPLODE (LAMBDA (U) (COND
  ((NUMBERP U) (EXPLODN U))
  (T (EXPLODE U)))))
(EXPLODN (LAMBDA (U) (COND
  ((ZEROP U) (LIST (QUOTE $$$0$)))
  ((MINUSP U) (CONS (QUOTE $$$-$) (EXPLODN (MINUS U))))
  ((NOT (FIXP U)) (LIST 1 2 3 4 5 6 7 8 9 0 1 2))
  (T (EXPLODN1 U)))))
(EXPLODN1 (LAMBDA (U) (PROG (Z)
 A (COND ((ZEROP U) (RETURN Z)))
   (SETQ Z (CONS (CDR (ASSOC* (REMAINDER U 10) NASL*)) Z))
   (SETQ U (QUOTIENT U 10))
   (GO A))))
(ASSOC* (LAMBDA (U V)
  (COND ((NULL V) NIL)
    ((EQUAL U (CAAR V)) (CAR V))
    (T (ASSOC* U (CDR V))))))
(*OPEN  (LAMBDA (U V) (PROG2 (OPEN U NIL V) U)))
(*RDS (LAMBDA (U) (COND
  ((NULL U) (RDS (QUOTE LISPIN)))
  (T (RDS U)))))
(*WRS (LAMBDA (U) 
   (PROG NIL 
         (WRS (QUOTE LISPOUT)) 
         (COND (U (PROG2 (ASA NIL) (WRS U)))) 
         (OTLL (OTLLNG)) 
         (PTS (QUOTE LLENGTH*) (DIFFERENCE (OTLLNG) 7))))) 
))
LOSE ((ASSOC* REMK*))
COMMENT ((STANDARD LISP FUNCTIONS NOT DEFINED IN LISP/360))
DEFINE ((
(COMPRESS (LAMBDA (U)
   (PROG2 (COND ((DIGIT (CAR U))
                 (MAP U (FUNCTION (LAMBDA (J) (RNUMB (CAR J))))))
           (T    (MAP U (FUNCTION (LAMBDA (J) (RLIT (CAR J)))))))
          (MKATOM))))
(GTS (LAMBDA (U) ((LAMBDA (X) (COND
  ((NULL X) (ERROR (LIST (QUOTE GTS) U)))
  (T (CAR X))))  (GET U (QUOTE SPECIAL)))))
(PTS (LAMBDA (U V) (CAR ((LAMBDA (X) (COND
  ((NULL X) (PUT U (QUOTE SPECIAL) (LIST V)))
  (T (RPLACA X V)))) (GET U (QUOTE SPECIAL))))))
(PUT (LAMBDA (U V W)
  (PROG2 (DEFLIST (LIST (LIST U W)) V) W)))
(*EVAL (LAMBDA (U) ((LAMBDA (X) (COND
      (X (CAR X))
      (T (EVAL U ALIST))))
    (GET* U (QUOTE SPECIAL)))))
(PAIRX (LAMBDA (U V)
   (COND ((AND (NULL U) (NULL V)) NIL)
      ((OR (NULL U) (NULL V)) (ERROR (QUOTE (PAIR MISMATCH))))
    (T (CONS (CONS (CAR U) (CAR V)) (PAIRX (CDR U) (CDR V)))))))
))
COMMENT ((REDEFINING SOME FUNCTIONS EXCISED FROM THE COMPILER))
DEFINE ((
(MAP (LAMBDA (U *PI*)
  (PROG NIL
   A  (COND ((NULL U) (RETURN NIL)))
      (*PI* U)
      (SETQ U (CDR U))
      (GO A))))
(MAPCON (LAMBDA (U *PI*)
   (COND ((NULL U) NIL)
    (T (NCONC (*PI* U) (MAPCON (CDR U) *PI*))))))
(REVERSE (LAMBDA (U)
   (PROG (V)
    A (COND ((NULL U) (RETURN V)))
      (SETQ V (CONS (CAR U) V))
      (SETQ U (CDR U))
      (GO A))))
(SUBST (LAMBDA (U V W)
   (COND ((NULL W) NIL)
      ((EQUAL V W) U)
      ((ATOM W) W)
      (T (CONS (SUBST U V (CAR W)) (SUBST U V (CDR W)))))))
))
COMMENT (ARRAY HANDLING ROUTINES)
DEFINE ((
(*ARRAY (LAMBDA (U)
  (MAP U (FUNCTION (LAMBDA (J)
      (PUT (CAAR J) (QUOTE ARRAY) (MKARRAY (CDAR J))))))))
(MKARRAY (LAMBDA (U)
  (COND ((NULL U) NIL)
   (T (ARLIST (CDR U) (CAR U))))))
(ARLIST (LAMBDA (U N)
  (COND ((ZEROP N) NIL) (T (CONS (MKARRAY U) (ARLIST U (SUB1 N)))))))
(GETEL (LAMBDA (U)
  (GETEL1 (GET (CAR U) (QUOTE ARRAY)) (CDR U))))
(GETEL1 (LAMBDA (U V)
  (COND ((NULL V) U)
  (T (GETEL1 (NTH U (ADD1 (CAR V))) (CDR V))))))
(SETEL (LAMBDA (U V)
   (PROG (X N)
      (SETQ X (REVERSE (CDR U)))
      (SETQ N (CAR X))
      (SETQ X (GETEL1 (GET (CAR U) (QUOTE ARRAY))
                      (REVERSE (CDR X))))
  A    (COND ((EQUAL N 0) (RETURN (RPLACA X V))))
      (SETQ N (SUB1 N))
      (SETQ X (CDR X))
      (GO A))))
))
COMMENT ((I O HANDLING ROUTINES))
DEFINE ((
(IN (LAMBDA (U)
  (INOUT U (QUOTE INPUT))))
(OUT (LAMBDA (U)
  (INOUT U (QUOTE OUTPUT))))
(INOUT (LAMBDA (U V)
  (PROG (ECHO INT)
    (COND ((NOT (ATOMLIS U)) (REDERR (QUOTE (ILLEGAL FILE NAME))))) 
    (SETQ ECHO *ECHO)
    (SETQ INT *INT)
 A  (COND ((NULL U) (GO E))
       ((EQ V (QUOTE OUTPUT)) (GO C))
       ((EQ (CAR U) (QUOTE T)) (GO L)))
    (SETQ IFL* (CAR U))
    (COND ((MEMBER IFL* IPL*) (GO B)))
    (OPEN IFL* V)
    (SETQ IPL* (CONS IFL* IPL*))
  B (RDS IFL*)
    (SETQ *ECHO T)
    (SETQ *INT NIL)
  F (BEGIN1 T) 
    (SETQ U (CDR U))
    (GO A)
  C (COND ((EQ (CAR U) (QUOTE T)) (GO M)))
    (SETQ OFL* (CAR U))
    (COND ((MEMBER OFL* OPL*) (GO D)))
    (OPEN OFL* V)
    (SETQ OPL* (CONS OFL* OPL*))
  D (WRS OFL*)
  E (SETQ *ECHO ECHO)
    (SETQ *INT INT)
    (RETURN NIL)
  L (SETQ IFL* NIL)
    (RDS NIL)
    (SETQ *INT (NOT (BATCH))) 
    (SETQ *ECHO (BATCH)) 
    (GO F) 
  M (SETQ OFL* NIL)
    (WRS NIL)
    (GO E)
)))
(SHUT (LAMBDA (U)
  (PROG (X)
 A  (COND ((NULL U) (RETURN NIL)))
    (SETQ X (CAR U))
    (COND ((MEMBER X OPL*) (GO B))
       ((NOT (MEMBER X IPL*))
         (REDERR (CONS X (QUOTE (NOT OPEN))))))
    (CLOSE X)
    (SETQ IPL* (DELETE X IPL*))
    (COND ((NOT (EQUAL X IFL*)) (GO C)))
       (RDS (SETQ IFL* (COND (IPL* (CAR IPL*)) (T NIL))))
    (GO C)
  B (SETQ OPL* (DELETE X OPL*))
    (CLOSE X)
    (COND ((NOT (EQ X OFL*)) (GO C)))
    (SETQ OFL* NIL)
    (WRS NIL)
  C  (SETQ U (CDR U))
    (GO A))))
))
DEFLIST (((SHUT RLIS) (IN RLIS) (OUT RLIS)) STAT)
COMMENT ((INITIALIZATION OF INPUT AND OUTPUT CHARACTER STRINGS))
CSET (SWITCH* (
 ($ NIL *SEMICOL* NIL)
 (|;| NIL *SEMICOL* NIL)
 (|+| NIL PLUS NIL | + |)
 (|-| NIL MINUS NIL | - |)
 (|*| |*| TIMES EXPT)
 (|/| NIL QUOTIENT NIL)
 (|=| NIL EQUAL NIL)
 (|,| NIL *COMMA* NIL)
 (|(| NIL *LPAR* NIL)
 (|)| NIL *RPAR* NIL)
 (|.| NIL CONS NIL)
 (|:| |=| *COLON* SETQ)
 (|<| |=| LESSP LESSEQ)
 (|>| |=| GREATERP GREATEQ)
 (|&| NIL AND NIL) 
 (\| NIL OR NIL) 
 (|~| |=| NOT UNEQ) 
))
COMMENT ((E N D   O F   R E D U C E   P R E P R O C E S S O R))
COMMENT ((R E D U C E    M A I N    P R O G R A M))
(LAMBDA (U) (MAP U (FUNCTION (LAMBDA (J) (PTS (CAR J) NIL))))) ((*FORT
 *ECHO *INT PRECLIS* ORIG* POSN* *NAT YCOORD* YMIN* YMAX* *LIST COUNT*
 *CARDNO ECHO* FORTVAR* LLENGTH* PLINE* CURSYM* *MODE MATP* DEFN*
 SEMIC* SYMFG* *MSG TMODE* *SQVAR* PROGRAM* PROGRAML* DIAG* VARS*
 CRCHAR* IFL* OFL* IPL* OPL* PRI* ERFG*))
(LAMBDA (U) (MAP U (FUNCTION (LAMBDA (J) (PTS (CAAR J) (CADAR J))))))
(((*NAT T) (COUNT* 1) (*CARDNO 20) (ORIG* 0) (LLENGTH* 67) (*SQVAR* (T
))))
DEFINE ((
(FLAGP** (LAMBDA (U V)
   (AND (ATOM U) (NOT (NUMBERP U)) (FLAGP U V))))
(GET* (LAMBDA (U V)
   (COND ((NUMBERP U) NIL) (T (GET U V)))))
(EQCAR (LAMBDA (U V)
   (AND (NOT (ATOM U)) (EQ (CAR U) V))))
(MKPREC (LAMBDA NIL
   (PROG (X Y)
       (SETQ X (CONS (QUOTE SETQ) PRECLIS*))
       (SETQ Y 2)
    A    (COND ((NULL X) (RETURN NIL)))
       (PUT (CAR X) (QUOTE INFIX) Y)
       (SETQ X (CDR X))
       (SETQ Y (ADD1 Y))
       (GO A))))
))
PTS (PRECLIS* (AND OR MEMBER EQUAL UNEQ EQ GREATEQ GREATERP LESSEQ
 LESSP PLUS MINUS TIMES QUOTIENT EXPT CONS))
(LAMBDA NIL (PROG (W X Y Z) (MKPREC) (SETQ X SWITCH*) (MAP X (FUNCTION
 (LAMBDA (J) (PUT (CAAR J) (QUOTE SWITCH*) (CDAR J))))) A (COND ((NULL
 X) (RETURN NIL))) (SETQ W (CDAR X)) (PUT (CADR W) (QUOTE PRTCH) (LIST
 (CAAR X) (CAAR X))) (COND ((CAR (SETQ Y (CDDR W))) (PROG2 (SETQ Z
(COMPRESS (LIST (CAAR X)(CAR W))))(PUT (CAR Y)(QUOTE PRTCH) (LIST Z Z)
)))) (COND ((NULL (CDR Y)) (GO B)) ((CADR Y) (RPLACA (GET (CADR W)
(QUOTE PRTCH))(CADR Y))))(COND ((CDDR Y)(RPLACA (GET (CAR Y) (QUOTE
 PRTCH)) (CADDR Y)))) B (SETQ X (CDR X)) (GO A))) NIL
DEFLIST (((MINUS (PLUS . MINUS))) ALT)
DEFINE ((
(RVLIS (LAMBDA NIL
   (PROG (X)
    A    (SETQ X (CONS (SCAN) X))
       (COND
        ((OR (FLAGP** (SCAN) (QUOTE DELIM))
             (MEMBER CURSYM* (QUOTE (CLEAR LET MATCH SAVEAS))))
         (RETURN X))
        ((NOT (EQ CURSYM* (QUOTE *COMMA*))) (CURERR NIL T)))
       (GO A))))
(INFIXFN (LAMBDA NIL
   (PROG (X)
       (SETQ X (RVLIS))
       (COND
        ((EQ *MODE (QUOTE ALGEBRAIC))
         (*APPLY (QUOTE OPERATOR) (LIST X))))
       (SETQ PRECLIS* (APPEND X PRECLIS*))
       (MKPREC))))
(PRECEDFN (LAMBDA NIL
   (PROG (W X Y Z)
       (SETQ X (RVLIS))
       (SETQ Y (CAR X))
       (SETQ X (CADR X))
       (SETQ PRECLIS* (DELETE X PRECLIS*))
       (SETQ W PRECLIS*)
    A    (COND ((NULL W) (REDERR (CONS Y (QUOTE (NOT FOUND)))))
             ((EQ Y (CAR W)) (GO B)))
       (SETQ Z (CONS (CAR W) Z))
       (SETQ W (CDR W))
       (GO A)
    B    (SETQ PRECLIS*
             (NCONC (REVERSE Z) (CONS (CAR W) (CONS X (CDR W)))))
       (MKPREC))))
))
DEFINE ((
(MATHPRINT (LAMBDA (L)
   (PROG NIL (MAPRIN L) (TERPRI*))))
(MAPRIN (LAMBDA (U)
   (MAPRINT U 0)))
(MAPRINT (LAMBDA (L P)
   (PROG (X Y)
       (COND ((NULL L) (RETURN NIL))
             ((ATOM L) (GO B))
             ((NOT (ATOM (CAR L))) (MAPRINT (CAR L) P))
             ((SETQ X (GET* (CAR L) (QUOTE INFIX))) (GO A))
             ((SETQ X (GET* (CAR L) (QUOTE SPECPRN)))
            (RETURN (*APPLY X (LIST (CDR L)))))
             (T (PRINC* (CAR L))))
       (PRINC* **LPAR)
       (INPRINT (QUOTE *COMMA*) 0 (CDR L))
    E    (RETURN (PRINC* **RPAR))
    B    (COND ((NUMBERP L) (GO D))
             ((SETQ X (GET L (QUOTE OLDNAME)))
            (RETURN (PRINC* X))))
    C    (RETURN (PRINC* L))
    D    (COND ((NOT (MINUSP L)) (GO C)))
       (PRINC* **LPAR)
       (PRINC* L)
       (GO E)
    A    (SETQ P (NOT (GREATERP X P)))
       (COND ((NOT P) (GO G)))
       (SETQ Y ORIG*)
       (PRINC* **LPAR)
       (COND ((LESSP POSN* 15) (SETQ ORIG* POSN*)))
    G    (INPRINT (CAR L) X (CDR L))
       (COND ((NOT P) (RETURN NIL)))
       (PRINC* **RPAR)
       (SETQ ORIG* Y))))
(INPRINT (LAMBDA (OP P L)
   (PROG NIL
       (COND ((FLAGP OP (QUOTE UNIP)) (GO A)))
       (MAPRINT (CAR L) P)
       (GO C)
    A    (COND ((NULL L) (RETURN NIL))
             ((AND (NOT (ATOM (CAR L)))
                 (GET* (CAAR L) (QUOTE ALT))
                 (EQ OP (CAR (GET* (CAAR L) (QUOTE ALT)))))
            (GO B)))
       (OPRIN OP)
    B    (MAPRINT (CAR L) P)
       (COND ((OR (NOT *NAT) (NOT (EQ OP (QUOTE EXPT)))) (GO C)))
       (SETQ YCOORD* (SUB1 YCOORD*))
       (SETQ YMIN* (*EVAL (LIST (QUOTE MIN) YMIN* YCOORD*)))
    C    (SETQ L (CDR L))
       (GO A))))
))
DEFINE ((
(OPRIN (LAMBDA (OP)
   ((LAMBDA(X)
     (COND ((NULL X) (PRINC* OP))
         (*FORT (PRINC* (CADR X)))
         (*NAT
          (COND ((EQ OP (QUOTE EXPT))
               (PROG NIL
                   (SETQ YCOORD* (ADD1 YCOORD*))
                   (SETQ YMAX*
                         (*EVAL
                        (LIST (QUOTE MAX) YMAX* YCOORD*)))))
              ((AND *LIST
                  (MEMBER OP (QUOTE (PLUS MINUS QUOTIENT))))
               (PROG NIL (CLOSELINE) (TERPRI) (PPRINT (CAR X))))
              (T (PPRINT (CAR X)))))
         (T (PRINC (CAR X)))))
    (GET OP (QUOTE PRTCH)))))
(PRINC* (LAMBDA (U)
   (COND (*NAT (PPRINT U))
       ((NULL *FORT) (PRINC U))
       (T
        (PROG NIL
            (COND
             ((AND (EQUAL COUNT* *CARDNO)
                   (OR (EQ U **PLUSS) (EQ U **DASH)))
              (GO B))
             ((NOT
               (GREATERP (SETQ POSN*
                           (PLUS POSN* (LENGTH (EXPLODE U))))
                             69))
              (GO A)))
            (TERPRI)
            (SPACES 5)
            (PRINC (QUOTE X))
         (SETQ POSN* (PLUS 6 (LENGTH (EXPLODE U))))
            (SETQ COUNT* (ADD1 COUNT*))
          A    (RETURN (COND (ECHO* (PRINC U)) (T NIL)))
          B    (TERPRI)
            (SETQ POSN* 0) 
            (COND ((NULL FORTVAR*) (GO A))) 
            (SPACES 6)
            (SETQ POSN* 6) 
            (PRINC* FORTVAR*) 
            (OPRIN (QUOTE EQUAL))
            (PRINC* FORTVAR*) 
            (SETQ COUNT* 1)
            (GO A))))))
(TERPRI* (LAMBDA NIL
   (COND (*NAT (PROG NIL (CLOSELINE) (COND (ECHO* (TERPRI)))))
         (*FORT (COND ((ZEROP POSN*) NIL)
                      (T (PROG NIL (TERPRI) (SETQ COUNT* 1)
                             (SETQ POSN* 0)))))
       (T (TERPRI)))))
(PPRINT (LAMBDA (U)
   (PROG (M N)
       (SETQ N (LENGTH (EXPLODE U)))
       (COND ((GREATERP N LLENGTH*) (GO A1)))
    C    (SETQ M (PLUS POSN* N))
       (COND ((AND (GREATERP M LLENGTH*) (NOT (TERPRI*))) (GO C)))
       (SETQ PLINE*
             (CONS (CONS (CONS (CONS POSN* M) YCOORD*) U) PLINE*))
    A    (RETURN (SETQ POSN* M))
    A1   (TERPRI*)
       (PRINC U)
       (RETURN (SETQ POSN* (REMAINDER N LLENGTH*))))))
(CLOSELINE (LAMBDA NIL
   (PROG (N)
       (COND ((OR (NULL PLINE*) (NULL ECHO*)) (GO C)))
       (SETQ N YMAX*)
       (SETQ PLINE* (REVERSE PLINE*))
    A    (SCPRINT PLINE* N)
       (COND ((EQUAL N YMIN*) (GO B)))
       (TERPRI)
       (SETQ N (SUB1 N))
       (GO A)
    B    (COND ((EQ ECHO* (QUOTE RESULT)) (TERPRI)))
    C    (SETP))))
(SCPRINT (LAMBDA (U N)
   (PROG (M)
       (SETQ POSN* 0)
    A    (COND ((NULL U) (RETURN NIL))
             ((NOT (EQUAL (CDAAR U) N)) (GO B))
             ((NOT (MINUSP (SETQ M (DIFFERENCE (CAAAAR U) POSN*))))
            (SPACES M)))
       (PRINC (CDAR U))
       (SETQ POSN* (CDAAAR U))
    B    (SETQ U (CDR U))
       (GO A))))
(SPACES* (LAMBDA (N)
   (COND (*NAT (SETQ POSN* (PLUS N POSN*))) (T (SPACES N)))))
))
DEFINE ((
(SETP (LAMBDA NIL
   (PROG NIL
       (SETQ PLINE* NIL)
       (SETQ POSN* ORIG*)
       (SETQ YMAX* 0)
       (SETQ YMIN* 0)
       (SETQ YCOORD* 0))))
))
FLAG ((MINUS NOT) UNIP)

DEFINE ((
(MREAD* (LAMBDA (J)
   (PROG2 (SCAN) (MREAD J))))
(MREAD (LAMBDA (J)
   (PROG (U V W W1 X Y Z)
       (SETQ Z -1)
    A    (SETQ V CURSYM*)
       (COND ((OR (NOT (ATOM V)) (NUMBERP V)) (GO B))
             ((FLAGP V (QUOTE DELIM)) (GO ERR1))
             ((EQ V (QUOTE *LPAR*)) (GO E))
             ((AND (EQ V (QUOTE *RPAR*)) (NULL U)) (RETURN NIL)))
       (SETQ X (GET V (QUOTE INFIX)))
    B0   (COND ((SETQ W (GET* V (QUOTE ISTAT))) (GO L)))
    B    (SETQ W (SCAN))
    BX   (SETQ Y NIL)
       (COND ((OR (NOT (ATOM W)) (NUMBERP W)) (GO B2))
            ((FLAGP W (QUOTE DELIM)) (GO ENDD))
             ((EQ W (QUOTE *LPAR*)) (GO E2))
             ((EQ W (QUOTE *RPAR*)) (GO END0))
             (U (GO B1)))
    BY   (COND
        ((AND J
            (EQ W (QUOTE *COMMA*))
            (NOT (MEMBER J (QUOTE (MAT PAREN FUNC)))))
         (RETURN V)))
    B1   (SETQ Y (GET W (QUOTE INFIX)))
  B2        (COND ((NULL X) (GO SYM))
             ((NOT (FLAGP V (QUOTE UNARY))) (GO ERR3)))
    C    (SETQ Z X)
       (SETQ U (CONS (LIST V) U))
       (SETQ V W)
       (SETQ X Y)
       (COND ((OR (NOT (ATOM V)) (NUMBERP V)) (GO B)) (T (GO B0)))
    SYM  (COND ((NULL Y) (GO M))
             ((AND (NULL W1)
                 (SETQ W1 (GET W (QUOTE ALT)))
                 (SETQ W (CAR W1)))
            (GO B1)))
 SYM1   (COND  ((OR (NULL Z) (LESSP Y Z)) (GO H))
             ((OR (GREATERP Y Z) (FLAGP W (QUOTE BINARY))) (GO G)))
       (SETQ U (CONS (ACONC (CAR U) V) (CDR U)))
       (GO G1)
    E    (SETQ V
             (MREAD*
            (COND ((EQ J (QUOTE MAT)) (QUOTE FUNC))
                  (T (QUOTE PAREN)))))
       (GO B)
    E2   (COND ((EQ V (QUOTE MAT))
            (SETQ V (CONS V (REMCOMMA (MREAD* (SETQ MATP* V))))))
                ((AND (ATOM V) (GET V (QUOTE UNARY))
                 (SETQ W (CAR (MREAD* (QUOTE FUNC))))) (GO C))
             ((OR (ATOM V) (EQ *MODE (QUOTE SYMBOLIC)))
            (SETQ V (CONS V (MREAD* (QUOTE FUNC)))))
             (T (GO ERR4)))
         (SETQ X NIL)
         (GO B)
    G    (SETQ U (CONS (LIST W V) U))
       (SETQ Z Y)
    G1   (COND (W1 (GO G2)))
       (SCAN)
  G3     (SETQ X NIL)
       (GO A)
    G2   (SETQ CURSYM* (CDR W1))
       (SETQ W1 NIL)
       (GO G3)
    H    (SETQ V (ACONC (CAR U) V))
       (SETQ U (CDR U))
       (COND ((AND (NULL U) (SETQ Z 0)) (GO BY)))
       (SETQ Z (GET (CAAR U) (QUOTE INFIX)))
       (GO SYM1)
    L    (SETQ V (*APPLY W NIL))
       (SETQ W CURSYM*)
       (GO BX)
    M    (COND ((NUMBERP V) (GO ERR4))
             ((PROGVR V)
            (LPRIM*
             (APPEND (QUOTE (PROGRAM VARIABLE))
                   (CONS V
                         (QUOTE (USED AS OPERATOR)))))))
       (GO C)
    END0 (COND ((NULL J) (GO ERR21)) (T (GO END2)))
    ENDD (COND ((MEMBER J (QUOTE (MAT PAREN FUNC))) (GO ERR22)))
    END2 (COND (X (GO ERR1)))
    END1 (COND
        ((NULL U)
         (RETURN (COND ((EQ J (QUOTE FUNC)) (REMCOMMA V)) (T V)))))
       (SETQ V (ACONC (CAR U) V))
       (SETQ U (CDR U))
       (GO END1)
    ERR1 (CURERR (QUOTE (SYNTAX ERROR)) NIL)
    ERR21
       (CURERR (QUOTE (TOO MANY RIGHT PARENTHESES)) NIL)
    ERR22
       (CURERR (QUOTE (TOO FEW RIGHT PARENTHESES)) NIL)
    ERR3 (CURERR (QUOTE (REDUNDANT OPERATOR)) 1)
    ERR4 (CURERR (QUOTE (MISSING OPERATOR)) NIL))))
(ACONC (LAMBDA (U V)
   (NCONC U (LIST V))))
(REMCOMMA (LAMBDA (U)
   (COND ((EQCAR U (QUOTE *COMMA*)) (CDR U)) (T (LIST U)))))
(SCAN (LAMBDA NIL
   (PROG (X Y)
       (COND ((EQ CURSYM* (QUOTE *SEMICOL*)) (TERPRI*)))
    A    (COND ((EQ CRCHAR* **BLANK) (GO L))
             ((EQ CRCHAR* **EOF) (GO EOF)) 
             ((DIGIT CRCHAR*) (GO G))
             ((LITER CRCHAR*) (GO E))
             ((EQ CRCHAR* **XMARK) (GO E0))
             ((EQ CRCHAR* **QMARK) (GO P))
             ((EQ CRCHAR* **SMARK) (RETURN (COMM1 NIL)))
             ((NULL (SETQ X (GET* CRCHAR* (QUOTE SWITCH*))))
            (GO B))
             ((EQ (SETQ Y (CADR X)) (QUOTE *SEMICOL*)) (GO J))
             ((EQ (READCH*) (CAR X)) (GO K)))
    C    (SETQ CURSYM* (CADR X))
    D    (COND ((OR ECHO* *NAT) (SYMPRI CURSYM*))) 
       (COND
        ((SETQ X (GET* CURSYM* (QUOTE NEWNAME))) (SETQ CURSYM* X)))
    D1   (RETURN CURSYM*)
    E0   (READCH*)
    E    (SETQ Y (CONS CRCHAR* Y))
       (COND
        ((OR (DIGIT (READCH*)) (LITER CRCHAR*)) (GO E))
        ((EQ CRCHAR* **XMARK) (GO E0)))
       (GO H)
    G    (SETQ Y (CONS CRCHAR* Y))
       (SETQ X CRCHAR*)
       (COND
        ((OR (DIGIT (READCH*))
             (EQ CRCHAR* **DOT)
             (EQ CRCHAR* (QUOTE E))
             (EQ X (QUOTE E)))
         (GO G)))
    H    (SETQ CURSYM* (COMPRESS (REVERSE Y)))
       (GO D)
    J    (SETQ SEMIC* CRCHAR*)
       (SETQ CRCHAR* **BLANK)
       (GO C)
    K    (READCH*)
       (SETQ CURSYM* (CADDR X))
       (GO D)
    B    (COND ((EQ CRCHAR* **ESC) (ERROR **ESC))
             (Y
            (CURERR (CONS CRCHAR* (QUOTE (INVALID CHARACTER)))
                   NIL)))
       (SETQ CURSYM* CRCHAR*)
       (READCH*)
       (GO D)
    L    (READCH*)
       (GO A)
    P    (SETQ CURSYM* (LIST (QUOTE QUOTE) (READ)))
       (READCH*)
       (COND ((OR ECHO* *NAT) (MAPRIN CURSYM*))) 
         (GO D1) 
    EOF (SETQ CURSYM* (QUOTE END)) 
        (SETQ CRCHAR* **SEMICOL) 
        (GO D) )))
))
DEFINE ((
(LPRI (LAMBDA (U)
   (PROG NIL
    A    (COND ((NULL U) (RETURN NIL)))
       (PRINC* (CAR U))
       (SPACES* 1)
       (SETQ U (CDR U))
       (GO A))))
(LPRIE (LAMBDA (U X)
   (PROG NIL (SETQ ERFG* T) (LPRIW U X (QUOTE *****)))))
(REDERR (LAMBDA (U)
   (PROG2 (LPRIE U T) (ERROR*))))
(LPRIW (LAMBDA (U X Y)
   (PROG (V W)
         (COND ((AND OFL* (OR *FORT (NOT *NAT))) (GO D)))
       (TERPRI*)
    A    (SETQ V U)
       (PRINC Y)
       (PRINC **BLANK)
    B    (COND ((NULL V) (GO C)))
       (PRINC (CAR V))
       (PRINC **BLANK)
       (SETQ V (CDR V))
       (GO B)
    C    (COND (X (TERPRI)))
       (COND ((NULL OFL*) (RETURN NIL)) (W (RETURN (WRS OFL*))))
     D (WRS NIL)
       (SETQ W T)
       (GO A))))
))
DEFLIST (((*COMMA* 1)) INFIX)
FLAG ((CONS EXPT QUOTIENT) BINARY)
FLAG ((PLUS MINUS TIMES NOT *COMMA*) UNARY)
FLAG ((*COLON* *SEMICOL*) DELIM)
DEFINE ((
(COMMAND (LAMBDA NIL
   (PROG2 (SCAN) (COMMAND1 (QUOTE TOP)))))
(COMMAND1 (LAMBDA (U)
   (PROG (V X Y)
  A0        (COND ((NOT (ATOM U)) (SETQ V (CAR U)))
               ((AND (EQ CURSYM* (QUOTE *SEMICOL*))
                 (LIST (SCAN))) (GO A0))
             ((NOT (SETQ Y (GET* (SETQ V CURSYM*) (QUOTE STAT))))
            (SETQ V (MREAD
                     (AND (NOT (EQ U (QUOTE TOP)))
                       (OR (EQ U (QUOTE IF))
                          (EQ *MODE (QUOTE SYMBOLIC))))))))
       (SETQ U (AND (NOT (EQ *MODE (QUOTE SYMBOLIC))) 
                    (OR PRI* (EQ U (QUOTE TOP)) (EQ U (QUOTE PRI))))) 
       (COND (Y (GO B))
             ((EQ CURSYM* (QUOTE *COLON*)) (RETURN V))
             ((EQCAR V (QUOTE SETQ)) (GO C))
             ((OR (EQUAL *MODE (QUOTE SYMBOLIC))
                (EQCAR V (QUOTE QUOTE))
                (AND (NUMBERP V) (FIXP V)))
            (SETQ Y V))
             ((EQCAR V (QUOTE EQUAL)) (GO C))
             (T (SETQ Y (LIST (QUOTE AEVAL) (MKARG V)))))
    A    (COND ((AND U (OR PRI* (EQ SEMIC* **SEMICOL))) 
            (SETQ Y (LIST (QUOTE VARPRI) X Y PRI*)))
             ((AND PRI* (EQ *MODE (QUOTE SYMBOLIC)))
            (SETQ Y (LIST (QUOTE PRINC) Y))))
       (RETURN Y)
    B    (SETQ Y (*APPLY Y NIL))
       (SETQ U (AND U (MEMBER V (QUOTE (BEGIN FOR IF)))))
       (GO A)
    C    (SETQ V (CDR V))
       (COND ((NULL (CDDR V)) (GO D)))
       (SETQ X PRI*)
       (SETQ PRI* NIL)
       (SETQ Y (COMMAND1 (LIST (CONS (QUOTE SETQ) (CDR V)))))
       (SETQ PRI* X)
       (SETQ X NIL)
    D    (COND ((EQ *MODE (QUOTE SYMBOLIC)) (GO E))
             (U
            (SETQ X
                  (CONS (QUOTE LIST)
                      (MAPCAR
                       (REVERSE (CDR (REVERSE V)))
                       (FUNCTION MKARG*))))))
       (COND ((NULL (CDDR V))
         (SETQ Y (LIST (QUOTE AEVAL) (MKARG (CADR V))))))
       (SETQ Y
             (COND
            ((AND (ATOM (CAR V)) (PROGVR (CAR V)))
             (LIST (QUOTE SETQ) (CAR V) Y))
            (T (LIST (QUOTE SETK) (MKARG (CAR V)) Y))))
       (GO A)
    E    (COND ((NULL (CDDR V)) (SETQ Y (CADR V))))
       (SETQ Y
             (COND
            ((ATOM (CAR V)) (LIST (QUOTE SETQ) (CAR V) Y))
            ((GET* (CAAR V) (QUOTE **ARRAY))
             (LIST (QUOTE SETEL) (CAR V) Y))
            (T (PROCDEF1 (CAR V) Y))))
       (GO A))))
(MKARG (LAMBDA (U)
   (COND ((NULL U) NIL)
       ((ATOM U) (COND ((PROGVR U) U) (T (LIST (QUOTE QUOTE) U))))
       ((MEMBER (CAR U) (QUOTE (COND PROG QUOTE))) U)
       (T (CONS (QUOTE LIST) (MAPCAR U (FUNCTION MKARG)))))))
(MKARG* (LAMBDA (U)
   (COND ((NULL U) NIL)
         ((ATOM U) (LIST (QUOTE QUOTE) U))
       (T (CONS (QUOTE LIST) (MAPCAR U (FUNCTION MKARG)))))))
(MKPROG (LAMBDA (U V)
   (CONS (QUOTE PROG) (CONS U V))))
(PROGVR (LAMBDA (VAR)
   (COND ((NOT (ATOM VAR)) NIL)
       ((NUMBERP VAR) T)
       (T
        ((LAMBDA (X) (COND (X (CAR X)) (T NIL)))
         (GET VAR (QUOTE DATATYPE)))))))
))
DEFINE ((
(LPRIM* (LAMBDA (U)
   (PROG (X Y)
       (COND ((AND OFL* (OR *FORT (NOT *NAT))) (GO C)))
  A        (SETQ X *NAT)
       (SETQ *NAT NIL)
       (LPRI (CONS (QUOTE ***) U))
       (TERPRI)
       (SETQ *NAT X)
      (COND ((NULL Y) (GO B)))
      (WRS Y)
       (RETURN NIL)
  B        (COND ((NULL OFL*) (RETURN NIL)))
     C (SETQ Y OFL*)
       (WRS NIL)
       (GO A))))
(SYMPRI (LAMBDA (U)
   (PROG (X)
       (COND
        ((EQ U (QUOTE *SEMICOL*)) (PRINC* SEMIC*))
        ((SETQ X (GET* U (QUOTE PRTCH))) (PRINC* (CAR X)))
        (T (GO B)))
       (RETURN (SETQ SYMFG* NIL))
    B    (COND (SYMFG* (SPACES* 1)))
       (PRINC* U)
       (SETQ SYMFG* T))))
(CURERR (LAMBDA (U V)
   (PROG (X)
       (SETQ ECHO* T)
       (TERPRI)
       (SETQ X CURSYM*)
       (COND ((NULL PLINE*) (GO B))
             ((EQUAL V 1)
            (SETQ PLINE*
                  (CONS (CAR PLINE*)
                      (CONS
                       (CONS (CONS (CAAADR PLINE*) -1) **EMARK)
                       (CDR PLINE*)))))
             (T
            (SETQ PLINE*
                  (CONS (CONS (CONS (CAAAR PLINE*) -1) **EMARK)
                       PLINE*))))
       (SETQ YMIN* -1)
    B    (COMM1*)
       (COND ((NUMBERP V) (SETQ V NIL)))
       (COND ((AND (NULL U) (NULL V)) (GO A))
             ((NULL V) (LPRIE U T))
             (T (LPRIE
               (CONS X
                   (CONS (QUOTE INVALID)
                         (COND
                        (U
                         (LIST (QUOTE IN)
                                U
                               (QUOTE STATEMENT)))
                        (T NIL))))
               T)))
    A    (ERROR*))))
(ERROR* (LAMBDA NIL
   (PROG2 (TERPRI*) (ERROR NIL))))
))
DEFINE ((
(GREATEQ (LAMBDA (U V)
   (OR (EQUAL U V) (GREATERP U V))))
(LESSEQ (LAMBDA (U V)
   (OR (EQUAL U V) (LESSP U V))))
(UNEQ (LAMBDA (U V)
   (NOT (EQUAL U V))))
(REDMSG (LAMBDA (U V W)
   (COND ((NULL *MSG) T)
       ((AND *INT W) (REDMSG1 U V))
       (T (NULL (LPRIM* (LIST U (QUOTE DECLARED) V)))))))
(DELETE (LAMBDA (U V)
   (COND ((NULL V) NIL)
       ((EQUAL U (CAR V)) (CDR V))
       (T (CONS (CAR V) (DELETE U (CDR V)))))))
(SETDIFF (LAMBDA (U V)
   (COND ((NULL V) U) (T (SETDIFF (DELETE (CAR V) U) (CDR V))))))
(XN (LAMBDA (U V)
   (COND ((NULL U) NIL)
       ((MEMBER (CAR U) V)
        (CONS (CAR U) (XN (CDR U) (DELETE (CAR U) V))))
       (T (XN (CDR U) V)))))
))
DEFINE ((
(PROCDEF (LAMBDA NIL
   (PROG (X Y)
       (COND ((ATOM (SETQ X (MREAD* NIL))) (SETQ X (LIST X))))
       (SCAN)
         (SETQ Y (FLAGTYPE (CDR X) (QUOTE SCALAR)))
         (SETQ X (PROCDEF1 X (COMMAND1 NIL)))
         (REMTYPE Y)
         (RETURN X))))
(PROCDEF1 (LAMBDA (U BODY)
   (PROG (NAME VARLIS)
       (SETQ NAME (CAR U))
       (COND
        ((OR (NULL NAME) (NOT (ATOM NAME)) (NUMBERP NAME))
         (CURERR NAME NIL))
        ((NOT (GETD NAME)) (FLAG (LIST NAME) (QUOTE FNC))))
       (COND ((EQCAR BODY (QUOTE PROG)) (SETQ VARLIS (CADR BODY))))
       (COND (VARLIS (RPLACA (CDR BODY) (SETDIFF VARLIS (CDR U)))))
       (SETQ VARLIS (CDR U))
       (AND (NOT (FLAGP NAME (QUOTE FNC)))
            (LPRIM* (LIST NAME (QUOTE REDEFINED))))
       (DEF* NAME VARLIS BODY DEFN*)
        (REMFLAG (LIST NAME) (QUOTE FNC)) 
       (RETURN (LIST (QUOTE QUOTE) NAME)))))
(FLAGTYPE (LAMBDA (U V)
   (PROG (X Y Z)
    A    (COND ((NULL U) (RETURN (REVERSE Z))))
       (SETQ X (CAR U))
       (COND ((GET X (QUOTE SIMPFN))
              (REDERR (APPEND (QUOTE (TYPE CONFLICT FOR)) (LIST X)))))
       (SETQ Y (GET X (QUOTE DATATYPE)))
       (PUT X (QUOTE DATATYPE) (CONS V Y))
       (SETQ Z (CONS X Z))
    C  (SETQ U (CDR U))
       (GO A))))
(REMTYPE (LAMBDA (VARLIS)
   (PROG (X Y)
    A    (COND ((NULL VARLIS) (RETURN NIL)))
       (SETQ X (CAR VARLIS))
       (SETQ Y (CDR (GET X (QUOTE DATATYPE))))
       (COND (Y (PUT X (QUOTE DATATYPE) Y))
             (T (REMPROP X (QUOTE DATATYPE))))
       (SETQ VARLIS (CDR VARLIS))
       (GO A))))
(NEWVAR (LAMBDA (U)
   (COMPRESS (CONS **FMARK (EXPLODE U)))))
(DEF* (LAMBDA (NAME VARLIS BODY FN)
   (*APPLY FN
         (LIST
          (LIST (LIST NAME (LIST (QUOTE LAMBDA) VARLIS BODY)))))))
))
DEFINE ((
(PROCBLOCK (LAMBDA NIL
   (PROG (X HOLD VARLIS)
       (SCAN)
       (COND ((MEMBER CURSYM* (QUOTE (NIL *RPAR*))) (ERROR **ESC)))
       (SETQ VARLIS (DECL T))
    A    (COND ((EQ CURSYM* (QUOTE END)) (GO B)))
       (SETQ X (COMMAND1 NIL))
       (COND ((EQCAR X (QUOTE END)) (GO C)))
       (AND (NOT (EQ CURSYM* (QUOTE END))) (SCAN))
       (COND (X (SETQ HOLD (ACONC HOLD X))))
       (GO A)
    B    (COMM1 (QUOTE END))
    C    (REMTYPE VARLIS)
         (COND ((NOT (EQ *MODE (QUOTE SYMBOLIC)))
            (SETQ HOLD (ACONC HOLD (QUOTE (RETURN 0))))))
       (RETURN (MKPROG VARLIS HOLD)))))
(DECL* (LAMBDA NIL
   (MAP (DECL NIL) (FUNCTION (LAMBDA (J)
        (PUT (CAR J) (QUOTE SPECIAL) (LIST NIL)))))))
(DECL (LAMBDA (U)
   (PROG (V W VARLIS)
    A    (COND
        ((NOT (MEMBER CURSYM* (QUOTE (REAL INTEGER SCALAR))))
         (RETURN VARLIS)))
       (SETQ W CURSYM*)
       (COND ((EQ (SCAN) (QUOTE PROCEDURE)) (RETURN (ALGFN))))
       (SETQ V (FLAGTYPE (REMCOMMA (MREAD NIL)) W))
       (SETQ VARLIS (APPEND V VARLIS))
       (AND (NOT (EQ CURSYM* (QUOTE *SEMICOL*))) (CURERR NIL T))
       (AND U (SCAN))
       (GO A))))
(GOFN (LAMBDA NIL
   (PROG (VAR)
       (SETQ VAR
             (COND ((EQ (SCAN) (QUOTE TO)) (SCAN)) (T CURSYM*)))
       (SCAN)
       (RETURN (LIST (QUOTE GO) VAR)))))
(RETFN (LAMBDA NIL
   (LIST (QUOTE RETURN)
         (COND ((FLAGP** (SCAN) (QUOTE DELIM)) NIL)
               (T (COMMAND1 NIL))))))
(ENDFN (LAMBDA NIL
   (PROG2 (COMM1 (QUOTE END)) (QUOTE (END)))))
))
DEFINE ((
(FORSTAT (LAMBDA NIL
   (COND ((EQ (SCAN) (QUOTE ALL)) (FORALLFN*)) (T (FORLOOP)))))
(FORLOOP (LAMBDA NIL
   (PROG (CURS EXP INCR INDX CONDLIST BODY FLG FNC LAB1 LAB2)
       (SETQ FNC (GENSYM))
       (SETQ EXP (MREAD T))
       (COND
        ((AND (EQ (CAR EXP) (QUOTE *COMMA*))
            (EQCAR (CADR EXP) (QUOTE SETQ)))
         (SETQ EXP
             (LIST NIL
                   (CADADR EXP)
                   (CONS (QUOTE *COMMA*)
                       (NCONC (CDDADR EXP) (CDDR EXP))))))
        ((NOT (MEMBER (CAR EXP) (QUOTE (SETQ EQUAL)))) (GO ERR)))
       (SETQ EXP (CDR EXP))
       (COND
        ((OR (NOT (ATOM (SETQ INDX (CAR EXP)))) (NUMBERP INDX))
         (GO ERR)))
       (SETQ INDX (CAR (FLAGTYPE (LIST INDX) (QUOTE INTEGER))))
    A    (SETQ EXP (REMCOMMA (CADR EXP)))
    A1   (COND ((NULL EXP) (GO B2))
             ((CDR EXP) (SETQ FLG T))
             ((EQ CURSYM* (QUOTE STEP)) (GO B1))
             ((EQ CURSYM* (QUOTE *COLON*)) (GO BB)))
       (SETQ CONDLIST
             (NCONC CONDLIST
                  (LIST (LIST (QUOTE SETQ) INDX (MKEX (CAR EXP)))
                      (LIST FNC))))
    B0   (SETQ EXP (CDR EXP))
       (GO A1)
    B1   (SETQ INCR (MKEX (MREAD* NIL)))
       (COND
        ((NOT (MEMBER (SETQ CURS CURSYM*) (QUOTE (UNTIL WHILE))))
         (GO ERR)))
    AA   (SETQ LAB1 (GENSYM))
       (SETQ LAB2 (GENSYM))
       (SETQ CONDLIST
             (ACONC CONDLIST(LIST (QUOTE SETQ) INDX (MKEX (CAR EXP)))))
       (SETQ EXP (REMCOMMA (MREAD* NIL)))
       (SETQ BODY (MKEX (CAR EXP)))
       (SETQ CONDLIST
             (NCONC CONDLIST
                  (LIST LAB1
                      (LIST (QUOTE COND)
                          (LIST
                           (COND
                            ((EQ CURS (QUOTE UNTIL))
                             (COND
                              ((NUMBERP INCR)
                               (LIST
                              (COND
                               ((MINUSP INCR)
                                (QUOTE LESSP))
                               (T (QUOTE GREATERP)))
                              INDX
                              BODY))
                              (T
                               (LIST
                              (QUOTE MINUSP)
                              (LIST
                               (QUOTE TIMES)
                               (LIST
                                (QUOTE DIFFERENCE)
                                BODY
                                INDX)
                               INCR)))))
                            (T (LIST (QUOTE NOT) BODY)))
                           (LIST (QUOTE GO) LAB2)))
                      (LIST FNC)
                      (LIST (QUOTE SETQ)
                           INDX
                          (LIST (QUOTE PLUS) INDX INCR))
                      (LIST (QUOTE GO) LAB1)
                       LAB2)))
       (AND (CDR EXP) (SETQ FLG T))
       (GO B0)
    BB   (SETQ INCR 1)
       (SETQ CURS (QUOTE UNTIL))
       (GO AA)
    B2   (COND ((NULL CONDLIST) (GO ERR))
             ((MEMBER CURSYM* (QUOTE (SUM PRODUCT))) (GO C))
             ((NOT (EQ CURSYM* (QUOTE DO))) (GO ERR)))
       (SCAN)
       (SETQ BODY (COMMAND1 NIL))
    B    (COND (FLG (DEF* FNC NIL BODY (QUOTE DEFINE)))
             (T (SETQ CONDLIST (ADFORM BODY (LIST FNC) CONDLIST))))
         (REMTYPE (LIST INDX))
       (RETURN (MKPROG (CONS INDX EXP) (ACONC CONDLIST
                                 (QUOTE (RETURN NIL)))))
    C    (SETQ CURS CURSYM*)
       (SETQ EXP (GENSYM))
       (SETQ BODY
             (LIST (QUOTE SETQ)
                  EXP
                 (LIST
                  (COND
                   ((EQ CURS (QUOTE SUM)) (QUOTE ADDSQ))
                   (T (QUOTE MULTSQ)))
                  (LIST (QUOTE AEVAL1) (MKARG (MREAD* T)))
                  EXP)))
       (SETQ CONDLIST
             (CONS (LIST (QUOTE SETQ)
                      EXP
                     (LIST (QUOTE CONS)
                         (COND
                          ((EQ CURS (QUOTE SUM)) NIL)
                          (T 1))
                          1))
                 (ACONC CONDLIST
                      (LIST (QUOTE RETURN)
                          (LIST (QUOTE MK*SQ)
                              (LIST (QUOTE SUBS2) EXP))))))
       (SETQ EXP (LIST EXP))
       (GO B)
    ERR  (CURERR (QUOTE FOR) T))))
(ADFORM (LAMBDA (U V W)
   (COND ((NULL W) NIL)
       ((EQUAL V (CAR W))
        ((LAMBDA(X)
          (COND (X (APPEND X (CDR W))) (T (CONS U (CDR W)))))
         (PROGCHK U)))
       (T (CONS (CAR W) (ADFORM U V (CDR W)))))))
(PROGCHK (LAMBDA (U)
   (PROG (X)
       (COND
        ((OR (NOT (EQCAR U (QUOTE PROG))) (CADR U)) (RETURN NIL)))
       (SETQ U (CDR U))
    A    (SETQ U (CDR U))
       (COND ((NULL U) (RETURN (REVERSE X)))
             ((ATOM (CAR U)) (GO B))
             ((EQCAR (CAR U) (QUOTE RETURN)) (GO RET))
             ((EQCAR (CAR U) (QUOTE PROG)) (GO B))
             ((MEMBER (QUOTE RETURN) (FLATTEN (CAR U)))
            (RETURN NIL)))
    B    (SETQ X (CONS (CAR U) X))
       (GO A)
   RET   (COND ((CDR U) (RETURN NIL))
               ((NOT (ATOM (CADAR U))) (SETQ X (CONS (CADAR U) X))))
         (GO A))))
(FLATTEN (LAMBDA (U)
   (COND ((NULL U) NIL)
       ((ATOM U) (LIST U))
       ((ATOM (CAR U)) (CONS (CAR U) (FLATTEN (CDR U))))
       (T (NCONC (FLATTEN (CAR U)) (FLATTEN (CDR U)))))))
))
DEFINE ((
(IFSTAT (LAMBDA NIL
   (PROG (CONDX CONDIT)
       (FLAG (QUOTE (CLEAR LET MATCH)) (QUOTE DELIM))
    A    (SETQ CONDX (MREAD* T))
         (REMFLAG (QUOTE (CLEAR LET MATCH)) (QUOTE DELIM))
       (COND ((NOT (EQ CURSYM* (QUOTE THEN))) (GO C)))
       (SCAN)
         (SETQ CONDIT(ACONC CONDIT (LIST (MKEX CONDX) (COMMAND1 NIL))))
       (COND ((NOT (EQ CURSYM* (QUOTE ELSE))) (GO B))
             ((EQ (SCAN) (QUOTE IF)) (GO A))
             (T
            (SETQ CONDIT
                  (ACONC CONDIT
                       (LIST T (COMMAND1 (QUOTE IF)))))))
    B    (RETURN (CONS (QUOTE COND) CONDIT))
    C    (COND
        ((NOT (MEMBER CURSYM* (QUOTE (CLEAR LET MATCH))))
         (CURERR (QUOTE IF) T)))
       (SETQ MCOND* (MKEX CONDX))
       (RETURN (FORALLFN (GVARB CONDX))))))
(MKEX (LAMBDA (U)
  (COND ((EQ *MODE (QUOTE SYMBOLIC)) U) (T (APROC U)))))
(APROC (LAMBDA (U)
   (COND ((NULL U) NIL)
       ((ATOM U)
        (COND ((AND (NUMBERP U) (FIXP U)) U)
            (T (LIST (QUOTE REVAL) (MKARG U)))))
       ((MEMBER (CAR U) (QUOTE (COND PROG))) U)
       ((MEMBER (CAR U) (QUOTE (EQUAL UNEQ)))
        (LIST (CAR U)
            (LIST (QUOTE REVAL)
                  (MKARG
                   (LIST (QUOTE PLUS)
                       (CADR U)
                       (LIST (QUOTE MINUS) (CARX (CDDR U))))))
             0))
       (T (CONS (CAR U) (MAPCAR (CDR U) (FUNCTION APROC)))))))
(ARB (LAMBDA (U)
   T))
(GVARB (LAMBDA (U)
   (COND ((ATOM U) (COND ((NUMBERP U) NIL) (T (LIST U))))
       ((EQ (CAR U) (QUOTE QUOTE)) NIL)
       (T
        (MAPCON (CDR U) (FUNCTION (LAMBDA (J) (GVARB (CAR J)))))))))
))
FLAG ((THEN ELSE END STEP DO SUM PRODUCT UNTIL WHILE) DELIM)
DEFINE ((
(ALGFN (LAMBDA NIL
   (ALGFN* (QUOTE ALGEBRAIC))))
(LSPFN (LAMBDA NIL
   (ALGFN* (QUOTE SYMBOLIC))))
(ALGFN* (LAMBDA (U)
   (PROG (X)
       (COND ((EQ CURSYM* (QUOTE PROCEDURE)) (GO A))
             ((EQ CURSYM* (QUOTE MACRO)) (SETQ DEFN* CURSYM*))
             ((EQ CURSYM* (QUOTE FEXPR))
            (SETQ DEFN* (QUOTE DEFEXPR))))
       (COND
        ((FLAGP** (SCAN) (QUOTE DELIM)) (GO B)))
    A    (SETQ TMODE* *MODE)
       (SETQ *MODE U)
       (COND
        ((NOT (EQ CURSYM* (QUOTE PROCEDURE)))
         (RETURN (COMMAND1 (QUOTE PRI))))) 
       (SETQ X (PROCDEF))
       (COND
            ((NOT (EQ U (QUOTE SYMBOLIC)))(FLAG (CDR X)(QUOTE OPFN))))
         (RETURN (CONS (QUOTE QUOTE) (CDR X)))
    B  (SETQ *MODE U))))
(RLIS (LAMBDA NIL
   (RLIS* T)))
(NORLIS (LAMBDA NIL
   (RLIS* NIL)))
(RLIS* (LAMBDA (U)
   (PROG (X Y)
       (SETQ X CURSYM*)
         (COND ((FLAGP** (SCAN) (QUOTE DELIM)) (GO A)))
       (SETQ Y (REMCOMMA (MREAD NIL)))
       (COND (U (SETQ Y (LIST Y))))
    A    (RETURN (CONS X (MAPCAR Y (FUNCTION MKARG)))))))
))
DEFINE ((
(COMM1* (LAMBDA NIL
   (COMM1 T)))
(COMM1 (LAMBDA (U)
   (PROG (X Y Z) 
       (SETQ X ECHO*) 
       (COND
        ((AND (EQ U (QUOTE END))
            (MEMBER (SCAN) (QUOTE (ELSE END UNTIL *RPAR*))))
         (GO RET1)))
       (COND (U (GO LOOP)) (X (PRINC* CRCHAR*)))
       (SETQ Y (LIST CRCHAR*))
       (GO A)
   LOOP (COND ((EQ CRCHAR* **EOF) (GO RET)) 
            ((NULL U) (GO L1)) 
             ((EQ CURSYM* (QUOTE *SEMICOL*)) (GO RET1))
             ((OR (EQ CRCHAR* **SEMICOL)
                (EQ CRCHAR* **DOLLAR)
                (EQ CRCHAR* **ESC))
            (GO RET)))
   L1   (COND ((NULL X) (GO L3))) 
        (COND ((NULL U) (PRINC* CRCHAR*)) 
              ((BREAKP CRCHAR*) (GO L2)) 
              (T (PROG2 (RLIT CRCHAR*) (SETQ Z T)))) 
   L3 
       (COND
        ((OR (NULL U) (EQ U (QUOTE END)))
         (SETQ Y (CONS CRCHAR* Y))))
       (COND
        ((AND (EQ U (QUOTE END))
            (EQ CRCHAR* (QUOTE D))
            (EQCAR (CDR Y) (QUOTE N))
            (EQCAR (CDDR Y) (QUOTE E))
            (SETQ CRCHAR* **BLANK)
            (SETQ CURSYM* (QUOTE END)))
         (GO RET1))
        ((AND (NULL U) (EQ CRCHAR* **SMARK)) (GO RETS)))
    A    (SETQ CRCHAR* (READCH*))
       (GO LOOP)
   L2   (COND (Z (PRINC* (MKATOM)))) 
        (SETQ Z NIL) 
        (PRINC* CRCHAR*) 
        (COND ((NOT (EQ CRCHAR* **BLANK)) (GO L3)) 
              ((EQ U (QUOTE END)) (SETQ Y NIL))) 
   L4   (COND ((EQ (READCH*) **BLANK) (GO L4))) 
        (GO LOOP) 
   RET  (COND ((AND X Z) (PROG2 (PRINC* (MKATOM)) (SETQ Z NIL)))) 
        (SCAN) 
   RET1 (COND ((AND X Z) (PRINC* (MKATOM)))) 
        (RETURN (COND (X (TERPRI*)) (T NIL))) 
    RETS (SETQ CURSYM* (MKSTRING (REVERSE Y)))
       (READCH*)
       (RETURN CURSYM*))))
(QOTPRI (LAMBDA (U)
   (PROG2 (PRINC* **QMARK) (PRIN0* (CAR U)))))
(PRIN0* (LAMBDA (U)
   (PROG NIL
       (COND ((ATOM U) (RETURN (PRINC* U))))
       (PRINC* **LPAR)
    A    (COND ((NULL U) (GO B)) ((ATOM U) (GO C)))
       (PRIN0* (CAR U))
       (COND ((CDR U) (PRINC* **BLANK)))
       (SETQ U (CDR U))
       (GO A)
    B    (RETURN (PRINC* **RPAR))
    C    (PRINC* **DOT)
       (PRINC* **BLANK)
       (PRINC* U)
       (GO B))))
))
DEFLIST (((QUOTE QOTPRI)) SPECPRN)
DEFINE ((
(LMDEF (LAMBDA NIL
   (PROG (X)
       (COND
        ((NOT (EQ *MODE (QUOTE SYMBOLIC)))
         (CURERR (QUOTE ALGEBRAIC) T)))
       (SETQ CURSYM* (QUOTE *COMMA*))
       (SETQ X (MREAD NIL))
       (RETURN (LIST (QUOTE LAMBDA) (CDR X) (COMMAND1 NIL))))))
(WRITEFN (LAMBDA NIL
   (PROG (X Y Z)
       (SETQ X (MREAD* NIL))
       (SETQ PRI* T)
       (SETQ X
             (COND
            ((EQCAR X (QUOTE *COMMA*)) (CDR X))
            (T (LIST X))))
    A    (COND ((NULL X) (GO B)))
         (SETQ Z (COMMAND1 (LIST (CAR X))))
         (COND ((NULL (CDR X)) (SETQ Z (LIST (QUOTE RETURN) Z))))
         (SETQ Y (ACONC Y Z))
       (SETQ X (CDR X))
       (GO A)
    B    (SETQ PRI* NIL)
       (RETURN (MKPROG NIL (CONS (QUOTE (TERPRI*)) Y))))))
))
DEFINE ((
(ON1 (LAMBDA (U V)
   (PROG (X)
    A    (COND ((NULL U) (RETURN NIL)))
       (PTS (COMPRESS (APPEND (EXPLODE **STAR) (EXPLODE (CAR U))))
             V)
       (COND
        ((SETQ X (ASSOC V (GET* (CAR U) (QUOTE SIMPFG))))
           (*APPLY (CONVRT (CDR X) T) NIL))) 
       (SETQ U (CDR U))
       (GO A))))
(ON (LAMBDA (U)
   (ON1 U T)))
(OFF (LAMBDA (U)
   (ON1 U NIL)))
))
DEFINE ((
(AARRAY (LAMBDA (U)
   (PROG (X Y)
    A    (COND ((NULL U) (RETURN NIL)))
       (SETQ X (CAR U))
       (COND
        ((OR (NUMBERP (CAR X))
               (NOT (ATOM (CAR X)))
             (GET (CAR X) (QUOTE SIMPFN))
               (GET (CAR X) (QUOTE APROP)))
           (REDERR (APPEND (QUOTE (TYPE CONFLICT FOR))
                (LIST (CAR X)))))
          ((NOT (NUMLIS (SETQ Y (MAPCAR (CDR X)
             (FUNCTION REVAL))))) (PROG2 (ERRPRI2 X) (ERROR*)))) 
         (PUT (CAR X) (QUOTE **ARRAY) Y)
         (*ARRAY
          (LIST (CONS (CAR X) (MAPCAR Y (FUNCTION ADD1)))))
    B    (SETQ U (CDR U))
       (GO A))))
(NUMLIS (LAMBDA (U)
   (OR (NULL U) (AND (NUMBERP (CAR U)) (NUMLIS (CDR U))))))
))
DEFLIST (((AARRAY RLIS)) STAT)
(LAMBDA NIL (PUT (QUOTE ARRAY) (QUOTE NEWNAME) (QUOTE AARRAY))) NIL
DEFINE ((
(BEGIN1 (LAMBDA (U) 
   (PROG (RESULT)
       (SETQ CURSYM* NIL)
  A    (TERPRI)
         (COND ((AND TMODE* (SETQ *MODE TMODE*)) (SETQ TMODE* NIL)))
       (SETQ ECHO* (AND *ECHO (NOT (AND OFL* (OR *FORT (NULL *NAT)))))) 
       (SETQ ERFG* NIL)
         (COND ((EQ CURSYM* (QUOTE END)) (GO ND0)))
       (SETQ CRCHAR* **BLANK)
       (SETQ DEFN* (QUOTE DEFINE))
         (OVOFF)
       (SETQ PROGRAM* (ERRORSET (QUOTE (COMMAND)) T))
       (COND ((OR (ATOM PROGRAM*) (CDR PROGRAM*)) (GO ERR1)))
       (SETQ PROGRAM* (CAR PROGRAM*))
       (COND
        ((EQ (CAR PROGRAM*) (QUOTE RETRY))
         (SETQ PROGRAM* PROGRAML*))
          ((EQCAR PROGRAM* (QUOTE *COMMA*)) (GO ER))
        ((EQ (CAR PROGRAM*) (QUOTE END)) (GO ND1))
        ((EQ (CAR PROGRAM*) (QUOTE CONT)) (GO C)) 
        (DIAG* (GO D)))
  B    (TERPRI*) 
       (SETQ ECHO* (QUOTE RESULT))
       (SETP)
         (OVON)
       (SETQ RESULT
              (ERRORSET (CONVRT (GTS (QUOTE PROGRAM*)) T) T)) 
       (COND ((OR (ATOM RESULT) (CDR RESULT)) (GO ERR2))
        ((EQ *MODE (QUOTE SYMBOLIC)) (AND (EQ SEMIC* **SEMICOL)
         (PROG2 (PRINT (CAR RESULT)) (TERPRI))))
         ((CAR RESULT) (SETQ *ANS (CAR RESULT))))
       (SETQ ORIG* 0)
       (CLOSELINE)
       (COND ((NULL (OR *INT OFL* *FORT)) (PRINTTY **STAR))) 
       (GO A)
  C    (COND ((NOT U) (GO A))) 
       (COND (IFL* (GO ND1))) 
       (SETQ IFL* (COND (IPL* (CAR IPL*)) (T NIL))) 
       (RDS IFL*) 
       (TERPRI*) 
       (RETURN NIL) 
  D        (COND ((OR (ATOM PROGRAM*)(EQ (CAR PROGRAM*) (QUOTE QUOTE)))
            (GO A))
          ((FLAGP (CAR PROGRAM*) (QUOTE IGNORE)) (GO B)))
         (PRINT (CONVRT PROGRAM* NIL))
       (GO A)
  ND0    (COMM1 (QUOTE END))
  ND1
       (RETURN (FINF U)) 
    ERR1 (COND ((OR (EQ PROGRAM* **ESC) (EQ PROGRAM* **EOF)) (GO A)))
       (GO ERR3)
    ER        (LPRIE (COND ((NOT (ATOM (CADR PROGRAM*)))
            (LIST (CAADR PROGRAM*) (QUOTE UNDEFINED)))
               (T (QUOTE (SYNTAX ERROR)))) T)
       (GO ERR3)
    ERR2 (SETQ PROGRAML* PROGRAM*)
       (SETP) 
    ERR3 (COND
          ((NULL ERFG*)
        (LPRIE (QUOTE (COMMAND TERMINATED *****)) T))) 
       (SETQ ORIG* 0)
       (TERPRI*)
        (COND (IFL* (PAUSE))) 
       (GO A))))
(FINF (LAMBDA (U) 
   (PROG NIL
       (COND (U (GO A))) 
       (MAPCAR (APPEND IPL* OPL*) (FUNCTION CLOSE))
       (SETQ IFL* NIL) 
       (SETQ IPL* NIL)
       (SETQ OPL* NIL)
       (SETQ OFL* NIL)
       (LPRIW NIL T **ENDMSG)
       (RETURN (QUOTE ***))
    A  (COND ((NOT IFL*) (RETURN NIL))) 
       (SHUT (LIST IFL*)) 
       (LPRIM* NIL))))
))
DEFLIST (((FOR FORSTAT) (FORALL FORALLFN*) (IF IFSTAT) (BEGIN PROCBLOCK
) (IN RLIS) (OUT RLIS) (SHUT RLIS) (GO GOFN) (GOTO GOFN) (RETURN RETFN
 ) (INTEGER DECL*) (SCALAR DECL*) (WRITE WRITEFN) (
REAL DECL*) (LISP LSPFN) (ALGEBRAIC ALGFN) (RETRY NORLIS) (PROCEDURE
 ALGFN)(MACRO LSPFN)(FEXPR LSPFN) (SYMBOLIC LSPFN) (ON RLIS) (OFF RLIS
) (END ENDFN) (COMMENT COMM1*) (INFIX INFIXFN) (PRECEDENCE PRECEDFN))
STAT)
DEFLIST (((BEGIN PROCBLOCK) (FOR FORSTAT) (IF IFSTAT) (LAMBDA LMDEF))
ISTAT)
(LAMBDA (U) (MAP U (FUNCTION (LAMBDA (J) (PTS (CAR J) NIL))))) ((*GCD
*EXP *MCD *FLOAT MATCH* *DIV *RAT *SUPER MCOND* *ALLFAC *NCMP SUBFG*
FRLIS1* FRLIS* GAMIDEN* SUB2* RPLIS* SUBL* DSUBL* FACTORS* FRASC* VREP*
 INDICES* WTP* SNO* PNO* *RAT *OUTP MCHFG* *ANS *RESUBS *NERO EXLIST*
ORDN* *XDN SV* DNL* UPL* EXPTL*))
(LAMBDA (U) (MAP U (FUNCTION (LAMBDA (J) (PTS (CAAR J) (CADAR J))))))
(((*EXP T) (*MSG T) (*ALLFAC T) (*MCD T) (SUBFG* T) (EXLIST* ((*)))
 (*RESUBS T) (ORDN* 0) (*ANS 0) (SNO* 500) (*XDN T)))
DEFLIST (((EXP ((NIL . RMSUBS1) (T . RMSUBS))) (MCD ((NIL . RMSUBS1) (
T . RMSUBS))) (FORT ((NIL LAMBDA NIL (SETQ *NAT NAT**)) (T LAMBDA NIL
(PROG2 (SETQ NAT** *NAT) (SETQ *NAT NIL))))) (GCD ((T . RMSUBS)))
 (FLOAT ((T . RMSUBS)))) SIMPFG)
DEFLIST (((ANTISYMMETRIC RLIS)(CLEAR RLIS)(DENOM NORLIS) (FACTOR RLIS)
 (LET RLIS) (MATCH RLIS) (MKCOEFF NORLIS) (ND NORLIS) (NUMER NORLIS)
 (MTS NORLIS) 
 (OPERATOR RLIS) (ORDER RLIS) (REMFAC RLIS) (SAVEAS NORLIS) (SYMMETRIC
 RLIS) (TERMS NORLIS) (WEIGHT RLIS)) STAT)
DEFLIST (((PLUS SIMPPLUS) (MINUS SIMPMINUS) (EXPT SIMPEXPT) (SUB
SIMPSUBS)(DF SIMPDF)(RECIP SIMPRECIP)(QUOTIENT SIMPQUOT) (*SQ SIMP*SQ)
 (TIMES SIMPTIMES)) SIMPFN)
DEFLIST (((*ANS (SCALAR)) (*MODE (SCALAR))) DATATYPE)
DEFLIST (((I (I NIL (REP (MINUS 1) 2 NIL)))) APROP)
DEFINE ((
(ABS (LAMBDA (N)
   (COND ((MINUSP N) (MINUS N)) (T N))))
(ASSOC (LAMBDA (U V)
   (SASSOC U V (FUNCTION (LAMBDA NIL NIL)))))
(ASSOC* (LAMBDA (U V)
   (COND ((NULL V) NIL)
       ((EQUAL U (CAAR V)) (CAR V))
       (T (ASSOC* U (CDR V))))))
(ATOMLIS (LAMBDA (U)
   (OR (NULL U) (AND (ATOM (CAR U)) (ATOMLIS (CDR U))))))
(CARX (LAMBDA (U)
   (COND ((NULL (CDR U)) (CAR U)) (T (ERRACH (LIST (QUOTE CARX) U)))))
)
(DELASC (LAMBDA (U V)
   (COND ((NULL V) NIL)
       ((OR (ATOM (CAR V)) (NOT (EQUAL U (CAAR V))))
        (CONS (CAR V) (DELASC U (CDR V))))
       (T (CDR V)))))
(MAPCONS (LAMBDA (U *S*)
   (MAPCAR U (FUNCTION (LAMBDA (J) (CONS *S* J))))))
(MAPC2 (LAMBDA (U *PI*)
   (MAPCAR U
         (FUNCTION
          (LAMBDA(J)
           (MAPCAR J (FUNCTION (LAMBDA (K) (*PI* K)))))))))
(MEXPR (LAMBDA (U V)
   (COND ((NULL V) NIL)
       ((ATOM V) (EQ U V))
       (T (OR (MEXPR U (CAR V)) (MEXPR U (CDR V)))))))
(NCONS (LAMBDA (U V)
   (COND ((NULL U) V) (T (CONS U V)))))
(NLIST (LAMBDA (U N)
   (COND ((ZEROP N) NIL) (T (CONS U (NLIST U (SUB1 N)))))))
(NTH (LAMBDA (U N)
   (COND ((ONEP N) (CAR U)) (T (NTH (CDR U) (SUB1 N))))))
(POSN (LAMBDA (U V)
   (COND ((EQ U (CAR V)) 1) (T (ADD1 (POSN U (CDR V)))))))
(REMOVE (LAMBDA (X N)
   (COND ((MINUSP N) (ERRACH (LIST (QUOTE REMOVE) X N)))
       ((NULL X) NIL)
       ((ZEROP N) (CDR X))
       (T (CONS (CAR X) (REMOVE (CDR X) (SUB1 N)))))))
(REVPR (LAMBDA (U)
   (CONS (CDR U) (CAR U))))
(RPLACW (LAMBDA (U V)
   (COND
    ((OR (ATOM U) (ATOM V)) (ERRACH (LIST (QUOTE RPLACW) U V)))
    (T (RPLACD (RPLACA U (CAR V)) (CDR V))))))
(REPEATS (LAMBDA (X)
   (COND ((NULL X) NIL)
       ((MEMBER (CAR X) (CDR X)) (CONS (CAR X) (REPEATS (CDR X))))
       (T (REPEATS (CDR X))))))
(UNION (LAMBDA (X Y)
   (COND ((NULL X) Y)
       (T
        (UNION (CDR X)
             (COND ((MEMBER (CAR X) Y) Y)
                   (T (CONS (CAR X) Y))))))))
))
DEFINE ((
(REPPRI (LAMBDA (U V)
   (MESPRI NIL U (QUOTE (REPRESENTED BY)) V NIL)))
(REDEFPRI (LAMBDA (U)
   (COND ((NULL U) NIL)
       (T
        (MESPRI (QUOTE (ASSIGNMENT FOR))
               U
              (QUOTE (REDEFINED))
               NIL
               NIL)))))
(MESPRI (LAMBDA (U V W X Y)
   (PROG (Z)
       (COND
        ((AND (NULL Y) (NULL *MSG)) (RETURN NIL))
        ((AND OFL* (OR *FORT (NOT *NAT))) (GO B)))
    A    (LPRIM U)
       (MAPRIN V)
       (PRINC* **BLANK)
       (LPRI W)
       (MATHPRINT X)
       (COND ((NULL OFL*) (RETURN NIL)) (Z (RETURN (WRS OFL*))))
    B    (WRS NIL)
       (SETQ Z T)
       (GO A))))
(LPRIM (LAMBDA (U)
   (PROG2 (TERPRI*) (LPRI (CONS (QUOTE ***) U)))))
(ERRACH (LAMBDA (U)
   (PROG NIL
       (LPRIE (QUOTE (CATASTROPHIC ERROR *****)) T)
       (PRINTTY U)
       (PRINTTY **BLANK)
       (LPRIE (QUOTE
             (PLEASE SEND
                    OUTPUT
                    AND
                    INPUT
                    LISTING
                    TO
                THE COMPUTING CENTER 
                    *****))
             T)
       (ERROR*))))
(ERRPRI1 (LAMBDA (U)
   (MESPRI (QUOTE (ASSIGNMENT)) U (QUOTE (NOT ALLOWED)) NIL T)))
(ERRPRI2 (LAMBDA (U)
   (MESPRI (QUOTE (FORMAT)) U (QUOTE (INCORRECT)) NIL T)))
))
DEFINE ((
(ORDAD (LAMBDA (A U)
   (COND ((NULL U) (LIST A))
       ((ORDP A (CAR U)) (CONS A U))
       (T (CONS (CAR U) (ORDAD A (CDR U)))))))
(ORDN (LAMBDA (U)
   (COND ((NULL U) NIL)
       ((NULL (CDR U)) U)
       ((NULL (CDDR U)) (ORD2 (CAR U) (CADR U)))
       (T (ORDAD (CAR U) (ORDN (CDR U)))))))
(ORD2 (LAMBDA (U V)
   (COND ((ORDP U V) (LIST U V)) (T (LIST V U)))))
(ORDP (LAMBDA (U V)
   (COND ((NULL U) (NULL V))
         ((NULL V) T)
       ((ATOM U)
        (COND
         ((ATOM V)
          (COND ((NUMBERP U) (AND (NUMBERP V) (NOT (LESSP U V))))
              ((NUMBERP V) T)
              (T (ORDERP U V))))
         (T T)))
       ((ATOM V) NIL)
       ((EQUAL (CAR U) (CAR V)) (ORDP (CDR U) (CDR V)))
       (T (ORDP (CAR U) (CAR V))))))
))
DEFINE ((
(ADDSQ (LAMBDA (U V)
   (COND ((EQUAL (CDR U) (CDR V))
        (CONS (ADDF (CAR U) (CAR V)) (CDR U)))
       ((NULL (CAR U)) V)
       ((NULL (CAR V)) U)
       ((NULL *MCD) (CONS (ADDF (MKSQP U) (MKSQP V)) 1))
       (T
        ((LAMBDA(Z)
          ((LAMBDA(X Y)
         (COND ((OR (NULL X) (NULL Y)) (ERRACH (QUOTE ADDSQ))) (T
            (CONS (ADDF (MULTF Y (CAR U)) (MULTF X (CAR V)))
                (MULTF Y (CDR U))))
                   ))
           (QUOTF (CDR U) Z)
           (QUOTF (CDR V) Z)))
         (GCD1 (CDR U) (CDR V)))))))
(ADDF (LAMBDA (U V)
   (COND ((NULL U) V)
       ((NULL V) U)
       ((ATOM U) (ADDN U V))
       ((ATOM V) (ADDN V U))
       ((EQUAL (CAAR U) (CAAR V))
        ((LAMBDA(X)
          (COND ((NULL X) (ADDF (CDR U) (CDR V)))
              (T
               (CONS (CONS (CAAR U) X) (ADDF (CDR U) (CDR V))))))
         (ADDF (CDAR U) (CDAR V))))
       ((ORDP (CAAR U) (CAAR V)) (CONS (CAR U) (ADDF (CDR U) V)))
       (T (CONS (CAR V) (ADDF U (CDR V)))))))
(ADDN (LAMBDA (N V)
   (COND ((NULL V) N)
       ((ATOM V)
        ((LAMBDA (M) (COND ((ZEROP M) NIL) (T M))) (PLUS N V)))
       (T (CONS (CAR V) (ADDN N (CDR V)))))))
(MULTSQ (LAMBDA (U V)
   (COND
    ((OR (NULL (CAR U)) (NULL (CAR V))) (CONS NIL 1))
    (T
     ((LAMBDA(X Y)
       (COND ((AND X Y) (CONS (MULTF X Y) 1))
           (X (CONS (MULTF X (CAR V)) (CDR U)))
           (Y (CONS (MULTF (CAR U) Y) (CDR V)))
           (T
            (CONS (MULTF (CAR U) (CAR V))
                (MULTF (CDR U) (CDR V))))))
      (QUOTF (CAR U) (CDR V))
      (QUOTF (CAR V) (CDR U)))))))
(MULTF (LAMBDA (U V)
   (PROG (X Y Z)
       (COND ((OR (NULL U) (NULL V)) (RETURN NIL))
             ((ATOM U) (RETURN (MULTN U V)))
             ((ATOM V) (RETURN (MULTN V U)))
             ((OR *EXP *NCMP) (GO A)))
       (SETQ U (MKSFP U 1))
       (SETQ V (MKSFP V 1))
       (COND ((ATOM U) (RETURN (MULTN U V)))
             ((ATOM V) (RETURN (MULTN V U))))
    A    (SETQ X (CAAAR U))
       (SETQ Y (CAAAR V))
       (COND
        ((OR (ATOM X)
             (ATOM Y)
             (NOT (ATOM (CAR X)))
             (NOT (ATOM (CAR Y))))
         (GO B))
        ((AND (EQ (CAR X) (CAR Y))
            (SETQ Z (GET (CAR X) (QUOTE MRULE)))
            (NOT
             (EQ (SETQ Z (*APPLY Z (LIST (CAAR U) (CAAR V))))
                 (QUOTE FAILED))))
         (RETURN
          (ADDF (MULTF Z (MULTF (CDAR U) (CDAR V)))
              (ADDF (MULTF (LIST (CAR U)) (CDR V))
                  (MULTF (CDR U) V)))))
        ((AND (FLAGP (CAR X) (QUOTE NONCOM))
            (FLAGP (CAR Y) (QUOTE NONCOM)))
         (GO B1)))
    B    (COND ((EQ X Y) (GO C))
            ((ORDP (CAAR U) (CAAR V)) (GO B1)))
         (SETQ X (MULTF U (CDAR V)))
         (SETQ Y (MULTF U (CDR V)))
         (RETURN (COND ((NULL X) Y) (T (CONS (CONS (CAAR V) X) Y))))
    B1   (SETQ X (MULTF (CDAR U) V))
         (SETQ Y (MULTF (CDR U) V))
         (RETURN (COND ((NULL X) Y) (T (CONS (CONS (CAAR U) X) Y))))
    C    (SETQ X (MKSP X (PLUS (CDAAR U) (CDAAR V))))
       (SETQ Y
             (ADDF (MULTF (LIST (CAR U)) (CDR V))
                 (MULTF (CDR U) V)))
       (RETURN
        (COND
         ((NULL (CDR X))
          (COND ((NULL (CAAR X)) Y)
              (T
               (ADDF (MULTF (CAAR X)
                        (MULTF (CDAR U)
                               (COND
                              ((EQUAL (CDAR X) 1) (CDAR V))
                              (T
                               (MULTF
                                (MKSQP (CONS 1 (CDAR X)))
                                (CDAR V))))))
                    Y))))
           ((NULL (SETQ U (MULTF (CDAR U) (CDAR V)))) Y)
           (T (CONS (CONS X U) Y)))))))
(MULTF2 (LAMBDA (U V)
   (MULTF (LIST (CONS U 1)) V)))
(MULTN (LAMBDA (N V)
   (COND ((NULL V) NIL)
       ((ZEROP N) NIL)
       ((ONEP N) V)
       ((NUMBERP V) (TIMES N V))
         ((EQ (CAR V) (QUOTE QUOTIENT))
                (MKFR (TIMES N (CADR V)) (CADDR V)))
       (T
        (CONS (CONS (CAAR V) (MULTN N (CDAR V)))
            (MULTN N (CDR V)))))))
))
DEFINE ((
(REVAL (LAMBDA (U)
   (COND ((AND (NUMBERP U) (FIXP U)) U)
       ((VECTORP U) U)
       (T ((LAMBDA (X)
           (COND ((AND (EQCAR X (QUOTE MINUS)) (NUMBERP (CADR X)))
                   (MINUS (CADR X)))
               (T X)))
           (PREPSQ (AEVAL1 U)))))))
(AEVAL (LAMBDA (U)
   (COND
    ((EQCAR U (QUOTE *COMMA*)) (REDERR (QUOTE (SYNTAX ERROR))))
    (T (MK*SQ (AEVAL1 U))))))
(AEVAL1 (LAMBDA (U)
   (PROG2 (RSET2)
        (COND ((MATEXPR U) (MATSM U)) (T (SUBS2 (SIMP* U)))))))
(MATEXPR (LAMBDA (U)
   NIL))
(MK*SQ (LAMBDA (U)
   (COND ((NULL (CAR U)) 0)
       ((AND (ATOM (CAR U)) (EQUAL (CDR U) 1)) (CAR U))
       ((EQCAR U (QUOTE MAT)) U)
       (T (CONS (QUOTE *SQ) (CONS U *SQVAR*))))))
(RSET2 (LAMBDA NIL
   (PROG2 (MAP RPLIS*
             (FUNCTION (LAMBDA (J) (RPLACW (CDAR J) (CAAR J)))))
        (SETQ RPLIS* NIL))))
))
DEFINE ((
(MKSP (LAMBDA (U P)
   (PROG (V X Y)
       (SETQ U (FKERN U))
    A0   (SETQ V (CDDR U))
    A    (COND ((OR (NULL V) (NULL SUBFG*)) (GO B))
             ((SETQ X (ASSOC (QUOTE ASYMP) V)) (GO L1))
             ((SETQ X (ASSOC (QUOTE REP) V)) (GO L2))
             ((AND (NOT (ATOM (CAR U)))
                 (ATOM (CAAR U))
                 (FLAGP (CAAR U) (QUOTE VOP))
                 (VCREP U))
            (GO A0)))
    B    (RETURN (GETPOWER U P))
    L1   (COND
        ((NOT (LESSP P (CDR X))) (RETURN (LIST (CONS NIL 1)))))
       (SETQ V (DELASC (CAR X) V))
       (GO A)
    L2   (SETQ V (CDDDR X))
       (COND ((LESSP P (CADDR X)) (GO B))
               ((AND (CAR V)
                 (NOT (FLAGP** (CAR U) (QUOTE WEIGHT)))) (GO L3)))
       (SETQ SUBL* (CONS V SUBL*))
       (SETQ Y (SIMPCAR (CDR X)))
       (COND
        ((NOT (ASSOC (QUOTE HOLD) (CDDR U))) (GO L21))
        ((EQUAL (CDR Y) 1) (SETQ Y (CONS (MKSFP (CAR Y) 1) 1)))
        (T (SETQ Y (MKSQP Y))))
   L21   (RPLACA V (MK*SQ Y))
         (GO L31)
   L3    (SETQ Y (SIMPCAR V))
         (COND((AND(EQCAR (CAR V)(QUOTE *SQ))(NULL(CADDAR V)))(GO L21)))
   L31   (SETQ V Y)
         (SETQ X (CADDR X))
       (COND ((ONEP X) (RETURN (LIST (NMULTSQ V P)))))
       (SETQ Y (DIVIDE P X))
    C    (SETQ V (NMULTSQ V (CAR Y)))
       (COND
        ((NOT (ZEROP (CDR Y)))
         (SETQ V
             (CONS (MULTF2 (GETPOWER U (CDR Y)) (CAR V))
                   (CDR V)))))
         (RETURN (LIST V)))))
(FKERN (LAMBDA (U)
   (PROG (V)
       (COND ((NOT (ATOM U)) (GO A0))
             ((SETQ V (GET U (QUOTE APROP))) (RETURN V)))
       (SETQ V (LIST U NIL))
       (PUT U (QUOTE APROP) V)
       (RETURN V)
    A0   (COND ((NOT (ATOM (CAR U))) (SETQ V EXLIST*))
             ((NOT (SETQ V (GET (CAR U) (QUOTE KLIST)))) (GO B)))
    A    (COND ((EQUAL U (CAAR V)) (RETURN (CAR V)))
             ((ORDP U (CAAR V))
            (RETURN
             (CAR
              (RPLACW V
                    (CONS (LIST U NIL)
                        (CONS (CAR V) (CDR V)))))))
             ((NULL (CDR V))
            (RETURN (CADR (RPLACD V (LIST (LIST U NIL)))))))
       (SETQ V (CDR V))
       (GO A)
    B    (SETQ V (LIST (LIST U NIL)))
       (PUT (CAR U) (QUOTE KLIST) V)
       (GO A))))
(GETPOWER (LAMBDA (U N)
   (PROG (V)
         (COND ((AND SUBFG* (NOT (ASSOC (QUOTE USED*) (CDR U))))
                (ACONC U (LIST (QUOTE USED*)))))
       (SETQ V (CADR U))
       (COND
        ((NULL V)
         (RETURN (CAAR (RPLACA (CDR U) (LIST (CONS (CAR U) N)))))))
    A    (COND ((EQUAL N (CDAR V)) (RETURN (CAR V)))
             ((LESSP N (CDAR V))
            (RETURN
             (CAR
              (RPLACW V
                    (CONS (CONS (CAAR V) N)
                                 (CONS (CAR V) (CDR V)))))))
       ((NULL (CDR V))
          (RETURN (CADR (RPLACD V (LIST (CONS (CAAR V) N)))))))
       (SETQ V (CDR V))
       (GO A))))
(NMULTSQ (LAMBDA (U N)
   (PROG (X)
       (COND
          ((NULL (CAR U)) (RETURN U))
        ((NULL *EXP)
         (RETURN (CONS (MKSFP (CAR U) N) (MKSFP (CDR U) N)))))
       (SETQ X U)
    A    (COND ((ONEP N) (RETURN X)))
       (SETQ X (MULTSQ U X))
       (SETQ N (SUB1 N))
       (GO A))))
))
DEFINE ((
(MKSF (LAMBDA (U N)
   ((LAMBDA(X)
     (COND
      ((NULL (CDR X))
       (COND ((EQUAL (CDAR X) 1) (CAAR X))
           (T (MULTF (MKSQP (CONS 1 (CDAR X))) (CAAR X)))))
      (T (LIST (CONS X 1)))))
    (MKSP U N))))
(MKSFP (LAMBDA (U N)
   (COND ((KERNLP U) (NMULTF U N))
       (T
        (PROG2 (SETQ SUB2* T)
             (COND ((MINUSF U) (MULTN -1 (MKSF (MULTN -1 U) N)))
                   (T (MKSF U N))))))))
(MKSQP (LAMBDA (U)
   (COND ((NULL (CAR U)) NIL)
       ((OR (EQUAL (CDR U) 1) (EQUAL (CDR (SETQ U (CANCEL U))) 1))
        (COND (*EXP (CAR U)) (T (MKSFP (CAR U) 1))))
       (T
        (PROG NIL
            (SETQ SUB2* T)
            (RETURN
             (COND (*EXP
                  (MULTF (CAR U)
                         (MKSF (MK*SQ
                              (CONS 1 (MKSFP (CDR U) 1)))
                              1)))
                   ((MINUSF (CAR U))
                  (MULTN -1
                         (MKSF
                        (MK*SQ
                         (CONS (MULTN -1 (CAR U))
                               (MKSFP (CDR U) 1)))
                        1)))
                   (T
                  (MKSF (MK*SQ
                         (CONS (CAR U) (MKSFP (CDR U) 1)))
                         1)))))))))
(MKSQ (LAMBDA (U N)
   ((LAMBDA(X)
     (COND ((NULL (CDR X)) (CAR X)) (T (CONS (LIST (CONS X 1)) 1))))
    (MKSP U N))))
))
DEFINE ((
(SIMP* (LAMBDA (U)
   (COND ((LESSP (SCNT U) SNO*) (ISIMPQ (SIMP U)))
       ((EQ (CAR U) (QUOTE PLUS)) (SIMPADD (CDR U)))
       ((EQ (CAR U) (QUOTE MINUS)) (NEGSQ (SIMP* (CARX (CDR U)))))
       ((EQ (CAR U) (QUOTE TIMES)) (ISIMPQ* (TSCAN (CDR U))))
       (T (ISIMPQ (SIMP U))))))
(SIMPADD (LAMBDA (U)
   (PROG (Z)
       (SETQ Z (CONS NIL 1))
    A    (COND ((NULL U) (RETURN Z)))
       (SETQ Z (ADDSQ (SIMP* (CAR U)) Z))
       (SETQ U (CDR U))
       (GO A))))
(ISIMPQ* (LAMBDA (U)
   (PROG (X)
       (SETQ U (REVERSE (MAPCAR U (FUNCTION SIMP))))
       (SETQ SV* (CONS NIL 1))
       (ISIMPQ*1 (CDR U) (CAR U))
       (SETQ X SV*)
       (SETQ SV* NIL)
       (RETURN X))))
(ISIMPQ*1 (LAMBDA (U V)
   (PROG (X Y)
       (COND ((NULL U) (RETURN (SETQ SV* (ADDSQ (ISIMPQ V) SV*)))))
       (SETQ X (CAAR U))
       (SETQ Y (MULTF (CDAR U) (CDR V)))
       (SETQ V (CAR V))
    A    (COND ((NULL X) (RETURN NIL))
             ((ATOM X)
            (RETURN (ISIMPQ*1 (CDR U) (CONS (MULTN X V) Y)))))
       (ISIMPQ*1 (CDR U) (CONS (MULTF (LIST (CAR X)) V) Y))
       (SETQ X (CDR X))
       (GO A))))
(ISIMPQ (LAMBDA (U)
   U))
(TSCAN (LAMBDA (U)
   (COND ((NULL U) NIL)
       ((ATOM U) (ERRACH (LIST (QUOTE TSCAN) U)))
       ((EQ (CAR U) (QUOTE TIMES)) (TSCAN (CDR U)))
       ((AND (NOT (ATOM (CAR U))) (EQ (CAAR U) (QUOTE TIMES)))
        (APPEND (TSCAN (CDAR U)) (TSCAN (CDR U))))
       (T (CONS (CAR U) (TSCAN (CDR U)))))))
(SCNT (LAMBDA (U)
   (COND ((OR (NULL U) (EQUAL U 0)) 0)
       ((ATOM U) 1)
       ((EQ (CAR U) (QUOTE PLUS))
        (*EVAL
         (CONS (QUOTE PLUS) (MAPCAR (CDR U) (FUNCTION SCNT)))))
       ((MEMBER (CAR U) (QUOTE (TIMES G CONS EPS)))
        (*EVAL
         (CONS (QUOTE TIMES) (MAPCAR (CDR U) (FUNCTION SCNT)))))
       ((FLAGP (CAR U) (QUOTE UNIP)) (SCNT (CADR U)))
       ((EQ (CAR U) (QUOTE EXPT))
        (COND
         ((OR (ATOM (CADR U)) (NOT (NUMBERP (CADDR U)))) 1)
         (T
          ((LAMBDA(X)
            (COND ((LESSP X 2) 1)
                (T (TIMES 2 X (ABS (*EVAL (CADDR U)))))))
           (SCNT (CADR U))))))
       ((AND (EQ (CAR U) (QUOTE *SQ)) GAMIDEN*) (TERMS1 (CAADR U)))
       (T 1))))
))
DEFINE ((
(SIMP (LAMBDA (U)
   (PROG (X)
    A    (COND ((ATOM U) (RETURN (SIMPATOM U)))
             ((OR (NOT (ATOM (CAR U))) (NUMBERP (CAR U))) (GO E))
             ((AND (SETQ X (OPMTCH U)) (SETQ U X)) (GO A))
             ((SETQ X (GET (CAR U) (QUOTE SIMPFN)))
            (RETURN
             (COND
              ((EQ X (QUOTE IDEN)) (SIMPIDEN U))
              (T (*APPLY X (LIST (CDR U)))))))
             ((GET (CAR U) (QUOTE **ARRAY)) (GO D))
             ((FLAGP (CAR U) (QUOTE OPFN))
            (SETQ U (*APPLY (CAR U) (CDR U))))
             ((GET (CAR U) (QUOTE INFIX)) (GO E))
             ((MEMBER (CAR U) (QUOTE (COND PROG)))
            (RETURN (SIMP (*EVAL U))))
             ((NOT (REDMSG (CAR U) (QUOTE OPERATOR) T)) (ERROR*))
             (T (MKOP (CAR U))))
       (GO A)
    D    (SETQ U (CONS (CAR U) (MAPCAR (CDR U) (FUNCTION REVAL))))
       (COND
        ((NOT (NUMLIS (CDR U)))
         (REDERR
          (APPEND (QUOTE (INCORRECT ARRAY ARGUMENTS FOR))
                (LIST (CAR U)))))
        ((AND (SETQ X (GETEL U)) (SETQ U X)) (GO A))
          (T (RETURN (MKSQ U 1))))
    E    (CURERR (QUOTE (SYNTAX ERROR)) NIL))))
(SIMPATOM (LAMBDA (U)
    (COND((NULL U)(REDERR(QUOTE(NIL USED IN ALGEBRAIC EXPRESSION))))
       ((NUMBERP U)
        (COND ((ZEROP U) (CONS NIL 1))
            ((FIXP U) (CONS U 1))
            (*FLOAT (CONS (PLUS 0.0 U) 1))
            (T
             ((LAMBDA(Z)
               (PROG2 (REPPRI U
                          (LIST
                           (QUOTE QUOTIENT)
                           (CAR Z)
                           (CDR Z)))
                     Z))
              (MAKFRC U)))))
       ((VECTORP U)
        (REDERR
         (CONS (QUOTE VECTOR) (CONS U (QUOTE (USED AS SCALAR))))))
         (T (MKSQ U 1)))))
(MAKFRC (LAMBDA (U)
   (PROG (X Y)
       (SETQ X (FIX (TIMES **MILLION U)))
       (SETQ Y (GCDN **MILLION X))
       (RETURN (CONS (QUOTIENT X Y) (QUOTIENT **MILLION Y))))))
(MKOP (LAMBDA (U)
  (COND ((MEMBER U FRLIS*) (REDERR (CONS (QUOTE OPERATOR)
            (CONS U (QUOTE (CANNOT BE ARBITRARY))))))
   (T (PUT U (QUOTE SIMPFN) (QUOTE IDEN))))))
(SIMPCAR (LAMBDA (U)
   (SIMP (CAR U))))
(VECTORP (LAMBDA (U)
   NIL))
(SIMPEXPT (LAMBDA (U)
   (PROG (N X)
       (COND
        ((AND (NUMBERP (SETQ N (CARX (CDR U)))) (FIXP N)) (GO A)))
       (SETQ X *FLOAT)
       (SETQ *FLOAT NIL)
       (SETQ N (CANCEL (SIMP N)))
       (SETQ *FLOAT X)
       (COND ((AND (ATOM (CAR N)) (EQUAL (CDR N) 1)) (GO A0)))
       (SETQ X (PREPSQ (SIMPCAR U)))
       (SETQ N (PREPSQ N))
         (COND ((EQCAR X (QUOTE TIMES)) (GO B))
               ((AND (EQCAR X (QUOTE MINUS))
                     (NOT (NUMBERP (CADR X))))
                (RETURN
                 (MULTSQ (SIMPEXPT (LIST -1 N))
                         (SIMPEXPT (LIST (CADR X) N)))))
               ((EQCAR X (QUOTE QUOTIENT))
                (RETURN
                 (MULTSQ (SIMPEXPT (LIST (CADR X) N))
                         (SIMPEXPT
                          (LIST (CADDR X) (LIST (QUOTE MINUS) N))))))
               ((EQCAR X (QUOTE EXPT))
                (AND (SETQ N
                           (REVAL (LIST (QUOTE TIMES) (CADDR X) N)))
                     (SETQ X (CADR X)))))
         (RETURN
          (COND ((EQUAL X 0) (CONS NIL 1))
                ((EQUAL X 1) (CONS 1 1))
                ((AND (ATOM X) (MEMBER N FRLIS*))
                 (CONS (LIST (CONS (CONS X N) 1)) 1))
                (T
                 (PROG2 (AND (NOT (MEMBER X EXPTL*))
                             (NOT (NUMBERP X))
                             (SETQ EXPTL* (CONS X EXPTL*)))
                        (MKSQ (LIST (QUOTE EXPT) X N) 1)))))
    A0   (SETQ N (CAR N))
      (COND ((NULL N) (SETQ N 0)))
    A    (RETURN
        (COND ((EQUAL N 0) (CONS 1 1))
            ((ATOM (CAR U))
             (COND ((NULL N) (CONS 1 1))
                   ((NUMBERP (CAR U))
                  (COND
                   ((ZEROP (CAR U)) (CONS NIL 1))
                   ((MINUSP N)
                    (CONS 1 (EXPT (CAR U) (MINUS N))))
                   (T (CONS (EXPT (CAR U) N) 1))))
                   ((MINUSP N)
                    (LIST 1 (CONS (MKSP (CAR U) (MINUS N)) 1)))
                       (T (MKSQ (CAR U) N))))
            ((MINUSP N) (REVPR (NMULTSQ (SIMPCAR U) (MINUS N))))
                (T (NMULTSQ (SIMPCAR U) N))))
   B     (SETQ U (CDDR X))
         (SETQ X (SIMPEXPT (LIST (CADR X) N)))
   C     (COND ((NULL U) (RETURN X)))
         (SETQ X (MULTSQ (SIMPEXPT (LIST (CAR U) N)) X))
         (SETQ U (CDR U))
         (GO C))))
(MEXPT (LAMBDA (U V)
   (COND
    ((NOT (EQUAL (CADAR U) (CADAR V))) (QUOTE FAILED))
    (T
     ((LAMBDA(X)
       (COND ((EQUAL X 0) 1)
             ((AND (NUMBERP X) (EQUAL (CADAR U) (QUOTE (MINUS 1))))
              (COND ((ZEROP (REMAINDER X 2)) 1) (T -1)))
           (T (MKSQP (MKSQ (LIST (QUOTE EXPT) (CADAR U) X) 1)))))
      (REVAL
       (LIST (QUOTE PLUS)
           (LIST (QUOTE TIMES) (CDR U) (CADDAR U))
           (LIST (QUOTE TIMES) (CDR V) (CADDAR V)))))))))
))
DEFLIST (((EXPT MEXPT)) MRULE)
DEFINE ((
(SIMPIDEN (LAMBDA (*S*)
   (PROG (Y Z)
       (COND ((FLAGP (CAR *S*) (QUOTE VOP)) (GO E)))
       (SETQ *S*
             (CONS (CAR *S*) (MAPCAR (CDR *S*) (FUNCTION REVAL))))
    B    (COND ((SETQ Z (OPMTCH *S*)) (RETURN (SIMP Z)))
             ((FLAGP (CAR *S*) (QUOTE SYMMETRIC))
            (SETQ *S* (CONS (CAR *S*) (ORDN (CDR *S*)))))
             ((FLAGP (CAR *S*) (QUOTE ANTISYMMETRIC)) (GO D)))
    C    (SETQ *S* (MKSQ *S* 1))
       (RETURN (COND (Y (NEGSQ *S*)) (T *S*)))
    D    (COND ((REPEATS (CDR *S*)) (RETURN (CONS NIL 1)))
             ((NOT (PERMP (SETQ Z (ORDN (CDR *S*))) (CDR *S*)))
            (SETQ Y T)))
       (SETQ *S* (CONS (CAR *S*) Z))
       (GO C)
    E    (COND ((ATOMLIS (CDR *S*)) (GO B)))
       (RETURN
        (MKVARG (CDR *S*)
              (FUNCTION
               (LAMBDA (J) (SIMPIDEN (CONS (CAR *S*) J)))))))))
(NEGSQ (LAMBDA (U)
   (CONS (MULTN -1 (CAR U)) (CDR U))))
(SIMPMINUS (LAMBDA (U)
   (NEGSQ (SIMP (CARX U)))))
(SIMPPLUS (LAMBDA (U)
   (PROG (Z)
       (SETQ Z (CONS NIL 1))
    A    (COND ((NULL U) (RETURN Z)))
       (SETQ Z (ADDSQ (SIMPCAR U) Z))
       (SETQ U (CDR U))
       (GO A))))
(SIMPQUOT (LAMBDA (U)
   ((LAMBDA(X)
     (COND
      ((NULL (CDR X)) (REDERR (QUOTE (ZERO DENOMINATOR))))
      (T (MULTSQ (SIMPCAR U) X))))
    (SIMPRECIP (CDR U)))))
(SIMPRECIP (LAMBDA (U)
   ((LAMBDA(X)
     (COND
      ((NULL (CAR X)) (REDERR (QUOTE (ZERO DENOMINATOR))))
      ((AND *FLOAT (ATOM (CAR X)))
       (CONS (MULTN (RECIP (PLUS 0.0 (CAR X))) (CDR X)) 1))
      (T (REVPR X))))
    (SIMP (CARX U)))))
(SIMPTIMES (LAMBDA (U)
   (PROG (X)
       (SETQ X (SIMPCAR U))
    A    (SETQ U (CDR U))
       (COND ((NULL (CAR X)) (RETURN (CONS NIL 1)))
             ((NULL U) (RETURN X)))
       (SETQ X (MULTSQ X (SIMPCAR U)))
       (GO A))))
(SIMPSUBS (LAMBDA (U)
   (PROG (X Y Z)
       (SETQ U (REVERSE U))
       (SETQ Y (SUBS2 (SIMPCAR U)))
       (SETQ U (CDR U))
    A    (COND ((NULL U) (GO B))
             ((NOT (MEMBER (CAAR U) (QUOTE (EQUAL SETQ))))
            (GO ERR))
             ((VECTORP (SETQ X (CADAR U))) (GO C))
             ((OR (NOT (KERNP (SETQ X (SIMP X))))
                (NOT (EQUAL (CDR X) 1))
                (NOT (EQUAL (CDAAR X) 1))
                (NOT (EQUAL (CDAAAR X) 1)))
            (GO ERR)))
       (SETQ X (CAAAAR X))
    C    (SETQ Z (CONS (CONS X (CADDAR U)) Z))
       (SETQ U (CDR U))
       (GO A)
    B    (RETURN (SIMP (SUBLIS Z (PREPSQ Y))))
    ERR  (ERRPRI1 (CAR U))
       (ERROR*))))
(SIMP*SQ (LAMBDA (U)
   (COND ((NULL (CADR U)) (SIMP (PREPSQ (CAR U)))) (T (CAR U)))))
))
DEFINE ((
(SUBS2 (LAMBDA (U)
   (PROG (X)
       (RSET2)
       (SETQ U (EXPSQ U))
         (COND ((AND (NULL EXPTL*)
                     (OR (NULL MATCH*) (NULL SUBFG*))) (GO A)))
         (COND (EXPTL* (SETQ U (EXPTCHK U))))
       (SETQ X MCHFG*)
       (SETQ U (MULTSQ (SUBS31 (CAR U)) (REVPR (SUBS31 (CDR U)))))
       (SETQ MCHFG* X)
    A    (RETURN (CANCEL U)))))
(CANCEL (LAMBDA (U)
   (PROG (X)
       (COND ((NULL (CAR U)) (RETURN (CONS NIL 1)))
             ((OR *FLOAT (EQUAL (CDR U) 1)) (GO C)))
       (SETQ X (GCD1 (CDR U) (CAR U)))
       (SETQ U (CONS (QUOTF (CAR U) X) (QUOTF (CDR U) X)))
    C    (RETURN (MKCANON U)))))
(MKCANON (LAMBDA (U)
   (COND ((MINUSF (CDR U))
        (CONS (MULTN -1 (CAR U)) (MULTN -1 (CDR U))))
       (T U))))
(MINUSF (LAMBDA (U)
   (COND ((NULL U) NIL)
         ((ATOM U) (MINUSP U))
         ((EQ (CAR U) (QUOTE QUOTIENT)) (MINUSP (CADR U)))
         (T (MINUSF (CDAR U))))))
))
DEFINE ((
(EXPSQ (LAMBDA (U)
   (COND ((OR (NULL SUB2*) (NULL *EXP)) U)
       (T
        ((LAMBDA(X Y)
          (CONS (MULTF (CAR X) (CDR Y)) (MULTF (CDR X) (CAR Y))))
         (EXPAND (CAR U))
         (COND (*XDN (EXPAND (CDR U))) (T (CONS (CDR U) 1))))))))
(EXPAND (LAMBDA (U)
   (PROG (W X Y Z)
       (COND ((ATOM U) (RETURN (CONS U 1))))
       (SETQ X U)
       (SETQ Z (CONS NIL 1))
    A    (COND
        ((NULL X)
         (RETURN
          (COND ((EQUAL (CAR Z) U) (CONS U (CDR Z))) (T Z))))
        ((ATOM X) (GO E)))
       (SETQ Y (EXPAND (CDAR X)))
       (COND
        ((AND (NOT (ATOM (SETQ W (CAAAR X))))
            (OR (EQ (CAR W) (QUOTE *SQ)) (NOT (ATOM (CAR W)))))
         (GO C)))
       (SETQ Z (ADDSQ (CONS (MULTF2 (CAAR X) (CAR Y)) (CDR Y)) Z))
    B    (SETQ X (CDR X))
       (GO A)
    C    (SETQ Z
             (ADDSQ
            (MULTSQ
             (COND
              ((EQ (CAR W) (QUOTE *SQ))
               (NMULTSQ (EXPSQ (CADR W)) (CDAAR X)))
              ((NULL (CDAAR X)) (EXPSQ W))
              (T (NMULTSQ (EXPAND W) (CDAAR X))))
             Y)
            Z))
       (GO B)
    E    (SETQ Z (ADDSQ (CONS X 1) Z))
       (SETQ X NIL)
       (GO A))))
))
DEFINE ((
(EXSCAN (LAMBDA (U)
   (COND ((ATOM U) U)
         (T
          (ADDF
           (MULTF2
            (COND
             ((MEMBER (CAAAR U) EXPTL*)
              (MKSP (LIST (QUOTE EXPT) (CAAAR U) 1) (CDAAR U)))
             (T (CAAR U)))
            (EXSCAN (CDAR U)))
           (EXSCAN (CDR U)))))))
(EXPTCHK (LAMBDA (U)
   (PROG (V W X Y Y1 Z)
         (SETQ V (EXSCAN (CAR U)))
         (SETQ W (CDR U))
         (SETQ X (CONS FACTORS* ORDN*))
         (SETQ FACTORS* NIL)
         (SETQ ORDN* 0)
         (SETQ Y (CKRN W))
   A     (COND ((ATOM Y) (GO C)))
         (SETQ Y1 (CAAAR Y))
         (COND
          ((AND (NOT (MEMBER Y1 EXPTL*)) (NOT (EQCAR Y1 (QUOTE EXPT))))
           (GO B)))
         (SETQ V
               (MULTF2
                (MKSP
                 (COND
                  ((MEMBER Y1 EXPTL*) (LIST (QUOTE EXPT) Y1 -1))
                  (T
                   (LIST (QUOTE EXPT)
                         (CADR Y1)
                         (PREPSQ (SIMPMINUS (CDDR Y1))))))
                 (CDAAR Y))
                V))
         (SETQ Z (CONS (CAAR Y) Z))
   B     (SETQ Y (CDAR Y))
         (GO A)
   C     (SETQ FACTORS* (CAR X))
         (SETQ ORDN* (CDR X))
         (SETQ X 1)
   D     (COND ((NULL Z) (GO E)))
         (SETQ X (LIST (CONS (CAR Z) X)))
         (SETQ Z (CDR Z))
         (GO D)
   E     (RETURN (CONS V (QUOTF W X))))))
))
DEFINE ((
(SUBS31 (LAMBDA (U)
   (COND ((ATOM U) (CONS U 1))
         (T
        (ADDSQ
         ((LAMBDA(X)
           (COND ((NULL MCHFG*) (CONS (LIST (CAR U)) 1))
               ((AND MCHFG* (NOT (SETQ MCHFG* NIL)) *RESUBS)
                (SUBS2 X))
               (T X)))
          (SUBS3T (CAR U) MATCH*))
         (SUBS31 (CDR U)))))))
(SUBS3T (LAMBDA (U V)
   (SUBS3T0 (SUBS3T1 U V))))
(SUBS3T0 (LAMBDA (X)
   (PROG (Y)
       (COND ((OR (CAR X) (ATOM (CDR X))) (RETURN X)))
       (SETQ Y (MULTSQ (SIMP (CAADR X)) (CADDR X)))
       (COND
        ((CDADR X)
         (SETQ Y
             (MULTSQ
              (REVPR (SIMPTIMES (EXCHK (CDADR X) NIL)))
              Y))))
       (RETURN (CANCEL Y)))))
(SUBS3T1 (LAMBDA (U V)
   (PROG (X Y Z)
       (SETQ X (MTCHK (CAR U) V))
       (COND
        ((NULL X)
         (RETURN (COND ((NULL MCHFG*) U) (T (CONS (LIST U) 1)))))
        ((AND (NULL (CAAR X))
            (SETQ MCHFG* T)
            (SETQ Y
                  (LIST NIL
                      (CONS (CADDAR X) (CADR (CDDAR X)))
                      (SUBS32 (CDR U) MATCH*))))
         (GO B))
        ((AND (NOT (ATOM (CDR U))) (NULL (CDDR U))) (GO A)))
       (SETQ Y (SUBS32 (CDR U) X))
       (COND ((NULL MCHFG*) (RETURN (CONS (CAR U) Y))))
    A0   (SETQ X (LIST (CONS (CAR U) 1)))
       (SETQ Z (GCD1 X (CDR Y)))
       (RETURN
        (COND ((NULL Z) (MULTS2 (CAR U) Y))
            ((EQUAL X Z) (CONS (CAR Y) (QUOTF (CDR Y) X)))
            (T
             (CONS (MULTF (QUOTF X Z) (CAR Y))
                   (QUOTF (CDR Y) Z)))))
    A    (SETQ Y (SUBS3T1 (CADR U) X))
         (COND ((AND (NULL (CAR Y)) (NOT (ATOM (CDR Y)))) (GO B))
             ((NULL MCHFG*) (RETURN (LIST (CAR U) Y)))
             (T (GO A0)))
    B    (COND
        ((AND (CDADR Y) (EQUAL (CADADR Y) (CAR U)))
         (RETURN (LIST NIL (CONS (CAADR Y) (CDDADR Y)) (CADDR Y))))
        ((AND (NOT (ATOM (CAAR U)))
            (FLAGP** (CAAAR U) (QUOTE NONCOM))
            (SETQ Y (SUBS3T0 Y)))
         (GO A0))
        (T
         (RETURN (LIST NIL (CADR Y) (MULTS2 (CAR U) (CADDR Y))))))))
)
(MULTS2 (LAMBDA (U V)
   (CONS (MULTF2 U (CAR V)) (CDR V))))
(SUBS32 (LAMBDA (U V)
   (PROG (B X Y)
    A    (COND
        ((ATOM U)
         (RETURN
          (COND (MCHFG*
               (COND ((NULL X) (CONS U 1))
                   (T (ADDSQ (CONS U 1) X))))
              (T (APPEND X U))))))
       (SETQ Y (SUBS3T (CAR U) V))
       (COND ((NULL MCHFG*) (SETQ X (APPEND X (LIST Y))))
             (B (SETQ X (ADDSQ Y X)))
             ((SETQ B T) (SETQ X (ADDSQ (CONS X 1) Y))))
       (SETQ U (CDR U))
       (GO A))))
(MKKL (LAMBDA (U V)
   (COND ((NULL U) V) (T (MKKL (CDR U) (LIST (CONS (CAR U) V)))))))
))
DEFINE ((
(MTCHK (LAMBDA (U V1)
   (PROG (V W X Y Z Q) 
    A0   (COND ((NULL V1) (RETURN Z)))
       (SETQ V (CAR V1))
       (SETQ W (CAR V))
    A  (SETQ Q (CAR W)) 
       (COND ((NULL W) (GO D)) 
             ((AND (EQUAL U (CAR W)) (SETQ Y (LIST NIL))) (GO B))
             ((NOT (ATOM (CAR U))) (GO A3)) 
             ((NOT (ATOM (CAAR W))) (GO D))
             ((OR FRLIS* (ORDP (CAR U) (CAAR W))) (GO A2))
             (T (GO E)))
    A3   (COND ((NOT (ATOM (CAAR W))) (GO A1)) 
               ((AND (MEMBER (CDAR W) FRLIS*) 
                     (EQ (CAAR U) (QUOTE EXPT)) 
                     (SETQ W (CONS (CONS (LIST (QUOTE EXPT) (CAAR W) 
                                          (CDAR W)) 1) (CDR W)))) 
              (GO A1)) 
               ((MEMBER (CAAR W) FRLIS*) (GO A2)) 
               (T (GO D))) 
    A1   (COND ((EQ (CAAR U) (CAAAR W)) (GO A2))
             ((FLAGP** (CAAR U) (QUOTE NONCOM)) (GO C1))
             ((NULL (ORDP (CAAR U) (CAAAR W))) (GO E))
             (T (GO D)))
    A2   (COND
        ((OR (AND (NOT (MEMBER (CDAR W) FRLIS*))
                 (OR (AND (CAADR V)
                        (NOT (EQUAL (CDR U) (CDAR W))))
                   (LESSP (CDR U) (CDAR W))))
             (NOT (SETQ Y (MCHK (CAR U) (CAAR W)))))
         (GO C))
        ((MEMBER (CDAR W) FRLIS*)
         (SETQ Y
                (MAPCONS U (CONS (CDAR W) (CDR U))))))
    B    (COND ((NULL Y) (GO C))
             ((AND (NULL
                  (CAR
                   (SETQ X
                       (CONS (SUBLIS (CAR Y)
                                  (DELETE Q (CAR V))) 
                           (LIST (CADR V)
                               (SUBLIS (CAR Y) (CADDR V))
                               (CONS
                                (SUBLIS (CAR Y) (CAR W))
                                (CADDDR V)))))))
                 (*EVAL (SUBLIS (CAR Y) (CDADR V))))
            (RETURN (LIST X))))
       (SETQ Z (CONS X Z))
       (SETQ Y (CDR Y))
       (GO B)
    C    (COND
        ((AND (NOT (ATOM (CAR U)))
            (FLAGP** (CAAR U) (QUOTE NONCOM)))
         (GO C1)))
       (SETQ W (CDR W))
       (GO A)
    C1   (COND ((AND (CADDDR V) (NOT (NOCP (CADDDR V)))) (GO E)))
    D    (SETQ Z (APPEND Z (LIST V)))
    E    (SETQ V1 (CDR V1))
       (GO A0))))
(NOCP (LAMBDA (U)
   (OR (NULL U)
       (AND (OR (ATOM (CAAR U))
            (NOT (FLAGP** (CAAAR U) (QUOTE NONCOM))))
          (NOCP (CDR U))))))
(MCHK (LAMBDA (U V)
   (COND ((EQUAL U V) (LIST NIL))
       ((OR (NULL U) (NULL V)) NIL)
       ((MEMBER V FRLIS*) (LIST (LIST (CONS V (EMTCH U)))))
       ((OR (ATOM U) (ATOM V)) NIL)
       ((EQ (CAR U) (CAR V)) (MCHARG (CDR U) (CDR V) (CAR U)))
       (T NIL))))
(MCHARG (LAMBDA (*S* V W)
   ((LAMBDA(X)
     (COND
      ((MTP V)
       (COND
      (X
       (COND
        ((FLAGP W (QUOTE SYMMETRIC))
         (MAPLIST (PERMUTATIONS V)
                (FUNCTION
                 (LAMBDA(J)
                  (PAIR (CAR J)
                      (MAPCAR *S* (FUNCTION EMTCH)))))))
        ((FLAGP W (QUOTE ANTISYMMETRIC))
         (ERRACH (QUOTE (NOT YET))))
        (T (LIST (PAIR V (MAPCAR *S* (FUNCTION EMTCH)))))))
      ((AND (EQUAL (LENGTH V) 2) (FLAGP W (QUOTE NARY)))
       (MCHARG (CDR (MKBIN (CONS W *S*))) V W))
      (T NIL)))
      (X (MCHARG1 *S* V (FLAGP W (QUOTE SYMMETRIC)) (LIST NIL)))
      (T NIL)))
    (EQUAL (LENGTH *S*) (LENGTH V)))))
(MCHARG1 (LAMBDA (U V FLG W)
   (PROG (X Z)
       (COND ((NULL U) (RETURN W))
             ((NULL FLG)
            (RETURN
             (MCHARG3 U (CDR V) (MCHK (CAR U) (CAR V)) FLG W))))
       (SETQ X (MCHARG2 (CAR U) V))
    A    (COND ((NULL X) (RETURN Z)))
       (SETQ Z (APPEND (MCHARG3 U (CDAR X) (CAAR X) FLG W) Z))
       (SETQ X (CDR X))
       (GO A))))
(MCHARG2 (LAMBDA (U V)
   (PROG (X Y Z)
    A    (COND ((NULL V) (RETURN (REVERSE Z)))
             ((SETQ Y (MCHK U (CAR V)))
            (SETQ Z
                  (CONS (CONS Y (APPEND (REVERSE X) (CDR V)))
                       Z))))
       (SETQ X (CONS (CAR V) X))
       (SETQ V (CDR V))
       (GO A))))
(MCHARG3 (LAMBDA (U V *S* FLG W)
   (PROG (Z)
    A    (COND ((NULL *S*) (RETURN Z)))
       (SETQ Z
             (APPEND (MCHARG1 (CDR U)
                        (SUBLIS (CAR *S*) V)
                         FLG
                        (MAPLIST W
                               (FUNCTION
                                (LAMBDA(J)
                                 (APPEND
                                  (CAR *S*)
                                  (CAR J))))))
                    Z))
       (SETQ *S* (CDR *S*))
       (GO A))))
(MKBIN (LAMBDA (U)
   (COND ((OR (NULL (CDDR U)) (NULL (CDDDR U))) U)
       (T (MKBIN1 (CAR U) (CDR U))))))
(MKBIN1 (LAMBDA (U V)
   (COND ((NULL (CDDR V)) (CONS U V))
       (T (LIST U (CAR V) (MKBIN1 U (CDR V)))))))
(MTP (LAMBDA (V)
   (OR (NULL V)
       (AND (MEMBER (CAR V) FRLIS*)
          (NOT (MEMBER (CAR V) (CDR V)))
          (MTP (CDR V))))))
(PERMUTATIONS (LAMBDA (*S*)
   (COND ((NULL *S*) (LIST NIL))
       ((NULL (CDR *S*)) (LIST *S*))
       (T
        (MAPCON *S*
              (FUNCTION
               (LAMBDA(J)
                (MAPCONS
                 (PERMUTATIONS (DELETE (CAR J) *S*))
                 (CAR J)))))))))
))
DEFINE ((
(EMTCH (LAMBDA (U)
   (COND ((ATOM U) U)
       (T ((LAMBDA (X) (COND (X X) (T U))) (OPMTCH U))))))
(OPMTCH (LAMBDA (U)
   (PROG (X Y)
       (COND ((NULL SUBFG*) (RETURN NIL)))
       (SETQ X (GET (CAR U) (QUOTE OPMTCH*)))
    A    (COND ((NULL X) (RETURN NIL))
             ((AND (NULL (CAADAR X))
                 (SETQ Y (MCHARG (CDR U) (CAAR X) (CAR U)))
                 (*EVAL (SUBLIS (CAR Y) (CDADAR X))))
            (GO B)))
       (SETQ X (CDR X))
       (GO A)
    B    (RETURN (SUBLIS (CAR Y) (CADDAR X))))))
))
DEFINE ((
(ORDER (LAMBDA (U)
   (PROG NIL
       (RMSUBS) 
    A    (COND ((NULL U) (RETURN NIL))
             ((OR (NOT (ATOM (CAR U))) (NUMBERP (CAR U))) (GO B)))
       (PUT (CAR U) (QUOTE ORDER) ORDN*)
       (SETQ ORDN* (ADD1 ORDN*))
    B    (SETQ U (CDR U))
       (GO A))))
(FORMOP (LAMBDA (U)
   (COND ((ATOM U) U)
       (T
        (ADDOF (MULTOP (CAAR U) (FORMOP (CDAR U)))
             (FORMOP (CDR U)))))))
(ADDOF (LAMBDA (U V)
   (COND ((NULL U) V)
       ((NULL V) U)
       ((ATOM U) (CONS (CAR V) (ADDOF U (CDR V))))
       ((ATOM V) (ADDOF V U))
       ((EQUAL (CAAR U) (CAAR V))
        (CONS (CONS (CAAR U) (ADDOF (CDAR U) (CDAR V)))
            (ADDOF (CDR U) (CDR V))))
       ((ORDOP (CAAR U) (CAAR V)) (CONS (CAR U) (ADDOF (CDR U) V)))
       (T (CONS (CAR V) (ADDOF U (CDR V)))))))
(MULTOP (LAMBDA (U V)
   (COND ((EQ (CAR U) (QUOTE K*)) V) (T (MULTOP1 U V)))))
(MULTOP1 (LAMBDA (U V)
   (COND ((NULL V) NIL)
       ((OR (ATOM V) (ORDOP U (CAAR V))) (LIST (CONS U V)))
       (T
        (CONS (CONS (CAAR V) (MULTOP1 U (CDAR V)))
            (MULTOP1 U (CDR V)))))))
(ORDOP (LAMBDA (U V)
   (COND ((NULL U) (NULL V))
       ((NULL V) NIL)
       ((AND (MEMBER U FACTORS*) (NOT (MEMBER V FACTORS*))) T)
         ((AND (MEMBER V FACTORS*) (NOT (MEMBER U FACTORS*))) NIL)
       ((ATOM U)
        (COND
         ((ATOM V)
          (COND ((NUMBERP U) (AND (NUMBERP V) (NOT (LESSP U V))))
              ((NUMBERP V) T)
                  ((ZEROP ORDN*) (ORDERP U V))
              (T
               ((LAMBDA(X Y)
                 (COND ((AND X Y) (LESSP X Y))
                     (X T)
                     (Y NIL)
                     (T (ORDERP U V))))
                (GET U (QUOTE ORDER))
                (GET V (QUOTE ORDER))))))
         ((MEMBER U FACTORS*) T)
         (T (NOT (MEMBER (CAR V) FACTORS*)))))
       ((ATOM V) (MEMBER (CAR U) FACTORS*))
       ((EQUAL (CAR U) (CAR V)) (ORDOP (CDR U) (CDR V)))
       (T (ORDOP (CAR U) (CAR V))))))
(QUOTOF (LAMBDA (P Q)
   (COND ((NULL P) NIL)
       ((EQUAL P Q) 1)
       ((EQUAL Q 1) P)
       ((NUMB Q)
        (COND
         ((NUMB P)
          (COND ((AND (ATOM P) (ATOM Q)) (MKFR P Q))
                ((ATOM P) (MKFR (TIMES P (CADDR Q)) (CADR Q))) 
                ((ATOM Q) (MKFR (CADR P) (TIMES Q (CADDR P)))) 
                (T (MKFR (TIMES (CADR P) (CADDR Q)) 
                         (TIMES (CADR Q) (CADDR P)))) )) 
         (T
          (CONS (CONS (CAAR P) (QUOTOF (CDAR P) Q))
              (QUOTOF (CDR P) Q)))))
       ((NUMB P)
        (LIST
         (CONS (CONS (CAAAR Q) (MINUS (CDAAR Q)))
             (QUOTOF P (CDARX Q)))))
       (T
        ((LAMBDA(X Y)
          (COND
           ((EQ (CAR X) (CAR Y))
            ((LAMBDA(N W Z)
            (COND ((ZEROP N) (ADDOF W Z))
                  (T (CONS (CONS (CONS (CAR Y) N) W) Z))))
             (DIFFERENCE (CDR X) (CDR Y))
             (QUOTOF (CDAR P) (CDARX Q))
             (QUOTOF (CDR P) Q)))
           ((ORDOP X Y)
            (CONS (CONS X (QUOTOF (CDAR P) Q)) (QUOTOF (CDR P) Q)))
           (T
            (LIST
             (CONS (CONS (CAR Y) (MINUS (CDR Y)))
                 (QUOTOF P (CDARX Q)))))))
         (CAAR P)
         (CAAR Q))))))
))
DEFINE ((
(CKRN (LAMBDA (U)
   (PROG (X)
       (COND ((KERNLOP U) (RETURN U)))
    A    (SETQ X (CONS (CKRN (CDAR U)) X))
       (COND
        ((NULL (CDR U)) (RETURN (LIST (CONS (CAAR U) (GCK X)))))
        ((OR (ATOM (CDR U)) (NOT (EQ (CAAAR U) (CAAADR U))))
         (RETURN (GCK (CONS (CKRN (CDR U)) X)))))
       (SETQ U (CDR U))
       (GO A))))
(GCK (LAMBDA (U)
   (COND ((NULL U) 1)
       ((NULL (CDR U)) (CAR U))
       (T (GCK (CONS (GCK1 (CAR U) (CADR U)) (CDDR U)))))))
(GCK1 (LAMBDA (U V)
   (COND ((OR (NULL U) (NULL V)) (ERRACH (QUOTE GCK1)))
       ((EQUAL U V) U)
       ((NUMB U)
        (COND
         ((NUMB V)
          (COND ((AND (ATOM U) (ATOM V)) (GCDN U V)) (T 1)))
         (T (GCK1 U (CDARX V)))))
       ((NUMB V) (GCK1 (CDARX U) V))
       (T
        ((LAMBDA(X Y)
          (COND
           ((EQ (CAR X) (CAR Y))
            (LIST
             (CONS
            (COND ((GREATERP (CDR X) (CDR Y)) Y) (T X))
            (GCK1 (CDARX U) (CDARX V)))))
             ((ORDOP X Y) (GCK1 (CDARX U) V))
           (T (GCK1 U (CDARX V)))))
         (CAAR U)
         (CAAR V))))))
))
DEFINE ((
(PREPSQ (LAMBDA (U)
   (COND ((NULL (CAR U)) 0)
       (T
        ((LAMBDA(X)
          (COND
           ((OR *RAT (AND (NOT *FLOAT) *DIV) UPL* DNL*)
            (REPLUS (PREPSQ1 (CAR X) NIL (CDR X))))
           (T
            (SQFORM X
                  (FUNCTION
                   (LAMBDA (J) (REPLUS (PREPSQ1 J NIL 1))))))))
         (CONS (FORMOP (CAR U)) (FORMOP (CDR U))))))))
(SQFORM (LAMBDA (U *PI*)
   ((LAMBDA(X Y)
     (COND ((EQUAL Y 1) X) (T (LIST (QUOTE QUOTIENT) X Y))))
    (*PI* (CAR U))
    (*PI* (CDR U)))))
(PREPSQ1 (LAMBDA (U V W)
   (PROG (X Y Z)
       (COND ((NULL U) (RETURN NIL))
             ((AND (NOT (ATOM U))
                 (OR (MEMBER (CAAAR U) FACTORS*)
                   (AND (NOT (ATOM (CAAAR U)))
                        (MEMBER (CAAAAR U) FACTORS*))))
            (RETURN
             (NCONC (PREPSQ1 (CDAR U) (CONS (CAAR U) V) W)
                  (PREPSQ1 (CDR U) V W))))
             ((NULL (KERNLP U)) (GO A)))
       (SETQ U (MKKL V U))
       (SETQ V NIL)
    A    (SETQ X (CKRN U))
       (COND ((NULL DNL*) (GO A1)))
       (SETQ Z (CKRN* X DNL*))
       (SETQ X (QUOTOF X Z))
       (SETQ U (QUOTF U Z))
       (SETQ W (QUOTOF W Z))
    A1   (SETQ Y (CKRN W))
       (COND ((NULL UPL*) (GO A2)))
       (SETQ Z (CKRN* Y UPL*))
       (SETQ Y (QUOTOF Y Z))
       (SETQ U (QUOTOF U Z))
       (SETQ W (QUOTOF W Z))
    A2   (COND ((AND (NULL *DIV) (NULL *FLOAT)) (SETQ Y (GCK1 X Y))))
       (SETQ U (MKCANON (CONS (QUOTOF U Y) (QUOTOF W Y))))
       (COND ((AND *GCD (ZEROP ORDN*)) (SETQ U (CANCEL U))))
       (SETQ X (QUOTOF X Y))
       (COND
        ((AND *ALLFAC (NOT (EQUAL X (CAR U)))) (GO B)) 
        ((NULL V) (GO D)))
       (SETQ V (EXCHK V NIL))
       (GO C)
    D    (SETQ U (PREPSQ2 U))
       (RETURN
        (COND ((EQCAR U (QUOTE PLUS)) (CDR U)) (T (LIST U))))
    B    (COND ((AND (EQUAL X 1) (NULL V)) (GO D)))
       (SETQ U (CONS (QUOTOF (CAR U) X) (CDR U)))
       (SETQ V (PREPF (MKKL V X)))
       (COND ((EQUAL U (CONS 1 1)) (RETURN V))
             ((EQCAR V (QUOTE TIMES)) (SETQ V (CDR V)))
             (T (SETQ V (LIST V))))
    C    (RETURN (LIST (RETIMES (ACONC V (PREPSQ2 U))))))))
(CKRN* (LAMBDA (U V)
   (COND ((NULL U) (ERRACH (QUOTE CKRN*)))
       ((ATOM U) 1)
       ((MEMBER (CAAAR U) V)
        (LIST (CONS (CAAR U) (CKRN* (CDARX U) V))))
       (T (CKRN* (CDARX U) V)))))
(UP (LAMBDA (U)
   (FACTOR1 U T (QUOTE UPL*))))
(DOWN (LAMBDA (U)
   (FACTOR1 U T (QUOTE DNL*))))
))
DEFLIST (((UP RLIS) (DOWN RLIS)) STAT)
DEFINE ((
(REPLUS (LAMBDA (U)
   (COND ((ATOM U) U)
       ((NULL (CDR U)) (CAR U))
       (T (CONS (QUOTE PLUS) U)))))
(RETIMES (LAMBDA (U)
   (PROG (X Y)
    A    (COND ((NULL U) (GO D))
               ((NOT (EQCAR (CAR U) (QUOTE MINUS))) (GO B)))
         (SETQ X (NOT X))
         (COND ((EQUAL (CADAR U) 1) (GO C))
               (T (SETQ U (CONS (CADAR U) (CDR U)))))
    B    (SETQ Y (CONS (CAR U) Y))
    C    (SETQ U (CDR U))
         (GO A)
    D    (SETQ Y (COND ((NULL Y) 1)
                       ((CDR Y) (CONS (QUOTE TIMES) (REVERSE Y)))
                       (T (CAR Y))))
         (RETURN (COND (X (LIST (QUOTE MINUS) Y)) (T Y))))))
(PREPSQ2 (LAMBDA (U)
   (SQFORM U (FUNCTION PREPF))))
(PREPF (LAMBDA (U)
   (PROG (X)
         (COND ((AND (MINUSF U) (SETQ X T)) (SETQ U (MULTN -1 U))))
         (SETQ U (REPLUS (PREPF1 U NIL)))
         (RETURN (COND (X (LIST (QUOTE MINUS) U)) (T U))))))
(PREPF1 (LAMBDA (U V)
   (COND ((NULL U) NIL)
       ((NUMB U)
        (LIST (RETIMES (NUMCONS (MINUSCHK U) (EXCHK V NIL)))))
       (T
        (NCONC (PREPF1 (CDAR U) (CONS (CAAR U) V))
             (PREPF1 (CDR U) V))))))
(NUMB (LAMBDA (U)
   (OR (NUMBERP U) (EQCAR U (QUOTE QUOTIENT)))))
(NUMCONS (LAMBDA (N V)
   (COND ((NULL V) (LIST N)) ((EQUAL N 1) V) (T (CONS N V)))))
(KERNLOP (LAMBDA (U)
   (OR (NUMB U) (AND (NULL (CDR U)) (KERNLOP (CDAR U))))))
(EXCHK (LAMBDA (U V)
   (COND ((NULL U) V)
       ((ONEP (CDAR U)) (EXCHK (CDR U) (CONS (SQCHK (CAAR U)) V)))
       (T
        (EXCHK (CDR U)
             (CONS (LIST (QUOTE EXPT) (SQCHK (CAAR U)) (CDAR U))
                    V))))))
(SQCHK (LAMBDA (U)
   (COND ((ATOM U) ((LAMBDA (X)
             (COND (X X) (T U))) (GET U (QUOTE NEWNAME))))
         ((EQ (CAR U) (QUOTE *SQ)) (PREPSQ (CADR U)))
         ((AND (EQ (CAR U) (QUOTE EXPT)) (EQUAL (CADDR U) 1))
                (CADR U))
       ((ATOM (CAR U)) U)
       (T (PREPF U)))))
(MINUSCHK (LAMBDA (U)
   (COND
    ((ATOM U)
     (COND ((MINUSP U) (LIST (QUOTE MINUS) (MINUS U))) (T U)))
    ((MINUSP (CADR U))
     (LIST (QUOTE MINUS)
         (LIST (QUOTE QUOTIENT) (MINUS (CADR U)) (CADDR U))))
    (T U))))
(MKFR (LAMBDA (U V)
   (COND (*FLOAT (QUOTIENT (PLUS 0.0 U) V))
       (T
        ((LAMBDA(M)
          ((LAMBDA(N1 N2)
            (COND ((ONEP N2) N1)
                (T (LIST (QUOTE QUOTIENT) N1 N2))))
           (QUOTIENT U M)
           (QUOTIENT V M)))
            (GCDN U V))))))
))
DEFLIST (((*SQ SQPRINT)) SPECPRN)
DEFINE ((
(SQPRINT (LAMBDA (U)
   (PROG (Z)
       (SETQ Z ORIG*)
       (COND ((LESSP POSN* 20) (SETQ ORIG* POSN*)))
       (MAPRIN
        (SETQ *OUTP
            (COND ((NULL (CAAR U)) 0) (T (PREPSQ (CAR U))))))
       (SETQ ORIG* Z))))
(VARPRI (LAMBDA (U V W)
   (PROG NIL
       (COND ((NULL V) (RETURN NIL))
             (*FORT (GO D))
             ((AND (EQUAL V 0) U *NERO) (GO C)))
       (COND ((NULL W) (TERPRI*)))
       (COND ((EQCAR V (QUOTE MAT)) (GO M)) ((NULL U) (GO A)))
       (INPRINT (QUOTE SETQ) (GET (QUOTE SETQ) (QUOTE INFIX)) U)
       (OPRIN (QUOTE SETQ))
    A    (MAPRIN V)
       (COND (W (GO C))
             ((AND (NULL *NAT) (NULL *FORT)) (PRINC* **DOLLAR)))
    C    (RETURN V)
    D  (COND ((NULL (OR W (EQ POSN* 0))) (PROG2 (SETQ POSN* 0) 
                                            (TERPRI)))) 
       (COND ((EQ POSN* 0) (SETQ COUNT* 1))) 
       (SETQ FORTVAR* NIL) 
       (COND ((OR W (ATOM V) (NOT (EQ POSN* 0))) (GO A))) 
       (SETQ FORTVAR* (QUOTE ANS))
       (COND ((OR (NULL U) (NOT (ATOM (CAR U)))) (GO E)))
       (SETQ FORTVAR* (CAR U))
E        (COND ((GREATERP POSN* 5) (GO A)))
         (SPACES 6)
       (SETQ POSN* 6) 
       (PRINC* FORTVAR*) 
       (OPRIN (QUOTE EQUAL))
       (GO A)
    M    (MATPRI (CDR V) (COND (U (CAR U)) (T NIL)))
       (GO C))))
))
DEFINE ((
(SIMPDF (LAMBDA (U)
   (PROG (V X Y N)
       (COND ((NULL SUBFG*) (RETURN (MKSQ (CONS (QUOTE DF) U) 1))))
       (SETQ V (CDR U))
       (SETQ U (SIMPCAR U))
    A    (COND ((OR (NULL V) (NULL (CAR U))) (RETURN U)))
       (SETQ X (COND ((NULL Y) (SIMP (CAR V))) (T Y)))
       (SETQ Y NIL)
       (COND
        ((OR (NULL (KERNP X)) (NOT (ONEP (CDAAAR X)))) (GO E))
        ((OR (NULL (CDR V))
             (NOT
            (NUMBERP
             (SETQ N (PREPSQ (SETQ Y (SIMP (CADR V))))))))
         (GO C1)))
       (SETQ Y NIL)
       (SETQ V (CDR V))
       (SETQ X (CAAAAR X))
    C    (COND ((ZEROP N) (GO D)))
       (SETQ U (DIFF1 U X))
       (SETQ N (SUB1 N))
       (GO C)
    C1   (SETQ U (DIFF1 U (CAAAAR X)))
    D    (SETQ V (CDR V))
       (GO A)
    E    (MESPRI (QUOTE (DIFFERENTIATION WITH RESPECT TO))
             (CAR V)
             (QUOTE (NOT ALLOWED))
              NIL
              T)
        (SETQ ERFG* T) 
       (ERROR*))))
(DIFF1 (LAMBDA (U V)
   (PROG (W X Y Z Z1)
       (COND
        ((KERNP (CONS (CDR U) 1)) (SETQ W (CONS (CAAADR U) 1))))
       (SETQ X (DIFF2 (CAR U) V))
       (SETQ Y
             (COND ((NULL W) (DIFF2 (CDR U) V))
                 (T (DIFFK (LIST (CONS W 1)) V))))
       (SETQ Z
             (COND ((NULL (CAR X)) (CONS NIL 1))
                 (T (CONS (CAR X) (MULTF (CDR X) (CDR U))))))
       (COND ((NULL (CAR Y)) (RETURN Z)))
       (SETQ Z1
             (NEGSQ
            (MULTSQ Y
                  (COND ((NULL W)
                         (CONS (CAR U) (NMULTF (CDR U) 2)))
                        (T
                         (CONS (MULTN (CDAADR U) (CAR U))
                             (MULTF2 W (CDR U))))))))
       (RETURN
        (COND
         ((AND *EXP *MCD)
          (CANCEL
           (CONS (ADDF (MULTF (CAR X)
                        (COND
                         ((NULL W) (MULTF (CDR U) (CDR Y)))
                         (T (MULTF2 W (CDR Y)))))
                   (MULTF (CDR X) (CAR Z1)))
               (MULTF (CDR X) (CDR Z1)))))
         (T (ADDSQ Z Z1)))))))
(DIFF2 (LAMBDA (U V)
   (COND ((ATOM U) (CONS NIL 1))
       (T
        (ADDSQ (DIFF2 (CDR U) V)
             (ADDSQ (MULTS2 (CAAR U) (DIFF2 (CDAR U) V))
                  (DIFFK U V)))))))
(DIFFK (LAMBDA (U *S*)
   (PROG (V W X Y Z)
       (SETQ X (CAAR U))
       (COND
        ((AND (EQ (CAR X) *S*) (SETQ X (CONS 1 1))) (GO D))
        ((OR (ATOM (CAR X))
             (AND (ATOM (CAAR X)) (GET (CAAR X) (QUOTE **ARRAY))))
   (RETURN (COND ((AND (SETQ Z (FKERN (CAR X)))
                        (ASSOC (QUOTE REP) (CDDR Z)))
                  (MKSQ (LIST (QUOTE DF) (CAR X) *S*) 1))
                 (T (CONS NIL 1))))))
       (SETQ Y (FKERN (CAR X)))
       (COND
        ((AND (SETQ V (ASSOC (QUOTE DFN) (CDDR Y)))
            (SETQ V (ASSOC *S* (CADR V)))
            (SETQ X (CDR V)))
         (GO D))
        ((OR (AND (NOT (ATOM (CAAR X)))
                (SETQ X (NMULTSQ (DIFF2 (CAR X) *S*) (CDR X))))
             (AND (EQ (CAAR X) (QUOTE *SQ))
                (SETQ X (DIFF1 (CADAR X) *S*))))
         (GO B))
        ((OR (NOT (SETQ V (GET* (CAAR X) (QUOTE DFN))))
             (NOT
            (DFP (SETQ W
                     (MAPCAR (CDAR X)
                           (FUNCTION
                            (LAMBDA(J)
                             (DIFF1 (SIMP J) *S*)))))
                  V)))
         (GO H)))
       (SETQ Z (CDAR X))
       (SETQ X (CONS NIL 1))
       (COND
        ((NULL
          (*EVAL
           (CONS (QUOTE OR)
               (MAPCAR W
                     (FUNCTION
                      (LAMBDA(J)
                       (LIST (QUOTE QUOTE) (CAR J))))))))
         (GO B)))
    A    (COND ((NULL W) (GO B))
             ((CAAR W)
            (SETQ X
                  (ADDSQ (MULTSQ (CAR W)
                             (SIMP
                              (SUBLIS
                               (PAIR (CAAR V) Z)
                               (CDAR V))))
                        X))))
       (SETQ W (CDR W))
       (SETQ V (CDR V))
       (GO A)
    B    (COND
        ((SETQ V (ASSOC (QUOTE DFN) (CDDR Y))) (GO C))
        (T (ACONC Y (SETQ V (LIST (QUOTE DFN) NIL)))))
       (SETQ DSUBL* (CONS (CDR V) DSUBL*))
    C    (RPLACA (CDR V) (XADD (CONS *S* X) (CADR V) NIL T))
       (COND ((NULL (CAR X)) (RETURN X)))
    D    (SETQ U (CAR U))
       (SETQ W
             (COND ((ONEP (CDAR U)) (CDR U))
                 (T
                  (MULTF2 (GETPOWER (COND (Y Y)
                                    (T (FKERN (CAAR U))))
                              (SUB1 (CDAR U)))
                        (MULTN (CDAR U) (CDR U))))))
       (RETURN (CONS (MULTF (CAR X) W) (CDR X)))
    H    (SETQ V
             (COND
            ((EQ (CAAR X) (QUOTE DF))
                 (CONS (CAAR X) (CONS (CADAR X)
                          (ORDAD *S* (CDDAR X)))))
            (T (LIST (QUOTE DF) (CAR X) *S*))))
       (SETQ X
             (COND ((SETQ W (OPMTCH V)) (SIMP W)) (T (MKSQ V 1))))
       (GO B))))
(DFP (LAMBDA (U V)
   (COND ((NULL U) (NULL V))
       ((NULL V) NIL)
       ((CAAR U) (AND (CAR V) (DFP (CDR U) (CDR V))))
       (T (DFP (CDR U) (CDR V))))))
))
DEFINE ((
(GCDN (LAMBDA (P Q)
   (GCDN0 (ABS P) (ABS Q))))
(GCDN0 (LAMBDA (P Q)
   (COND ((EQUAL P Q) P)
       (*FLOAT (COND ((GREATERP P Q) Q) (T P)))
       ((GREATERP Q P) (GCDN1 Q P))
       (T (GCDN1 P Q)))))
(GCDN1 (LAMBDA (P Q)
   ((LAMBDA (X) (COND ((ZEROP X) Q) (T (GCDN1 Q X))))
    (REMAINDER P Q))))
))
DEFINE ((
(QUOTF (LAMBDA (P Q)
   (COND ((NULL P) NIL)
       ((EQUAL P Q) 1)
       ((EQUAL Q 1) P)
       ((ATOM Q)
        (COND
         ((ATOM P)
            (COND (*FLOAT (TIMES P (RECIP (PLUS 0.0 Q))))
                (T ((LAMBDA (Z)
            (COND ((ZEROP (CDR Z)) (CAR Z))
                (T NIL)))
             (DIVIDE P Q)))))
         (T (QUOTK (CAAR P) P Q))))
       ((ATOM P) NIL)
       (T
        ((LAMBDA(X Y)
          (COND
           ((EQ (CAR X) (CAR Y))
            ((LAMBDA(N)
            (COND
             ((NOT (MINUSP N))
              ((LAMBDA(W)
                (COND
                 (W
                  ((LAMBDA(V Y)
                  (COND ((NULL Y) V)
                        (T
                         ((LAMBDA(Z)
                         (COND (Z (APPEND V Z)) (T NIL)))
                        (QUOTF Y Q)))))
                   (COND ((ZEROP N) W)
                       (T (LIST (CONS (MKSP (CAR X) N) W))))
                   (ADDF P
                       (MULTF
                        (COND ((ZEROP N) Q)
                            (T (MULTF2 (MKSP (CAR X) N) Q)))
                        (MULTN -1 W)))))
                 (T NIL)))
               (QUOTF (CDAR P) (CDAR Q))))
             (T NIL)))
             (DIFFERENCE (CDR X) (CDR Y))))
           ((ORDP X Y) (QUOTK X P Q))
           (T NIL)))
         (CAAR P)
         (CAAR Q))))))
(QUOTK (LAMBDA (X P Q)
   ((LAMBDA(W)
     (COND (W
          (COND ((NULL (CDR P)) (LIST (CONS X W)))
              (T
               ((LAMBDA(Y)
                 (COND (Y (CONS (CONS X W) Y)) (T NIL)))
                (QUOTF (CDR P) Q)))))
         (T NIL)))
    (QUOTF (CDAR P) Q))))
))
DEFINE ((
(ABSONE (LAMBDA (U)
   (AND (NUMBERP U) (ONEP (ABS U)))))
(CDARX (LAMBDA (U)
   (COND ((NULL (CDR U)) (CDAR U))
       (T (ERRACH (LIST (QUOTE CDARX) U))))))
))
DEFINE ((
(PRMCON (LAMBDA (P)
   (PROG (X Y Q)
       (SETQ Q P)
       (COND ((ATOM P) (ERRACH (LIST (QUOTE PRMCON) P)))
             ((AND (NULL (CDR P)) (SETQ X (CAR P))) (GO B)))
       (SETQ Y (CAAAR P))
    A    (COND
        ((OR (AND (OR (ATOM Q) (NOT (EQ (CAAAR Q) Y)))
                (SETQ X (CONS 1 (GCD (REVERSE (CONS Q X))))))
             (AND (NULL (CDR Q))
                (SETQ X
                    (CONS (CAAR Q) (GCD (CONS (CDAR Q) X))))))
         (GO B)))
       (SETQ X (CONS (CDAR Q) X))
       (SETQ Q (CDR Q))
       (GO A)
    B    (RETURN
        (CONS (QUOTF P
                   (COND ((ATOM (CAR X)) (CDR X)) (T (LIST X))))
             X)))))
(GCD (LAMBDA (L)
   (COND ((NULL (CDR L)) (CAR L))
       ((MEMBER 1 L) 1)
       (T (GCD (CONS (GCD1 (CAR L) (CADR L)) (CDDR L)))))))
(GCD1 (LAMBDA (U V)
   (COND
    ((OR (NULL U) (NULL V)) (ERRACH (LIST (QUOTE GCD1) U V)))
    ((EQUAL U V) U)
    ((ATOM U)
     (COND ((ATOM V) (GCDN U V))
         (T (GCD (NCONS (CDR V) (LIST U (CDAR V)))))))
    ((ATOM V) (GCD (NCONS (CDR U) (LIST V (CDAR U)))))
    (T
     ((LAMBDA(X Y)
       (COND ((EQ X Y)
            (PROG (N W X1 Y1 Z Z1 Z2 Z3)
                (SETQ X1 (PRMCON U))
                (SETQ Y1 (PRMCON V))
                (SETQ W 1)
                (SETQ Z1 (CAR X1))
                (SETQ Z2 (CAR Y1))
                (COND
                 ((OR (NULL *GCD) (ABSONE Z1) (ABSONE Z2))
                  (GO A))
                 ((OR (ATOM Z1) (ATOM Z2))
                  (ERRACH (LIST (QUOTE GCDK) U V X1 Y1)))
                 ((EQ (CAAAR Z1) (CAAAR Z2)) (GO C)))
              A    (SETQ W (MULTF W (GCD1 (CDDR X1) (CDDR Y1))))
                (RETURN
                 (COND
                  ((OR (ATOM (CADR X1)) (ATOM (CADR Y1))) W)
                  ((ORDP (CADR X1) (CADR Y1))
                   (MULTF2 (CADR Y1) W))
                  (T (MULTF2 (CADR X1) W))))
              C    (COND ((ORDP Z1 Z2) (GO D)))
                (SETQ Z Z1)
              D1   (SETQ Z1 Z2)
                (SETQ Z2 Z)
              D    (SETQ Z (REMK Z1 Z2))
                (COND (Z (GO G)))
                (SETQ W (CAR (PRMCON Z2)))
                (GO A)
              G    (COND ((NULL N) (GO H)))
                (SETQ Z (QUOTF Z (NMULTF Z3 N)))
                (COND
                 ((NULL Z)
                  (REDERR
                   (LIST (QUOTE (INTEGER OVERFLOW)) Z3 N))))
              H    (SETQ N
                    (ADD1 (DIFFERENCE (CDAAR Z1) (CDAAR Z2))))
                (SETQ Z3 (CDAR Z2))
                (COND
                 ((OR (ATOM Z)
                    (NULL (CDR Z))
                    (NOT (EQ (CAAAR Z) (CAAAR Z1))))
                  (GO A)))
                (GO D1)))
           ((ORDP X Y) (GCD (CONS V (COEFF U X))))
           (T (GCD (CONS U (COEFF V Y))))))
      (CAAAR U)
      (CAAAR V))))))
(COEFF (LAMBDA (U A)
   (COND ((NULL U) NIL)
       ((OR (ATOM U) (NOT (EQ (CAAAR U) A))) (LIST U))
       (T (CONS (CDAR U) (COEFF (CDR U) A))))))
(REMK (LAMBDA (U V)
   (REMK1 U V (CAAR V) NIL)))
(REMK1 (LAMBDA (U V W Z)
   (COND
    ((AND (NOT (ATOM U)) (ORDP (CAAR U) W))
     (REMK1 (ADDF (MULTF (CDAR V) U)
              ((LAMBDA(M X)
                (COND ((ZEROP M) (MULTN -1 X))
                    (T
                     (MULTF
                      (LIST (CONS (MKSP (CAAAR U) M) -1))
                      X))))
               (DIFFERENCE (CDAAR U) (CDR W))
               (MULTF (CDAR U) V)))
           V
           W
          (MULTF Z (CDAR V))))
    ((NULL Z) U)
    (T (CANCEL (CONS U Z))))))
(REMK* (LAMBDA (U V)
   (REMK1 U V (CAAR V) 1)))
(NMULTF (LAMBDA (U N)
   (COND ((OR *EXP (KERNLP U)) (NMULTF1 U N)) (T (MKSFP U N)))))
(NMULTF1 (LAMBDA (U N)
   (COND ((ONEP N) U) (T (MULTF U (NMULTF1 U (SUB1 N)))))))
))
DEFINE ((
(OPERATOR (LAMBDA (U)
   (PROG NIL
       (COND
        ((EQ *MODE (QUOTE SYMBOLIC))
         (RETURN (FLAG U (QUOTE OPFN)))))
    A    (COND ((NULL U) (RETURN NIL))
             ((OR (NUMBERP (CAR U)) (NOT (ATOM (CAR U))))
            (LPRIM*
             (CONS (CAR U) (QUOTE (CANNOT BE AN OPERATOR)))))
             ((GET (CAR U) (QUOTE SIMPFN))
            (LPRIM* (CONS (CAR U) (QUOTE (ALREADY DEFINED)))))
             (T (MKOP (CAR U))))
       (SETQ U (CDR U))
       (GO A))))
(FACTOR (LAMBDA (U)
   (FACTOR1 U T (QUOTE FACTORS*))))
(FACTOR1 (LAMBDA (U V W)
   (PROG (X Y)
       (SETQ Y (GTS W))
   A     (COND ((NULL U) (GO B))
             ((OR (KERNP (SETQ X (SIMPCAR U)))
                (AND *SUPER (KERNP (SETQ X (MKSFP X 1)))))
            (GO C))
             (T (ERRPRI2 (CAR U))))
       (GO D)
    C    (SETQ X (CAAAAR X))
       (COND (V (SETQ Y (CONS X Y)))
             ((NOT (MEMBER X Y))
            (MESPRI NIL (CAR U) (QUOTE (NOT FOUND)) NIL NIL))
             (T (SETQ Y (DELETE X Y))))
    D    (SETQ U (CDR U))
         (GO A)
   B     (PTS W Y))))
(REMFAC (LAMBDA (U)
   (FACTOR1 U NIL (QUOTE FACTORS*))))
))
DEFINE ((
(FORALLFN* (LAMBDA NIL
   (FORALLFN (RVLIS))))
(FORALLFN (LAMBDA (U)
   (PROG (X Y)
       (SETQ X (MAPCAR U (FUNCTION NEWVAR)))
       (SETQ Y (PAIR U X))
       (SETQ MCOND* (SUBLIS Y MCOND*))
       (SETQ FRLIS* (UNION X FRLIS*))
       (SETQ X (LIST (COMMAND1 NIL)))
      (COND (MCOND* (SETQ X (CONS (LIST (QUOTE SETQ)
                (QUOTE MCOND*) (LIST (QUOTE QUOTE) MCOND*)) X))))
      (COND (Y (SETQ X (CONS (LIST (QUOTE SETQ) (QUOTE FRASC*)
            (LIST (QUOTE QUOTE) Y)) X))))
       (RETURN (MKPROG NIL X)))))
))
DEFINE ((
(LET (LAMBDA (U)
   (LET0 U NIL)))
(LET0 (LAMBDA (U V)
   (PROG NIL
    A    (COND ((NULL U) (RETURN (SETQ MCOND* (SETQ FRASC* NIL))))
             ((OR (NOT (EQCAR (CAR U) (QUOTE EQUAL))) (CDDDAR U))
            (ERRPRI2 (CAR U))))
       (LET2 (CADAR U) (CAR (CDDAR U)) V T)
       (SETQ U (CDR U))
       (GO A))))
(LET1 (LAMBDA (U V)
   (LET2 U V NIL T)))
(LET2 (LAMBDA (U V W B)
   (PROG (X Y Z)
       (SETQ U (SUBLIS FRASC* U))
       (SETQ V (SUBLIS FRASC* V))
      (COND ((AND FRASC* (EQCAR V (QUOTE *SQ)))
            (SETQ V (PREPSQ (CADR  V)))))
    A    (SETQ X U)
       (COND ((NUMBERP X) (GO LER1))
             ((NOT (ATOM X)) (GO D))
                ((AND (SETQ Y (GET X (QUOTE OLDNAME)))
                 (NOT (MEMBER Y (FLATTEN V)))) (LET2 Y V W B)))
         (COND (B (GO A2)))
         (REMPROP X (QUOTE NEWNAME))
         (REMPROP X (QUOTE OLDNAME))
    A2   (COND
        ((AND (VECTORP X) (VLET X V B)) (RETURN NIL))
        ((AND (NULL B) (GET X (QUOTE **ARRAY))) (GO J2))
        (W (GO H))
        ((MATEXPR V) (GO J)))
    B1   (SETQ X (SIMP0 X))
    C    (SETQ X (CAAAR X))
       (SETQ Z (FKERN (CAR X)))
         (COND ((NULL B) (RETURN (RPLACD (CDR Z) NIL)))
               ((ASSOC (QUOTE USED*) (CDR Z)) (RMSUBS2)))
       (XADD
        (COND
         ((AND (EQUAL V 0) (NOT (EQUAL (CDR X) 1)))
          (CONS (QUOTE ASYMP) (CDR X)))
         (T (LIST (QUOTE REP) V (CDR X) NIL)))
        (CDR Z)
        (SQCHK (CAR Z))
        T)
       (RPLACW Z (DELASC (QUOTE DFN) Z))
       (RETURN NIL)
    D    (COND ((NOT (ATOM (CAR X))) (GO LER2))
               ((GET* (CAR X) (QUOTE **ARRAY)) (GO L))
               ((EQ (CAR X) (QUOTE DF)) (GO K))
             ((NOT (GET* (CAR X) (QUOTE SIMPFN))) (GO LER3))
             ((OR W
                (EQ (CAR X) (QUOTE TIMES))
                (XN (FLATTEN (CDR X)) FRLIS*))
            (GO H)))
       (SETQ X (SIMP0 X))
       (COND ((NOT (EQUAL (CDR X) 1)) (GO LER1)))
    E    (COND ((NOT (KERNP X)) (GO G))
             ((NOT (ONEP (CDAAR X)))
            (SETQ V (LIST (QUOTE QUOTIENT) V (CDAAR X)))))
       (GO C)
    G    (COND ((NOT (KERNLP (CAR X))) (GO M)))
       (SETQ X U)
   H     (RMSUBS)
         (COND
        ((OR (NULL
            (SETQ Y
                  (KERNLP
                   (CAR (SETQ X (SIMP0 X))))))
             (NOT (ATOM (CDR X))))
         (GO LER2))
        ((AND (ONEP Y) (ONEP (CDR X))) (GO H1)))
       (SETQ V (LIST (QUOTE TIMES) (CDR X) V))
       (COND
        ((NOT (ONEP Y))
         (SETQ V (ACONC V (LIST (QUOTE QUOTIENT) 1 Y)))))
    H1   (SETQ X (KLISTT (CAR X)))
       (SETQ Y
             (LIST (CONS W (COND (MCOND* MCOND*) (T T)))
                  V
                  NIL))
       (COND
        ((AND (NULL W) (NULL (CDR X)) (ONEP (CDAR X))) (GO H2)))
       (RETURN (SETQ MATCH* (XADD (CONS X Y) MATCH* U B)))
    H2   (SETQ X (CAAR X))
         (COND ((NOT (MATEXPR V)) (GO H3))
           ((NOT (REDMSG (CAR X) (QUOTE MATRIX) T)) (ERROR*)))
         (FLAG (LIST (CAR X)) (QUOTE MATFN))
   H3    (RETURN (PUT (CAR X)
            (QUOTE OPMTCH*)
                  (XADD (CONS (CDR X) Y)
                       (GET (CAR X) (QUOTE OPMTCH*))
                     U B)))
    J    (SETQ MATP* T)
       (COND ((GET X (QUOTE MATRIX)) (GO J1))
             ((NOT (REDMSG X (QUOTE MATRIX) T)) (ERROR*)))
       (PUT X (QUOTE MATRIX) (QUOTE MATRIX))
    J1   (COND ((EQCAR V (QUOTE MAT)) (RETURN (SETM X V)))
             (T (GO B1)))
    J2   (REMPROP X (QUOTE MATRIX))
       (REMPROP X (QUOTE **ARRAY))
        (REMPROP X (QUOTE ARRAY)) 
       (RETURN NIL)
    K    (COND
        ((AND (NOT (ATOMLIS (CADR X))) (CDDDR X)) (GO LER1))
        ((AND (NOT (GET* (CAADR X) (QUOTE SIMPFN)))
            (SETQ X (CADR X)))
         (GO LER3))
        ((OR (NOT (FRLP (CDADR X)))
             (NOT (FRLP (CDDR X)))
             (NOT (MEMBER (CADDR X) (CDADR X))))
         (GO H)))
       (SETQ Z (POSN (CADDR X) (CDADR X)))
       (COND
        ((NOT (GET (CAADR X) (QUOTE DFN)))
         (PUT (CAADR X)
            (QUOTE DFN)
            (NLIST NIL (LENGTH (CDADR X))))))
       (COND
        ((NULL (REPN (GET (CAADR X) (QUOTE DFN)) Z V X))
         (GO LER1)))
       (RETURN NIL)
    L    (COND ((AND (SETQ Z (ASSOC* X (GET (CAR X) (QUOTE KLIST))))
                 (ASSOC (QUOTE USED*) (CDR Z))) (RMSUBS2)))
         (SETEL (CONS (CAR X) (MAPCAR (CDR X) (FUNCTION
                REVAL))) V)
       (RETURN NIL)
    M    (COND ((NULL *SUPER) (GO LER1)))
       (SETQ X (CONS (MKSFP (CAR X) 1) 1))
       (GO E)
    LER1 (ERRPRI2 U)
       (ERROR*)
    LER2 (ERRPRI1 U)
       (ERROR*)
    LER3 (COND ((NOT (REDMSG (CAR X) (QUOTE OPERATOR) T)) (ERROR*)))
       (MKOP (CAR X))
       (GO A))))
(FRLP (LAMBDA (U)
   (OR (NULL U) (AND (MEMBER (CAR U) FRLIS*) (FRLP (CDR U))))))
(SIMP0 (LAMBDA (U)
   (PROG (X)
       (SETQ SUBFG* NIL)
       (SETQ X (SIMP U))
       (SETQ SUBFG* T)
       (RETURN X))))
(MATCH (LAMBDA (U)
   (LET0 U T)))
(CLEAR (LAMBDA (U)
   (PROG NIL
         (RMSUBS)
    A    (COND ((NULL U) (RETURN (SETQ MCOND* (SETQ FRASC* NIL)))))
    B    (LET2 (CAR U) NIL NIL NIL)
       (SETQ U (CDR U))
       (GO A))))
(KLISTT (LAMBDA (U)
   (COND ((ATOM U) NIL) (T (CONS (CAAR U) (KLISTT (CDARX U)))))))
))
DEFINE ((
(KERNP (LAMBDA (U)
   (AND (ATOM (CDR U))
      (NOT (ATOM (CAR U)))
      (NULL (CDAR U))
      (ATOM (CDAAR U)))))
(KERNLP (LAMBDA (U)
   (COND ((ATOM U) U) ((NULL (CDR U)) (KERNLP (CDAR U))) (T NIL))))
(RMSUBS (LAMBDA NIL
   (PROG2 (RMSUBS1) (RMSUBS2))))
(RMSUBS2 (LAMBDA NIL
   (PROG2 (RPLACA *SQVAR* NIL) (SETQ *SQVAR* (LIST T)))))
(RMSUBS1 (LAMBDA NIL
   (PROG NIL
       (MAP (APPEND DSUBL* SUBL*)
            (FUNCTION (LAMBDA (J) (RPLACA (CAR J) NIL))))
       (SETQ SUBL* NIL))))
(XADD (LAMBDA (U V W B)
   (PROG (X)
       (SETQ X (ASSOC* (CAR U) V))
       (COND ((NULL X) (GO C)) ((NULL B) (GO B1)))
         (RMSUBS1)
       (RPLACD X (CDR U))
    A    (RETURN V)
    B1   (SETQ V (DELETE X V))
       (GO A)
    C    (COND ((NULL B) (MESPRI NIL W (QUOTE (NOT FOUND)) NIL NIL))
             (T (SETQ V (NCONC V (LIST U)))))
       (GO A))))
(REPN (LAMBDA (U N V W)
   (PROG NIL
    A    (COND ((OR (NULL U) (ZEROP N)) (RETURN NIL))
             ((NOT (ONEP N)) (GO B))
             ((CAR U) (REDEFPRI W)))
       (RETURN (RPLACA U (CONS (CDADR W) V)))
    B    (SETQ U (CDR U))
       (SETQ N (SUB1 N))
       (GO A))))
(DENOM (LAMBDA (U)
   (PROG2 (LET1 U (MK*SQ (CONS (CDR (SIMP *ANS)) 1))) 
          (SETQ MCOND* (SETQ FRASC* NIL)))))
(NUMER* (LAMBDA (U) 
   (LET1 U (MK*SQ (CONS (CAR (SIMP *ANS)) 1)))))
(ND (LAMBDA (U V)
   (PROG2 (NUMER* U) (DENOM V)))) 
 
(NUMER (LAMBDA (U) 
   (PROG2 (NUMER* U) (SETQ MCOND* (SETQ FRASC* NIL)))))
(SAVEAS (LAMBDA (U)
   (SETK U *ANS)))
(SETK (LAMBDA (U V)
   (PROG2 (LET1 U
            (COND
             ((AND(NOT (ATOM U))(NOT (ATOM V))(XN (CDR U) FRLIS*))
              (PREPSQ (CADR V)))
             (T V)))
         V)))
(TERMS (LAMBDA NIL
   (PRINTTY
    (COND
     ((EQCAR *ANS (QUOTE *SQ)) (TERMS1 (CAADR *ANS)))
     (T (SCNT *ANS))))))
(TERMS1 (LAMBDA (U)
   (PROG (N)
       (SETQ N 0)
    A    (COND ((NULL U) (RETURN N)) ((ATOM U) (RETURN (ADD1 N))))
       (SETQ N (PLUS N (TERMS1 (CDAR U))))
       (SETQ U (CDR U))
       (GO A))))
))
DEFINE ((
(ANTISYMMETRIC (LAMBDA (U)
   (FLAG U (QUOTE ANTISYMMETRIC))))
(SYMMETRIC (LAMBDA (U)
   (FLAG U (QUOTE SYMMETRIC))))
))
FLAG ((PLUS TIMES CONS) SYMMETRIC)
FLAG ((PLUS TIMES) NARY)
DEFINE ((
(MKCOEFF (LAMBDA (U V)
   (PROG (W X Y Z)
       (COND ((NOT (ATOM U)) (SETQ U (REVAL U))))
       (SETQ X FACTORS*)
       (SETQ FACTORS* (LIST U))
       (SETQ W
             (COND
            ((EQCAR *ANS (QUOTE *SQ)) (CADR *ANS))
            (T (SIMP *ANS))))
       (SETQ Y (CONS (FORMOP (CAR W)) (FORMOP (CDR W))))
       (COND
        ((NULL (EQUAL (CDR Y) 1))
         (LPRIM* (QUOTE (MKCOEFF GIVEN RATIONAL FUNCTION)))))
       (SETQ W (CDR Y))
       (SETQ Y (CAR Y))
    A    (COND ((OR (ATOM Y) (NOT (EQUAL (CAAAR Y) U))) (GO B)))
       (SETQ Z
             (CONS (CONS (CDAAR Y)
                     (PREPSQ (CANCEL (CONS (CDAR Y) W))))
                  Z))
       (SETQ Y (CDR Y))
       (GO A)
    B    (COND ((NULL Y) (GO B1)))
       (SETQ Z (CONS (CONS 0 (PREPSQ (CANCEL (CONS Y W)))) Z))
    B1   (COND
          ((OR (AND (NOT (ATOM V)) (ATOM (CAR V))
             (SETQ Y (GET* (CAR V) (QUOTE **ARRAY))))
           (AND (ATOM V)
                (SETQ Y (GET* V (QUOTE **ARRAY)))
                (NULL (CDR Y))))
         (GO G)))
       (SETQ Y (EXPLODE V))
       (SETQ V NIL)
    C    (COND ((NULL Z) (GO D)))
       (SETQ V
             (CONS (LIST (QUOTE EQUAL)
                     (COMPRESS (APPEND Y (EXPLODE (CAAR Z))))
                     (CDAR Z))
                  V))
       (SETQ Z (CDR Z))
       (GO C)
    D    (*APPLY (QUOTE LET) (LIST V))
       (COND
        (*MSG
         (LPRI
          (NCONC (MAPLIST V (FUNCTION CADAR))
               (QUOTE (ARE NON ZERO))))))
    E    (SETQ FACTORS* X)
         (RETURN NIL)
   G     (SETQ Z (REVERSE Z))
         (COND ((ATOM V) (SETQ V (LIST V (QUOTE *)))))
       (COND
        (*MSG
         (LPRI
          (APPEND (QUOTE (HIGHEST POWER IS)) (LIST (CAAR Z))))))
         (SETQ Y (PAIR (CDR V) Y))
   G0    (COND ((AND (MEMBER (QUOTE *) (FLATTEN (CAAR Y)))
                     (SETQ Y (PLUS (CDAR Y) (MINUS (REVAL
                       (SUBST 0 (QUOTE *) (CAAR Y)))))))  (GO G1)))
         (SETQ Y (CDR Y))
         (GO G0)
   G1    (COND
        ((GREATERP (CAAR Z) Y) (REDERR (QUOTE (ARRAY TOO SMALL)))))
    H    (COND
        ((OR (NULL Z) (NOT (EQUAL Y (CAAR Z))))
           (SETEL (SUBST Y (QUOTE *) V) 0))
          (T (PROG2 (SETEL (SUBST Y (QUOTE *) V) (CDAR Z))
                 (SETQ Z (CDR Z)))))
         (COND ((ZEROP Y) (GO E)))
       (SETQ Y (SUB1 Y))
       (GO H))))
))
DEFINE ((
(WEIGHT (LAMBDA (U)
   (PROG (X Y)
       (RMSUBS)
    A    (COND ((NULL U) (RETURN NIL))
             ((OR (NOT (EQ (CAAR U) (QUOTE EQUAL)))
                    (NOT (AND (ATOM (CADAR U))
                           (NOT (NUMBERP (CADAR U)))))
                (NOT
                 (AND (NUMBERP (CADDAR U))
                    (FIXP (CADDAR U))
                           (NOT (MINUSP (CADDAR U))))))
                (ERRPRI1 (CAR U))))
         (SETQ Y (CADAR U))
         (COND ((SETQ X (GET Y (QUOTE OLDNAME))) (GO C)))
         (SETQ X (NEWVAR Y))
         (PUT Y (QUOTE NEWNAME) X)
         (PUT X (QUOTE OLDNAME) Y)
         (FLAG (LIST X) (QUOTE WEIGHT))
   B     (LET2 X
               (LIST (QUOTE TIMES)
                      Y
                     (LIST (QUOTE EXPT) (QUOTE K*) (CADDAR U)))
               NIL
               T)
         (SETQ U (CDR U))
         (GO A)
   C     (COND ((NOT (FLAGP Y (QUOTE WEIGHT))) (ERRPRI1 (CAR U))))
         (SETQ Y X)
         (SETQ X (CADAR U))
         (GO B))))
(WTLEVEL (LAMBDA (N)
   (PROG (X)
         (SETQ N (REVAL N))
         (COND
           ((NOT (AND (NUMBERP N) (FIXP N) (NOT (MINUSP N))))
            (ERRPRI1 N)))
         (SETQ X (ASSOC (QUOTE ASYMP) (CDDR (FKERN (QUOTE K*)))))
         (COND ((EQUAL N (CDR X)) (RETURN NIL))
               ((NOT (GREATERP N (CDR X))) (RMSUBS2)))
         (RMSUBS1)
         (RPLACD X N))))
))
DEFLIST (((WEIGHT RLIS) (WTLEVEL NORLIS)) STAT)
LET1 ((EXPT K* 2) 0)
COMMENT ((ELEMENTARY FUNCTION PROPERTIES))
DEFLIST (((LOG IDEN) (COS IDEN) (SIN IDEN)) SIMPFN)
DEFLIST ((
  (LOG (((LOG E) (((LOG E) . 1)) (REP 1 1 NIL))
      ((LOG 1) (((LOG 1) . 1)) (REP 0 1 NIL))))
  (COS (((COS 0) (((COS 0) . 1)) (REP 1 1 NIL))))
  (SIN (((SIN 0) (((SIN 0) . 1)) (REP 0 1 NIL))))
) KLIST)
DEFLIST ((
  (EXPT (((X Y) TIMES Y (EXPT X (PLUS Y (MINUS 1))))
        ((X Y) TIMES (LOG X) (EXPT X Y))))
(LOG (((X) QUOTIENT 1 X)))
(COS (((X) MINUS (SIN X))))
(SIN (((X) COS X)))
) DFN)
DEFLIST ((
  (COS ((((MINUS ***X)) (NIL  . T) (COS ***X) NIL)))
  (SIN ((((MINUS ***X)) (NIL . T) (MINUS (SIN ***X)) NIL)))
) OPMTCH*)
PTS (FRLIS* (***X))
DEFINE ((
(MSIMP (LAMBDA (U V)
   (PROG (X Y Z)
       (COND ((AND (NULL V) SUBFG*) (SETQ U (SUBLIS VREP* U))))
       (SETQ U (MSIMP1 U V))
    A1   (COND ((NULL U) (RETURN Z)))
    A0   (SETQ X (CAR U))
    A    (COND ((AND V (NULL X)) (GO D))
             ((NULL X) (GO NULLU))
             ((OR (AND (NULL V) (VECTORP (CAR X)))
                (AND V (MATP (CAR X))))
            (GO B)))
    BACK (SETQ X (CDR X))
       (GO A)
    B    (SETQ Y (LIST (CAR X)))
       (SETQ X (CDR X))
    C    (COND ((NULL X) (GO D))
             ((AND (NULL V) (VECTORP (CAR X)))
            (REDERR
             (APPEND (QUOTE (REDUNDANT VECTOR)) (LIST (CAR U)))))
             ((AND V (MATP (CAR X))) (SETQ Y (ACONC Y (CAR X)))))
       (SETQ X (CDR X))
       (GO C)
    D    (SETQ X (SETDIFF (CAR U) Y))
       (SETQ Z
             (ADDM1 (CONS (COND ((NULL X) (CONS 1 1))
                          (T (SIMPTIMES X)))
                      (REVERSE Y))
                   Z))
       (SETQ U (CDR U))
       (GO A1)
    E    (VECTOR (LIST (CAAR U)))
       (GO A0)
    NULLU
       (COND
        ((AND (ATOM (CAAR U))
            (NOT (NUMBERP (CAAR U)))
            (REDMSG (CAAR U) (QUOTE VECTOR) T))
         (GO E))
        (T
         (REDERR
          (APPEND (QUOTE (MISSING VECTOR)) (LIST (CAR U))))))
       (GO BACK))))
(MSIMP1 (LAMBDA (U1 *S*) ((LAMBDA (U)
   (COND ((NUMBERP U) (LIST (LIST U)))
       ((ATOM U)
        ((LAMBDA(X)
            (COND ((AND X SUBFG* (EQUAL (CADDR X) 1))
                   (MSIMP1 (CADR X) *S*))
              (T
               (PROG2
                (COND ((NULL *S*) (FLAG (LIST U) (QUOTE USED*)))
                    (T NIL))
                (LIST (LIST U))))))
         (ASSOC (QUOTE REP) (CDDR (FKERN U)))))
       ((EQ (CAR U) (QUOTE PLUS))
        (MAPCON (CDR U)
              (FUNCTION (LAMBDA (J) (MSIMP1 (CAR J) *S*)))))
       ((EQ (CAR U) (QUOTE MINUS))
        (MSIMPTIMES (LIST -1 (CARX (CDR U))) *S*))
       ((EQ (CAR U) (QUOTE TIMES)) (MSIMPTIMES (CDR U) *S*))
         ((EQ (CAR U) (QUOTE QUOTIENT))
          (MSIMPTIMES (LIST (CADR U)
                            (LIST (QUOTE RECIP) (CARX (CDDR U))))
                      *S*))
       ((OR (NULL *S*) (EQCAR U (QUOTE MAT)) (NOT (MATEXPR U)))
        (LIST (LIST U)))
       ((EQ (CAR U) (QUOTE RECIP)) (MSIMPRS (CARX (CDR U)) NIL))
       ((EQ (CAR U) (QUOTE SOLVE))
        (MSIMPRS (CADR U) (MATSIMP (MSIMP (CADDR U) T))))
       (T
        ((LAMBDA(Z)
          (COND
           ((OR (NOT (EQ (CAR U) (QUOTE EXPT)))
              (NOT (NUMBERP Z))
              (NOT (FIXP Z)))
            (REDERR (QUOTE (MATRIX SYNTAX))))
           ((MINUSP Z)
           (MSIMPRS
            (CONS (QUOTE TIMES) (NLIST (CADR U) (MINUS Z))) NIL))
           (T (MSIMPTIMES (NLIST (CADR U) Z) T))))
         ((LAMBDA(Y)
           (COND
            ((AND (EQCAR Y (QUOTE MINUS)) (NUMBERP (CADR Y)))
             (MINUS (CADR Y)))
            (T Y)))
            (REVAL (CADDR U))))))) (EMTCH U1))))
(MSIMPTIMES (LAMBDA (U V)
   (COND ((NULL U) (ERRACH (QUOTE MSIMPTIMES)))
       ((NULL (CDR U)) (MSIMP1 (CAR U) V))
       (T
        ((LAMBDA(*S*)
          (MAPCON (MSIMPTIMES (CDR U) V)
                (FUNCTION
                 (LAMBDA(*S1*)
                  (MAPCAR *S*
                        (FUNCTION
                         (LAMBDA(K)
                        (APPEND (CAR *S1*) K))))))))
         (MSIMP1 (CAR U) V))))))
(ADDM1 (LAMBDA (U V)
   (COND ((NULL V) (LIST U))
       ((EQUAL (CDR U) (CDAR V))
        ((LAMBDA(X)
          (COND ((NULL (CAR X)) (CDR V))
              (T (CONS (CONS X (CDR U)) (CDR V)))))
         (ADDSQ (CAR U) (CAAR V))))
       ((ORDP (CDR U) (CDAR V)) (CONS U V))
       (T (CONS (CAR V) (ADDM1 U (CDR V)))))))
))
DEFINE ((
(MATP (LAMBDA (U)
   (COND ((ATOM U) (FLAGP** U (QUOTE MATRIX)))
       (T (EQCAR U (QUOTE MAT))))))
(MATEXPR (LAMBDA (U)
   (AND MATP* (MATEXPR1 U))))
(MATEXPR1 (LAMBDA (U)
   (COND ((NULL U) NIL)
       ((ATOM U) (MATP U))
       ((MEMBER (CAR U) (QUOTE (*SQ DET TRACE))) NIL)
         ((OR (FLAGP** (CAR U) (QUOTE MATFN)) (MATEXPR1 (CADR U))) T)
       (T
        (*EVAL
         (CONS (QUOTE OR) (MAPCAR (CDR U) (FUNCTION MATEXPR1))))))))
))
FLAG ((MAT) MATFN)
DEFINE ((
(MATSM (LAMBDA (U)
   ((LAMBDA(X)
     (COND
      ((AND (NULL (CDR X)) (NULL (CDAR X))) (SIMP (CAAR X)))
      (T (CONS (QUOTE MAT) X))))
    (MAPC2 (MATSIMP (MSIMP U T))
         (FUNCTION (LAMBDA (J) (MK*SQ (SUBS2 J))))))))
))
DEFINE ((
(MATSIMP (LAMBDA (U)
   (PROG (X)
       (SETQ X (SMMULT (CAAR U) (MMULT (CDAR U))))
    A    (SETQ U (CDR U))
       (COND ((NULL U) (RETURN X)))
       (SETQ X (MADD X (SMMULT (CAAR U) (MMULT (CDAR U)))))
       (GO A))))
(MMULT (LAMBDA (U)
   (PROG (Y Z)
       (SETQ Y (GETM* (CAR U)))
    A    (SETQ U (CDR U))
       (COND ((NULL U) (RETURN Y)))
       (SETQ Z (GETM* (CAR U)))
       (COND
        ((NOT (EQUAL (LENGTH (CAR Y)) (LENGTH Z)))
         (REDERR (QUOTE (MATRIX MISMATCH)))))
       (SETQ Y (MULTM Y Z))
       (GO A))))
(SMMULT (LAMBDA (*S* V)
   (COND ((EQUAL *S* (CONS 1 1)) V)
       (T (MAPC2 V (FUNCTION (LAMBDA (J) (MULTSQ *S* J))))))))
(GETM* (LAMBDA (U)
   (COND ((EQCAR U (QUOTE MAT)) (SIMPDET* (CDR U)))
       (T
        ((LAMBDA(X)
          (COND
           ((OR (NULL X) (EQ X (QUOTE MATRIX)))
            (REDERR
             (CONS (QUOTE MATRIX) (CONS U (QUOTE (NOT SET))))))
           (T (MLIST U (CAR X) (CADR X)))))
         (COND ((ATOM U) (GET U (QUOTE MATRIX))) (T NIL)))))))
(MLIST (LAMBDA (U M N)
   (PROG (M1 N1 X Y Z)
       (SETQ M1 M)
    A    (SETQ Y NIL)
       (SETQ N1 N)
    B    (COND
        ((NULL (SETQ X (GETEL (LIST U M1 N1))))
         (REDERR (CONS U (CONS (LIST M1 N1) (QUOTE (NOT SET)))))))
       (SETQ Y (CONS (SIMP X) Y))
       (SETQ N1 (SUB1 N1))
       (COND ((NOT (ZEROP N1)) (GO B)))
       (SETQ Z (CONS Y Z))
       (SETQ M1 (SUB1 M1))
       (COND ((ZEROP M1) (RETURN Z)))
       (GO A))))
))
DEFINE ((
(MADD (LAMBDA (U V)
   (MAPCAR (PAIR U V)
         (FUNCTION (LAMBDA (J) (MADD1 (CAR J) (CDR J)))))))
(MADD1 (LAMBDA (U V)
   (COND ((NULL U) NIL)
       (T (CONS (ADDSQ (CAR U) (CAR V)) (MADD1 (CDR U) (CDR V)))))))
))
DEFLIST (((MATRIX RLIS)) STAT)
DEFINE ((
(MATRIX (LAMBDA (U)
   (PROG NIL
       (SETQ MATP* T)
    A    (COND ((NULL U) (RETURN NIL))
             ((ATOM (CAR U))
            (PUT (CAR U)
                 (QUOTE MATRIX)
                 ((LAMBDA (X) (COND (X X) (T (QUOTE MATRIX))))
                  (GET* (CAR U) (QUOTE **ARRAY)))))
             (T
            (PROG2 (*APPLY (QUOTE AARRAY) (LIST (LIST (CAR U))))
                       (PUT (CAAR U) (QUOTE MATRIX)
                        (MAPCAR (CDAR U) (FUNCTION REVAL))))))
       (SETQ U (CDR U))
       (GO A))))
))
DEFINE ((
(MULTM (LAMBDA (U *S*)
   (MAPCAR U
         (FUNCTION
          (LAMBDA (J) (MULTM1 J *S* (LENGTH (CAR *S*)) NIL))))))
(MULTM1 (LAMBDA (U V N W)
   (COND ((ZEROP N) W)
       (T (MULTM1 U V (SUB1 N) (CONS (MELEM U V N) W))))))
(MELEM (LAMBDA (U V N)
   (COND ((NULL U) (CONS NIL 1))
       (T
        ((LAMBDA (X) (COND ((NULL (CAR X)) (CONS NIL 1)) (T X)))
         (ADDSQ (MULTSQ (CAR U) (NTH (CAR V) N))
              (MELEM (CDR U) (CDR V) N)))))))
))
DEFINE ((
(MATPRI (LAMBDA (U X)
   (PROG (V M N)
       (SETQ M 1)
       (COND ((NULL X) (SETQ X (QUOTE MAT))))
    A    (COND ((NULL U) (RETURN NIL)))
       (SETQ N 1)
       (SETQ V (CAR U))
    B    (COND ((NULL V) (GO C))
            ((AND (EQUAL (CAR V) 0) *NERO) (GO B1)))
            (MAPRIN (LIST X M N))
       (OPRIN (QUOTE EQUAL))
       (SETQ ORIG* POSN*)
       (MATHPRINT (CAR V))
       (SETQ ORIG* 0)
       (TERPRI*)
   B1        (SETQ V (CDR V))
       (SETQ N (ADD1 N))
       (GO B)
    C    (SETQ U (CDR U))
       (SETQ M (ADD1 M))
       (GO A))))
))
DEFINE ((
(SETM (LAMBDA (U V)
   (PROG (N M X Y)
       (SETQ V (CDR V))
       (SETQ Y (LIST (LENGTH V) (LENGTH (CAR V))))
       (COND
        ((NOT (EQ (SETQ X (GET U (QUOTE MATRIX))) (QUOTE MATRIX)))
         (GO A)))
       (*APPLY (QUOTE AARRAY) (LIST (LIST (CONS U Y))))
       (PUT U (QUOTE MATRIX) Y)
       (GO A1)
    A    (COND
        ((NOT (EQUAL X Y)) (REDERR (QUOTE (MATRIX MISMATCH)))))
    A1   (SETQ M 1)
    B    (SETQ Y (CAR V))
       (SETQ N 1)
    C    (COND ((NULL Y) (GO D)))
       (SETEL (LIST U M N) (CAR Y))
       (SETQ N (ADD1 N))
       (SETQ Y (CDR Y))
       (GO C)
    D    (SETQ V (CDR V))
       (COND ((NULL V) (RETURN NIL)))
       (SETQ M (ADD1 M))
       (GO B))))
))
DEFINE ((
(MSIMPRS (LAMBDA (U V)
   ((LAMBDA(X)
     (LIST
      (LIST
       (CONS (QUOTE MAT)
           (MAPC2
            (COND
             ((AND (NULL (CDR X)) (NULL V))
            (SMMULT (REVPR (CAAR X))
                  (*MATINV (MMULT (CDAR X)) NIL)))
             (T (*MATINV (MATSIMP X) V)))
            (FUNCTION MK*SQ))))))
    (MSIMP U T))))
))
DEFINE ((
(AUGMENT (LAMBDA (U V)
   (COND ((NULL U) NIL)
       (T
        (CONS (APPEND (CAR U) (CAR V)) (AUGMENT (CDR U) (CDR V))))))
)
))
DEFINE ((
(SETMATELEM (LAMBDA (U I J ELEM)
   (PROG (A)
       (SETQ A (NTH U I))
    LOOP (COND ((EQUAL J 1) (RETURN (RPLACA A ELEM))))
       (SETQ J (SUB1 J))
       (SETQ A (CDR A))
       (GO LOOP))))
))
DEFINE ((
(LIPSON (LAMBDA (U M N V)
   (PROG (AA AA1 K K1 K2 I J TEMP BB C0 CI1 CI2 AAK)
       (SETQ AA (CONS 1 1))
       (SETQ K 2)
    BEG  (SETQ K1 (SUB1 K))
       (SETQ K2 (SUB1 K1))
       (COND ((GREATERP K M) (GO FB)) ((EQUAL K 2) (GO PIVOT)))
       (SETQ AA (REVPR (NTH (NTH U K2) K2)))
    PIVOT
       (SETQ AA1 (NTH (NTH U K1) K1))
       (COND ((NULL (EQUAL AA1 (CONS NIL 1))) (GO L2)))
       (SETQ I K)
    L    (COND ((GREATERP I M) (GO SING))
             ((EQUAL (NTH (NTH U I) K1) (CONS NIL 1)) (GO L1)))
       (SETQ J K1)
    L0   (COND ((GREATERP J N) (GO PL2)))
       (SETQ TEMP (NTH (NTH U I) J))
       (SETMATELEM U I J (NEGSQ (NTH (NTH U K1) J)))
       (SETMATELEM U K1 J TEMP)
       (SETQ J (ADD1 J))
       (GO L0)
    L1   (SETQ I (ADD1 I))
       (GO L)
    PL2  (SETQ AA1 (NTH (NTH U K1) K1))
    L2   (SETQ I K)
    L2A  (COND ((GREATERP I M) (GO SING)))
       (SETQ BB
             (ADDSQ (MULTSQ AA1 (NTH (NTH U I) K))
                  (NEGSQ
                   (MULTSQ (NTH (NTH U K1) K)
                         (NTH (NTH U I) K1)))))
       (COND ((EQUAL BB (CONS NIL 1)) (GO L2B)))
       (GO L3)
    L2B  (SETQ I (ADD1 I))
       (GO L2A)
    L3   (SETQ C0 (MULTSQ BB AA))
       (COND ((EQUAL K M) (GO EV)) ((EQUAL I K) (GO COMP)))
       (SETQ J K1)
    L3A  (COND ((GREATERP J N) (GO COMP)))
       (SETQ TEMP (NTH (NTH U I) J))
       (SETMATELEM U I J (NEGSQ (NTH (NTH U K) J)))
       (SETMATELEM U K J TEMP)
       (SETQ J (ADD1 J))
       (GO L3A)
    COMP (SETQ I (ADD1 K))
       (SETQ AAK (NTH (NTH U K) K))
    COMP1
       (COND ((GREATERP I M) (GO EV)))
       (SETQ CI1
             (MULTSQ (ADDSQ (MULTSQ (NTH (NTH U K1) K)
                              (NTH (NTH U I) K1))
                        (NEGSQ (MULTSQ AA1 (NTH (NTH U I) K))))
                    AA))
       (SETQ CI2
             (MULTSQ (ADDSQ (MULTSQ (NTH (NTH U K) K1)
                              (NTH (NTH U I) K))
                        (NEGSQ
                         (MULTSQ AAK (NTH (NTH U I) K1))))
                    AA))
       (SETQ J (ADD1 K))
    COMP2
       (COND ((GREATERP J N) (GO COMP3)))
       (SETMATELEM U
                  I
                  J
                 (MULTSQ
                  (ADDSQ (MULTSQ (NTH (NTH U I) J) C0)
                       (ADDSQ
                        (MULTSQ (NTH (NTH U K) J) CI1)
                        (MULTSQ (NTH (NTH U K1) J) CI2)))
                  AA))
       (SETQ J (ADD1 J))
       (GO COMP2)
    COMP3
       (SETQ I (ADD1 I))
       (GO COMP1)
    EV   (SETMATELEM U K K C0)
       (SETQ J (ADD1 K))
    EV1  (COND ((GREATERP J N) (GO BOT)))
       (SETMATELEM U
                  K
                  J
                 (MULTSQ (ADDSQ (MULTSQ AA1 (NTH (NTH U K) J))
                            (NEGSQ
                             (MULTSQ
                              (NTH (NTH U K) K1)
                              (NTH (NTH U K1) J))))
                        AA))
       (SETQ J (ADD1 J))
       (GO EV1)
    BOT  (SETQ K (ADD1 (ADD1 K)))
       (GO BEG)
    FB   (COND ((EQUAL (NTH (NTH U M) M) (CONS NIL 1)) (GO SING)))
       (RETURN U)
    SING (COND
        ((NULL V)
         (RETURN (PROG2 (SETMATELEM U N N (CONS NIL 1)) U))))
       (REDERR (QUOTE (SINGULAR MATRIX))))))
))
DEFINE ((
(BACKSUB (LAMBDA (U M N)
   (PROG (DET IJ I J JJ SUM)
       (SETQ DET (NTH (NTH U M) M))
       (SETQ J (ADD1 M))
    ROWM (COND ((GREATERP J N) (GO ROWS)))
       (SETMATELEM U
                  M
                  J
                 (CANCEL (MULTSQ (NTH (NTH U M) J) (REVPR DET))))
       (SETQ J (ADD1 J))
       (GO ROWM)
    ROWS (SETQ IJ 1)
    ROWS1
       (COND ((GREATERP IJ (SUB1 M)) (GO DONE)))
       (SETQ I (DIFFERENCE M IJ))
       (SETQ JJ (ADD1 M))
    ROWS2
       (COND ((GREATERP JJ N) (GO ROWS5)))
       (SETQ J (ADD1 I))
       (SETQ DET (NTH (NTH U I) I))
       (SETQ SUM (CONS NIL 1))
    ROWS3
       (COND ((GREATERP J M) (GO ROWS4)))
       (SETQ SUM
             (ADDSQ SUM
          (CANCEL (MULTSQ (NTH (NTH U I) J) (NTH (NTH U J) JJ)))))
       (SETQ J (ADD1 J))
       (GO ROWS3)
    ROWS4
       (SETMATELEM U
                  I
                  JJ
                 (CANCEL
                  (MULTSQ (ADDSQ (NTH (NTH U I) JJ) (NEGSQ SUM))
                        (REVPR DET))))
       (SETQ JJ (ADD1 JJ))
       (GO ROWS2)
    ROWS5
       (SETQ IJ (ADD1 IJ))
       (GO ROWS1)
    DONE (RETURN U))))
))
DEFINE ((
(RHSIDE (LAMBDA (U M)
   (COND ((NULL U) NIL)
       (T (CONS (RHSIDE1 (CAR U) M) (RHSIDE (CDR U) M))))))
))
DEFINE ((
(RHSIDE1 (LAMBDA (U M)
   (PROG NIL
    A    (COND ((EQUAL M 0) (RETURN U)))
       (SETQ U (CDR U))
       (SETQ M (SUB1 M))
       (GO A))))
))
DEFINE ((
(GENERATEIDENT (LAMBDA (N)
   (PROG (I K U V)
       (SETQ I 1)
       (SETQ V NIL)
    E    (COND ((GREATERP I N) (GO A)))
       (SETQ U NIL)
       (SETQ K 1)
    C    (COND ((GREATERP K N) (GO D)) ((EQUAL K I) (GO B)))
       (SETQ U (CONS (CONS NIL 1) U))
       (SETQ K (ADD1 K))
       (GO C)
    B    (SETQ U (CONS (CONS 1 1) U))
       (SETQ K (ADD1 K))
       (GO C)
    D    (SETQ I (ADD1 I))
       (SETQ V (CONS U V))
       (GO E)
    A    (RETURN V))))
(*MATINV (LAMBDA (U V)
   (PROG (A B M N X)
       (SETQ A U)
      (SETQ X SUBFG*)
      (SETQ SUBFG* NIL)
       (SETQ M (LENGTH A))
       (SETQ N (LENGTH (CAR A)))
       (COND
        ((NOT (EQUAL M N)) (REDERR (QUOTE (NON SQUARE MATRIX)))))
       (SETQ B (COND (V V) (T (GENERATEIDENT M))))
       (COND
        ((AND V (NOT (EQUAL M (LENGTH B))))
         (REDERR (QUOTE (EQUATION MISMATCH)))))
       (SETQ A (AUGMENT A B))
       (SETQ N (LENGTH (CAR A)))
       (SETQ A (LIPSON A M N T))
       (SETQ A (BACKSUB A M N))
      (SETQ SUBFG* X)
         (RETURN (MAPC2 (RHSIDE A M) (FUNCTION
                         (LAMBDA (J) (SIMP (PREPSQ J)))))))))
))
DEFINE ((
(SIMPDET (LAMBDA (U)
   (SIMPDET1 U T)))
(SIMPTRACE (LAMBDA (U)
   (SIMPDET1 U NIL)))
(SIMPDET1 (LAMBDA (U V)
   (PROG (N)
       (COND
        ((AND (NOT (EQCAR (CAR U) (QUOTE *COMMA*)))
            (NOT (MATEXPR (CAR U))))
         (REDERR (QUOTE (MATRIX EXPRESSION REQUIRED)))))
       (SETQ U
             (COND
            ((EQCAR (CAR U) (QUOTE *COMMA*))
             (MAPCAR U
                   (FUNCTION
                    (LAMBDA(J)
                     (MAPCAR
                      (COND
                       ((EQCAR J (QUOTE *COMMA*)) (CDR J))
                       (T J))
                      (FUNCTION SIMP))))))
            (T (MATSIMP (MSIMP (CARX U) T)))))
       (COND
        ((NOT (EQUAL (LENGTH U) (LENGTH (CAR U))))
         (REDERR (QUOTE (NON SQUARE MATRIX)))))
       (COND (V (RETURN (DETQ U))))
       (SETQ N 1)
       (SETQ V (CONS NIL 1))
    A    (COND ((NULL U) (RETURN V)))
       (SETQ V (ADDSQ (NTH (CAR U) N) V))
       (SETQ U (CDR U))
       (SETQ N (ADD1 N))
       (GO A))))
(SIMPDET* (LAMBDA (U)
   (MAPC2 U (FUNCTION SIMP))))
(SIMPMAT (LAMBDA (U)
   (REDERR (QUOTE (MATRIX MISMATCH)))))
))
DEFLIST (((DET SIMPDET) (TRACE SIMPTRACE) (MAT SIMPMAT)) SIMPFN)
DEFINE ((
(DETQ (LAMBDA (U)
   (PROG (V X)
      (SETQ X SUBFG*)
      (SETQ SUBFG* NIL)
      (SETQ V (LENGTH U))
      (SETQ V (NTH (NTH (LIPSON U V V NIL) V) V))
      (SETQ SUBFG* X)
         (RETURN (SIMP (PREPSQ V))))))
))
DEFLIST (((CONS SIMPDOT)) SIMPFN)
FLAG ((CONS) VOP)
DEFINE ((
(VOP (LAMBDA (U)
   (FLAG U (QUOTE VOP))))
(VECTORP (LAMBDA (U)
   (AND (ATOM U)
      (NOT (NUMBERP U))
      (OR (FLAGP U (QUOTE MASS))
          (FLAGP U (QUOTE VECTOR))
          (MEMBER U INDICES*)))))
(ISIMPQ (LAMBDA (U)
   (CONS (ISIMP (CAR U)) (CDR U))))
(ISIMP (LAMBDA (U)
   (COND
      ((OR (NULL SUBFG*)
      (AND (NULL INDICES*)
        (NULL GAMIDEN*)
          (NULL (GET (QUOTE EPS) (QUOTE KLIST)))))
     U)
    (T (ISIMP1 U INDICES* NIL NIL NIL)))))
(ISIMP1 (LAMBDA (U I V W X)
   (COND
    ((ATOM U)
     (COND
      ((OR V X) (REDERR (APPEND (QUOTE (UNMATCHED INDEX ERROR)) I)))
      (W (MULTF (EMULT W) (ISIMP1 U I V NIL X)))
      (T U)))
    (T
     (ADDF (ISIMP2 (CAR U) I V W X)
         (COND ((NULL (CDR U)) NIL)
             (T (ISIMP1 (CDR U) I V W X))))))))
(ISIMP2 (LAMBDA (U I V W X)
   (PROG (Z)
       (COND ((ATOM (SETQ Z (CAAR U))) (GO A))
             ((AND (EQ (CAR Z) (QUOTE CONS)) (XN (CDR Z) I))
            (RETURN (DOTSUM U I V W X)))
             ((EQ (CAR Z) (QUOTE G)) (RETURN (SPUR0 U I V W X)))
             ((EQ (CAR Z) (QUOTE EPS)) (RETURN (ESUM U I V W X))))
    A    (RETURN (MULTF2 (CAR U) (ISIMP1 (CDR U) I V W X))))))
(DOTSUM (LAMBDA (U I V W X)
   (PROG (I1 N U1 U2 V1 Y Z)
       (SETQ N (CDAR U))
       (COND
        ((NOT (MEMBER (CAR (SETQ U1 (CDAAR U))) I))
         (SETQ U1 (REVERSE U1))))
       (SETQ U2 (CADR U1))
       (SETQ U1 (CAR U1))
       (SETQ V1 (CDR U))
       (COND ((EQUAL N 2) (GO H)) ((NOT (ONEP N)) (REDERR U)))
    A    (COND
        ((NOT (MEMBER U1 I))
         (RETURN (MULTF (MKDOT U1 U2) (ISIMP1 V1 I1 V W X)))))
    A1   (SETQ I1 (DELETE U1 I))
       (COND ((EQ U1 U2) (RETURN (MULTN 4 (ISIMP1 V1 I1 V W X))))
             ((NOT (SETQ Z (ASSOC U1 V))) (GO C))
             ((MEMBER U2 I) (GO D)))
       (SETQ U1 (CDR Z))
       (GO E)
    C    (COND
        ((SETQ Z (MEMLIS U1 X))
         (RETURN
          (SPUR0 (CONS (CONS (CONS (QUOTE G) (SUBST U2 U1 Z)) 1)
                    V1)
                I1
                V
                W
               (DELETE Z X))))
        ((SETQ Z (MEMLIS U1 W))
         (RETURN
          (ESUM (CONS (CONS (CONS (QUOTE EPS) (SUBST U2 U1 Z)) 1)
                   V1)
               I1
               V
              (DELETE Z W)
               X)))
        ((AND (MEMBER U2 I) (NULL Y)) (GO G)))
       (RETURN (ISIMP1 V1 I (CONS (CONS U1 U2) V) W X))
    D    (SETQ U1 U2)
       (SETQ U2 (CDR Z))
    E    (SETQ I I1)
       (SETQ V (DELETE Z V))
       (GO A)
    G    (SETQ Y T)
       (SETQ Z U1)
       (SETQ U1 U2)
       (SETQ U2 Z)
       (GO A1)
    H    (COND ((EQ U1 U2) (REDERR U)))
       (SETQ I (DELETE U1 I))
       (SETQ U1 U2)
       (GO A))))
))
DEFINE ((
(VMULT (LAMBDA (U)
   (PROG (Z)
       (SETQ U
             (REVERSE
            (MAPCAR U (FUNCTION (LAMBDA (J) (MSIMP J NIL))))))
    A    (COND ((NULL U) (RETURN Z))
             ((NULL Z) (SETQ Z (CAR U)))
             (T (SETQ Z (VMULT1 (CAR U) Z))))
       (SETQ U (CDR U))
       (GO A))))
(VMULT1 (LAMBDA (U *S1*)
   (COND ((NULL *S1*) NIL)
       (T
        (MAPCON U
              (FUNCTION
               (LAMBDA(*S*)
                (MAPCAR *S1*
                      (FUNCTION
                       (LAMBDA(J)
                        (CONS (MULTSQ (CAAR *S*) (CAR J))
                            (APPEND (CDAR *S*)
                                  (CDR J)))))))))))))
))
DEFINE ((
(SIMPDOT (LAMBDA (U)
   (COND ((CDDR U) (ERRACH (LIST (QUOTE SIMPDOT) U)))
       (T
        (MKVARG U
              (FUNCTION
               (LAMBDA(J)
                (MKSQ (CONS (QUOTE CONS) (ORD2 (CAR J) (CADR J)))
                     1))))))))
(MKVARG (LAMBDA (U *PI*)
   (PROG (Z)
       (SETQ U (VMULT U))
       (SETQ Z (CONS NIL 1))
    A    (COND ((NULL U) (RETURN Z)))
       (SETQ Z (ADDSQ (MULTSQ (*PI* (CDAR U)) (CAAR U)) Z))
       (SETQ U (CDR U))
       (GO A))))
(MKDOT (LAMBDA (U V)
   (MKSF (CONS (QUOTE CONS) (ORD2 U V)) 1)))
(VLET (LAMBDA (U V B)
  (PROG2
         (AND B (FLAGP U (QUOTE USED*)) (RMSUBS2))
         (SETQ VREP* (XADD (CONS U V)  VREP* U B)))))
))
DEFINE ((
(INDEX (LAMBDA (U)
   (SETQ INDICES* (UNION INDICES* U))))
(REMIND (LAMBDA (U)
   (PROG2 (VECTOR U) (SETQ INDICES* (SETDIFF INDICES* U)))))
(MASS (LAMBDA (U)
   (COND ((NULL U) NIL)
       (T
        (PROG2 (PUT (CADAR U) (QUOTE MASS) (CADDAR U))
             (MASS (CDR U)))))))
(MSHELL (LAMBDA (U)
   (PROG (X Z)
    A    (COND ((NULL U) (RETURN (LET Z))))
       (SETQ X (GETMAS (CAR U)))
       (SETQ Z
             (CONS (LIST (QUOTE EQUAL)
                     (LIST (QUOTE CONS) (CAR U) (CAR U))
                     (LIST (QUOTE TIMES) X X))
                  Z))
       (SETQ U (CDR U))
       (GO A))))
(GETMAS (LAMBDA (U)
   ((LAMBDA(X)
     (COND (X X) (T (REDERR (CONS U (QUOTE (HAS NO MASS)))))))
    (GET* U (QUOTE MASS)))))
(VECTOR (LAMBDA (U)
   (FLAG U (QUOTE VECTOR))))
))
DEFINE ((
(VCREP (LAMBDA (U)
   ((LAMBDA(X)
     (COND
      ((AND SUBFG* (NOT (EQUAL X (CAR U))))
       (NCONC U (LIST (LIST (QUOTE REP) X 1 NIL NIL))))
      (T NIL)))
    (SUBLIS VREP* (CAR U)))))
))
DEFLIST (((MSHELL RLIS) (MASS RLIS) (INDEX RLIS) (REMIND RLIS) (VECTOR
 RLIS) (VOP RLIS)) STAT)
FLAG ((EPS) VOP)
DEFLIST (((G SIMPGAMMA) (EPS SIMPEPS)) SIMPFN)
FLAG ((G) NONCOM)
DEFLIST (((G GMULT)) MRULE)
DEFINE ((
(GMULT (LAMBDA (U V)
   (COND
    ((OR (NOT (EQUAL (CDR U) 1)) (NOT (EQUAL (CDR V) 1)))
     (ERRACH (LIST (QUOTE GMULT) U V)))
    ((NOT (EQ (CADAR U) (CADAR V))) (QUOTE FAILED))
    (T (GCHECK (REVERSE (CDDAR U)) (CDDAR V) (CADAR U))))))
(NONCOM (LAMBDA (U)
   (FLAG U (QUOTE NONCOM))))
))
DEFINE ((
(SPUR (LAMBDA (U)
   (PROG2 (RMSUBS)
        (MAP U
             (FUNCTION
            (LAMBDA(J)
                 (PROG2 (REMFLAG (LIST (CAR J)) (QUOTE NOSPUR))
                        (REMFLAG (LIST (CAR J)) (QUOTE REDUCE)))))))))
(NOSPUR (LAMBDA (U)
   (FLAG U (QUOTE NOSPUR))))
(REDUCE (LAMBDA (U)
   (PROG2 (NOSPUR U) (FLAG U (QUOTE REDUCE)))))
(SIMPGAMMA (LAMBDA (*S*)
   (COND
    ((OR (NULL *S*) (NULL (CDR *S*)))
     (REDERR (QUOTE (MISSING ARGUMENTS FOR G OPERATOR))))
    (T
     (PROG NIL
         (SETQ GAMIDEN* (UNION (LIST (CAR *S*)) GAMIDEN*))
         (SETQ *NCMP T)
         (RETURN
          (MKVARG (CDR *S*)
                (FUNCTION
                 (LAMBDA(J)
                  (CONS (GCHECK (REVERSE J) NIL (CAR *S*))
                       1))))))))))
(GCHECK (LAMBDA (U V L)
   (COND ((EQ (CAR V) (QUOTE A)) (GCHKA U (CDR V) T L))
       (T (GCHKV U V T L)))))
(GCHKA (LAMBDA (U V X W)
   (COND ((NULL U) (MULTN (NB X) (MKG (CONS (QUOTE A) V) W)))
       ((EQ (CAR U) (QUOTE A)) (GCHKV (CDR U) V X W))
       (T (GCHKA (CDR U) (CONS (CAR U) V) (NOT X) W)))))
(GCHKV (LAMBDA (U V X L)
   (COND ((NULL U)
        (COND ((NULL V) (NB X)) (T (MULTN (NB X) (MKG V L)))))
       ((EQ (CAR U) (QUOTE A)) (GCHKA (CDR U) V X L))
       (T (GCHKV (CDR U) (CONS (CAR U) V) X L)))))
(MKG (LAMBDA (U L)
   (LIST (CONS (CONS (CONS (QUOTE G) (CONS L U)) 1) 1))))
(MKA (LAMBDA (L)
   (MKG (LIST (QUOTE A)) L)))
(MKG1 (LAMBDA (U L)
   (COND
    ((OR (NOT (FLAGP L (QUOTE NOSPUR)))
       (NULL (CDR U))
       (CDDR U)
       (ORDOP (CAR U) (CADR U))
       (EQ (CAR U) (QUOTE A)))
     (MKG U L))
    (T
     (ADDF (MULTN 2 (MKDOT (CAR U) (CADR U)))
         (MULTN -1 (MKG (REVERSE U) L)))))))
(NB (LAMBDA (U)
   (COND (U 1) (T -1))))
))
DEFINE ((
(SPUR0 (LAMBDA (U I V1 V2 V3)
   (PROG (L V W I1 Z KAHP)
       (SETQ L (CADAAR U))
       (SETQ V (CDDAAR U))
       (COND ((NOT (ONEP (CDAR U))) (SETQ V (APPN V (CDAR U)))))
       (SETQ U (CDR U))
       (COND
         ((AND (NOT (FLAGP L (QUOTE NOSPUR))) 
            (OR (AND (EQ (CAR V) (QUOTE A))
                   (OR (LESSP (LENGTH V) 5)
                       (NOT (EVENP (CDR V)))))
                (AND (NOT (EQ (CAR V) (QUOTE A)))
                   (NOT (EVENP V)))))
         (RETURN NIL))
        ((NULL I) (GO END)))
    A    (COND ((NULL V) (GO END1)) ((MEMBER (CAR V) I) (GO B)))
    A1   (SETQ W (CONS (CAR V) W))
       (SETQ V (CDR V))
       (GO A)
    B    (COND ((MEMBER (CAR V) (CDR V)) (GO KAH1))
             ((MEMBER (CAR V) I1) (GO A1))
             ((SETQ Z (BASSOC (CAR V) V1)) (GO E))
             ((SETQ Z (MEMLIS (CAR V) V2))
            (RETURN
             ((LAMBDA(X)
               (COND
                ((AND (FLAGP L (QUOTE REDUCE))
                    (NULL V1)
                    (NULL V3)
                    (NULL (CDR V2)))
                 (MULTF (MKG* X L) (MULTF (MKEPS1 Z) (ISIMP U))))
                (T
                 (ISIMP1
                  (SPUR0 (CONS (CAAR (MKG X L)) U)
                        NIL
                        V1
                       (DELETE Z V2)
                        V3)
                  I
                  NIL
                  (LIST Z)
                  NIL))))
              (APPEND (REVERSE W) V))))
             ((SETQ Z (MEMLIS (CAR V) V3)) (GO C))
             (T
            (RETURN
             (ISIMP1 U
                    I
                    V1
                    V2
                   (CONS (CONS L (APPEND (REVERSE W) V))
                          V3)))))
    C    (SETQ V3 (DELETE Z V3))
       (SETQ KAHP NIL)
       (COND
        ((AND (FLAGP L (QUOTE NOSPUR))
            (FLAGP (CAR Z) (QUOTE NOSPUR)))
         (ERROR (QUOTE HELP)))
        ((FLAGP (CAR Z) (QUOTE NOSPUR)) (SETQ KAHP (CAR Z))))
       (SETQ Z (CDR Z))
       (SETQ I1 NIL)
    C1   (COND ((EQ (CAR V) (CAR Z)) (GO D)))
       (SETQ I1 (CONS (CAR Z) I1))
       (SETQ Z (CDR Z))
       (GO C1)
    D    (SETQ Z (CDR Z))
       (SETQ I (DELETE (CAR V) I))
       (SETQ V (CDR V))
       (COND ((NOT (FLAGP L (QUOTE NOSPUR))) (GO D0)))
       (SETQ W (CONS W (CONS V (CONS I1 Z))))
       (SETQ I1 (CAR W))
       (SETQ Z (CADR W))
       (SETQ V (CADDR W))
       (SETQ W (CDDDR W))
    D0   (SETQ W (REVERSE W))
       (COND
        ((AND (OR (NULL V) (NOT (EQ (CAR W) (QUOTE A))))
            (SETQ V (APPEND V W)))
         (GO D1))
        ((NOT (EVENP V)) (SETQ U (MULTN -1 U))))
       (SETQ V (CONS (QUOTE A) (APPEND V (CDR W))))
    D1   (COND (KAHP (SETQ L KAHP)))
       (SETQ VARS* NIL)
       (SETQ Z (MULTF (MKG (REVERSE I1) L)
                 (MULTF (BRACE V L I) (MULTF (MKG1 Z L) U))))
       (SETQ Z (ISIMP1 Z (APPEND VARS* I) V1 V2 V3))
       (COND ((NULL Z) (RETURN Z))
             ((NULL (SETQ Z (QUOTF Z 2)))
            (ERRACH (LIST (QUOTE SPUR0) U I V1 V2 V3))))
       (RETURN Z)
    E    (SETQ V1 (DELETE Z V1))
       (SETQ I (DELETE (CAR W) I))
       (SETQ V (CONS (OTHER (CAR V) Z) (CDR V)))
       (GO A)
    KAH1 (COND ((EQ (CAR V) (CADR V)) (GO K2)))
       (SETQ KAHP T)
       (SETQ I1 (CONS (CAR V) I1))
       (GO A1)
    K2   (SETQ I (DELETE (CAR V) I))
       (SETQ V (CDDR V))
       (SETQ U (MULTN 4 U))
       (GO A)
    END  (SETQ W (REVERSE V))
  END1 (COND (KAHP (GO END2))
             ((NULL (SETQ Z (SPURR W L NIL 1))) (RETURN NIL))
          (T (RETURN (COND ((AND (GET (QUOTE EPS) (QUOTE KLIST))
                                  (NOT (FLAGP L (QUOTE NOSPUR))))
                             (ISIMP1 (MULTF Z U) I V1 V2 V3))
                         (T (MULTF Z (ISIMP1 U I V1 V2 V3)))))))
  END2 (SETQ VARS* NIL)
       (SETQ Z (MULTF (KAHANE (REVERSE W) I1 L) U))
       (RETURN (ISIMP1 Z (APPEND VARS* (SETDIFF I I1)) V1 V2 V3)))))
(APPN (LAMBDA (U N)
   (COND ((ONEP N) U) (T (APPEND U (APPN U (SUB1 N)))))))
(OTHER (LAMBDA (U V)
   (COND ((EQ U (CAR V)) (CDR V)) (T (CAR V)))))
))
DEFINE ((
(KAHANE (LAMBDA (U I L)
   (PROG (K2 LD LU M P V W X Y)
       (SETQ K2 0)
       (SETQ M 0)
         (SETQ W (LIST T T NIL))
       (COND ((EQ (CAR U) (QUOTE A)) (GO B)))
    A    (COND
          ((AND (NULL U) (SETQ W (CONS NIL (CONS NIL (CONS NIL W)))))
         (GO KETJAK))
        ((MEMBER (CAR U) I) (GO D)))
       (SETQ P (NOT P))
    B    (SETQ W (CONS (CAR U) W))
    C    (SETQ U (CDR U))
       (GO A)
   D     (SETQ W (CONS (CAR U) (CONS P (CONS NIL W))))
       (SETQ X NIL)
    KETJAK
       (SETQ W (REVERSE W))
    TJARUM
       (COND ((CADR W) (SETQ LU (CONS W LU)))
             (T (SETQ LD (CONS W LD))))
       (COND ((NULL U) (GO DJANGER)) (X (GO MAS)))
       (SETQ W (REVERSE W))
       (SETQ X T)
       (GO TJARUM)
   MAS   (SETQ W (LIST T (SETQ P (NOT P)) (CAR U)))
       (SETQ K2 (ADD1 K2))
       (GO C)
    DJANGER
       (SETQ LU (REVERSE LU))
    BARUNA
       (COND ((NULL LU) (GO JAVA)))
       (SETQ V (CAR LU))
       (SETQ LU (CDR LU))
    WAJANG
         (SETQ X (CONS (CAR V) (CADR V)))
         (SETQ P (NULL (CADDR V)))
       (SETQ M (ADD1 M))
       (SETQ W NIL)
    RINDIK
       (SETQ Y (REVERSE V))
   R1    (COND ((CADR Y) (SETQ LU (DELETE Y LU)))
               (T (SETQ LD (DELETE Y LD))))
         (COND ((EQ Y V) (GO RINDIK))
               (P (AND (SETQ V Y)
                        (SETQ X (CONS (CAR V) (CADR V)))
                        (SETQ P NIL))))
         (SETQ V (CDDDR V))
    BANDJAR
         (COND ((CDDDR V) (GO SUBAK))
               ((NULL (CADDR V)) (GO WADAH))
                ((AND (EQ (CADDR V) (CAR X))
                   (EQ (CADR V) (CDR X))) (GO BARIS)))
         (SETQ V
         (SASSOC (CADDR V)
                 (COND ((CADR V) LU) (T LD))
                   (FUNCTION
                  (LAMBDA NIL (ERRACH (QUOTE KAHANE))))))
         (SETQ Y V)
         (GO R1)
    SUBAK
       (SETQ W (CONS (CAR V) W))
       (SETQ V (CDR V))
       (GO BANDJAR)
    WADAH
         (SETQ U (MKG (REVERSE W) L))
       (GO BARUNA)
    BARIS
       (COND ((AND W (CDR X)) (SETQ W (NCONC (CDR W) (LIST (CAR W))))))
       (SETQ U (MULTF (BRACE W L NIL) U))
       (GO BARUNA)
    JAVA (COND ((NULL LD) (GO HOME)))
       (SETQ V (CAR LD))
       (SETQ LD (CDR LD))
       (GO WAJANG)
    HOME (SETQ K2 (QUOTIENT K2 2))
       (SETQ X (EXPT 2 K2))
       (COND
        ((ZEROP (REMAINDER (DIFFERENCE K2 M) 2))
         (SETQ X (MINUS X))))
       (RETURN (MULTN X U)))))
(BRACE (LAMBDA (U L I)
   (COND ((NULL U) 2)
         ((OR (XN I U) (FLAGP L (QUOTE NOSPUR)))
           (ADDF (MKG1 U L) (MKG1 (REVERSE U) L)))
       ((EQ (CAR U) (QUOTE A))
           (COND ((EVENP U) (ADDF (MKG U L)
                                  (MULTN -1 (MKG (CONS (QUOTE A)
                                           (REVERSE (CDR U))) L))))
            (T (MULTF (MKA L) (SPR2 (CDR U) L 2 NIL)))))
       ((EVENP U) (SPR2 U L 2 NIL))
       (T (SPR1 U L 2 NIL)))))
(SPR1 (LAMBDA (U L N B)
   (COND ((NULL U) NIL)
       ((NULL (CDR U)) (MULTN N (MKG1 U L)))
       (T
        (PROG (M X Z)
            (SETQ X U)
            (SETQ M 0)
          A    (COND ((NULL X) (RETURN Z)))
            (SETQ Z
                  (ADDF (MULTF (MKG1 (LIST (CAR X)) L)
                           (COND
                            ((NULL B)
                                (SPURR (REMOVE U M) L NIL N))
                            (T (SPR1 (REMOVE U M) L N NIL))))
                       Z))
            (SETQ X (CDR X))
            (SETQ N (MINUS N))
            (SETQ M (ADD1 M))
            (GO A))))))
(SPR2 (LAMBDA (U L N B)
   (COND ((AND (NULL (CDDR U)) (NULL B))
        (MULTN N (MKDOT (CAR U) (CADR U))))
       (T
        ((LAMBDA (X) (COND (B (ADDF (SPR1 U L N B) X)) (T X)))
           (ADDF (SPURR U L NIL N)
                 (MULTF (MKA L)
              (SPURR (APPEND U (LIST (QUOTE A))) L NIL N))))))))
(EVENP (LAMBDA (U)
   (OR (NULL U) (NOT (EVENP (CDR U))))))
(BASSOC (LAMBDA (U V)
   (COND ((NULL V) NIL)
       ((OR (EQ U (CAAR V)) (EQ U (CDAR V))) (CAR V))
       (T (BASSOC U (CDR V))))))
(MEMLIS (LAMBDA (U V)
   (COND ((NULL V) NIL)
       ((MEMBER U (CAR V)) (CAR V))
       (T (MEMLIS U (CDR V))))))
))
DEFINE ((
(SPURR (LAMBDA (U L V N)
   (PROG (M W X Y Z)
    A    (COND ((NULL U) (GO B)) ((MEMBER (CAR U) (CDR U)) (GO G)))
       (SETQ V (CONS (CAR U) V))
       (SETQ U (CDR U))
       (GO A)
    B    (COND ((NULL V) (RETURN N))
             ((FLAGP L (QUOTE NOSPUR))
            (RETURN (MULTN N (MKG* V L))))
             (T (RETURN (SPRGEN V N))))
    G    (SETQ X (CAR U))
       (SETQ Y (CDR U))
       (SETQ W Y)
       (SETQ M 0)
    H    (COND
        ((EQ X (CAR W))
         (RETURN
          (ADDF (MULTF (MKDOT X X) (SPURR (DELETE X Y) L V N))
               Z))))
       (SETQ Z
             (ADDF (MULTF (MKDOT X (CAR W))
                      (SPURR (REMOVE Y M) L V (TIMES 2 N)))
                  Z))
       (SETQ W (CDR W))
       (SETQ N (MINUS N))
       (SETQ M (ADD1 M))
       (GO H))))
(SPRGEN (LAMBDA (V N)
   (PROG (X Z)
       (COND
        ((NOT (EQ (CAR V) (QUOTE A))) (RETURN (SPRGEN1 V N)))
        ((NULL (SETQ X (COMB1 (SETQ V (CDR V)) 4 NIL)))
         (RETURN NIL))
        ((NULL (CDR X)) (GO E)))
    C    (COND ((NULL X) (RETURN (MULTF2 (MKSP (QUOTE I) 1) Z))))
       (SETQ Z
              (ADDF (MULTN (ASIGN (CAR X) V N)
                      (MULTF (MKEPS1 (CAR X))
                           (SPRGEN1 (SETDIFF V (CAR X)) 1)))
                  Z))
    D    (SETQ X (CDR X))
       (GO C)
    E    (SETQ Z (MULTN N (MKEPS1 (CAR X))))
       (GO D))))
(ASIGN (LAMBDA (U V N)
  (COND ((NULL U) N)
   (T (ASIGN (CDR U) V (TIMES (ASIGN1 (CAR U) V -1) N))))))
(ASIGN1 (LAMBDA (U V N)
  (COND ((NULL V) (ERROR (QUOTE ARG)))
   ((EQ U (CAR V)) N)
   (T (ASIGN1 U (CDR V) (MINUS N))))))
(SPRGEN1 (LAMBDA (U N)
   (COND ((NULL U) NIL)
       ((NULL (CDDR U)) (MULTN N (MKDOT (CAR U) (CADR U))))
       (T
        (PROG (W X Y Z)
            (SETQ X (CAR U))
            (SETQ U (CDR U))
            (SETQ Y U)
          A    (COND ((NULL U) (RETURN Z))
                  ((NULL (SETQ W (MKDOT X (CAR U)))) (GO B)))
            (SETQ Z
                  (ADDF (MULTF W (SPRGEN1 (DELETE (CAR U) Y) N))
                       Z))
          B    (SETQ N (MINUS N))
            (SETQ U (CDR U))
            (GO A))))))
(COMB1 (LAMBDA (U N V)
   ((LAMBDA(M)
     (COND ((ONEP N)
          (APPEND V (MAPCAR U (FUNCTION (LAMBDA (J) (LIST J))))))
         ((MINUSP M) NIL)
         ((ZEROP M) (CONS U V))
         (T
          (COMB1 (CDR U)
                N
               (APPEND V
                     (MAPCONS (COMB1 (CDR U) (SUB1 N) NIL)
                            (CAR U)))))))
    (DIFFERENCE (LENGTH U) N))))
))
DEFINE ((
(SIMPEPS (LAMBDA (U)
   (MKVARG U
         (FUNCTION
          (LAMBDA(J)
           (CONS (COND ((REPEATS J) NIL) (T (MKEPS1 J))) 1))))))
(MKEPS1 (LAMBDA (U)
   ((LAMBDA(X)
     (MULTN (NB (PERMP X U)) (MKSF (CONS (QUOTE EPS) X) 1)))
    (ORDN U))))
(PERMP (LAMBDA (U V)
   (COND ((NULL U) T)
       ((EQ (CAR U) (CAR V)) (PERMP (CDR U) (CDR V)))
       (T (NOT (PERMP (CDR U) (SUBST (CAR V) (CAR U) (CDR V))))))))
))
DEFINE ((
(ESUM (LAMBDA (U I V W XX)
   (PROG (X Y Z)
       (SETQ X (CAR U))
       (SETQ U (CDR U))
       (COND
        ((NOT (ONEP (CDR X)))
         (SETQ U
             (MULTF (NMULTF (MKEPS1 (CDAR X)) (SUB1 (CDR X)))
                   U))))
       (SETQ X (CDAR X))
    A    (COND ((REPEATS X) (RETURN NIL)))
    B    (COND ((NULL X)
            (RETURN (ISIMP1 U I V (CONS (REVERSE Y) W) XX)))
             ((NOT (MEMBER (CAR X) I)) (GO D))
             ((NOT (SETQ Z (BASSOC (CAR X) V))) (GO C)))
       (SETQ V (DELETE Z V))
       (SETQ I (DELETE (CAR X) I))
       (SETQ X
             (APPEND (REVERSE Y) (CONS (OTHER (CAR X) Z) (CDR X))))
       (SETQ Y NIL)
       (GO A)
    C    (COND ((SETQ Z (MEMLIS (CAR X) W)) (GO C1))
             ((SETQ Z (MEMLIS (CAR X) XX))
            (RETURN
             (SPUR0 (CONS (CONS (CONS (QUOTE G) Z) 1) U)
                   I
                   V
                  (CONS (APPEND (REVERSE Y) X) W)
                  (DELETE Z XX)))))
       (RETURN (ISIMP1 U I V (CONS (APPEND (REVERSE Y) X) W) XX))
    C1   (SETQ X (APPEND (REVERSE Y) X))
       (SETQ Y (XN I (XN X Z)))
       (RETURN
        (ISIMP1 (MULTF (EMULT1 Z X Y) U)
              (SETDIFF I Y)
               V
              (DELETE Z W)
               XX))
    D    (SETQ Y (CONS (CAR X) Y))
       (SETQ X (CDR X))
       (GO B))))
(EMULT (LAMBDA (U)
   (COND ((NULL (CDR U)) (MKEPS1 (CAR U) 1))
       ((NULL (CDDR U)) (EMULT1 (CAR U) (CADR U) NIL))
       (T (MULTF (EMULT1 (CAR U) (CADR U) NIL) (EMULT (CDDR U)))))))
(EMULT1 (LAMBDA (U V I)
   ((LAMBDA(X *S*)
     ((LAMBDA(M N)
       (COND ((EQUAL M 4) (TIMES 6 (TIMES 4 N)))
           ((EQUAL M 3)
            (MULTN (TIMES 6 N) (MKDOT (CAR X) (CAR *S*))))
           (T
            (MULTN (TIMES N (COND ((ZEROP M) 1) (T M)))
                 (CAR
                  (DETQ
                   (MAPLIST X
                        (FUNCTION
                         (LAMBDA(*S1*)
                          (MAPLIST *S*
                                 (FUNCTION
                                  (LAMBDA
                                   (J)
                                   (CONS
                                    (MKDOT
                                     (CAR *S1*)
                                     (CAR J))
                                    1)))))))))))))
      (LENGTH I)
 ((LAMBDA (J) (NB(COND((PERMP U (APPEND I X)) (NOT J)) (T J))))
       (PERMP V (APPEND I *S*)))))
    (SETDIFF U I)
    (SETDIFF V I))))
))
DEFLIST (((NONCOM RLIS) (SPUR RLIS) (NOSPUR RLIS) (REDUCE RLIS)) STAT)
DEFINE ((
(MKG* (LAMBDA (U L)
   (COND ((NULL U) 1)
       ((NOT (FLAGP L (QUOTE REDUCE))) (MKG1 U L))
       ((LESSP (LENGTH U) 3) (MKG1 U L))
       ((AND (EQCAR U (QUOTE A)) (EQUAL (LENGTH U) 3))
        ((LAMBDA(Y)
          (PROG2 (SETQ INDICES* (APPEND Y INDICES*))
               (ADDF (MULTF (MKA L) (MKDOT (CADR U) (CADDR U)))
                   (MULTF2 (MKSP (QUOTE I) 1)
                         (MULTF (MKG1 Y L)
                              (MKEPS1
                               (APPEND (CDR U) Y)))))))
         (LIST (GENSYM) (GENSYM))))
       (T (RED* U L)))))
(RED* (LAMBDA (U L)
   (PROG (I X)
       (SETQ X (ACONC (EXPLODE L) (QUOTE I)))
       (SETQ I
             (LIST (COMPRESS (APPEND X (QUOTE (1))))
                 (COMPRESS (APPEND X (QUOTE (2))))))
       (SETQ X (LIST (QUOTE A) (CAR I)))
       (RETURN
        (ADDF (SPURR NIL (QUOTE ***) U 3)
            (ADDF (MULTF (MKG (QUOTE (A)) L)
                       (ISIMP1
                        (GCHECK (QUOTE (A)) U (QUOTE ***))
                        NIL
                        NIL
                        NIL
                        NIL))
                  (ADDF
                   (ISIMP1*
                  (ISIMP1 (GCHECK (LIST (CAR I)) U (QUOTE ***))
                         NIL
                         NIL
                         NIL
                         NIL)
                  (LIST (CAR I))
                  (LIST (LIST L (CAR I))))
                   (ADDF (MULTN -1
                            (ISIMP1*
                             (ISIMP1
                              (GCHECK
                               (REVERSE X)
                               U
                               (QUOTE ***))
                              NIL
                              NIL
                              NIL
                              NIL)
                             (CDR X)
                             (LIST (CONS L X))))
                       (MULTF (MKSQP (CONS -1 2))
                            (ISIMP1*
                             (ISIMP1
                              (GCHECK
                               (REVERSE I)
                               U
                               (QUOTE ***))
                              NIL
                              NIL
                              NIL
                              NIL)
                             I
                             (LIST (CONS L I))))))))))))
(ISIMP1* (LAMBDA (U I V)
   (COND ((NULL U) NIL) (T (ISIMP1 U I NIL NIL V)))))
))
INIT NIL
COMMENT ((E N D    O F    R E D U C E    P R O G R A M))