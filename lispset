|0123456789= +abcdefghi.)-jklmnopqr$* /stuvwxyz,(| ()

attrib (DEF1 (expr (LAMBDA (OB l)
  (prog nil
        (rplaca (prop ob pro (function (lambda nil
                                         (cddr (rplacd ob (cons pro (cons nil (cdr ob))))))))
                l)
        (return ob) ))))

attrib (DEFlist (expr (LAMBDA (L PRO) 
      (maplist l (function (lambda (j)
               (def1 (caar j) (cadar j))))) )))

attrib (DEFine (expr (LAMBDA (J) (DEFlist J (QUOTE EXPR)))))

DEFINE ((
   (MEMBER (LAMBDA (U V) (COND ((NULL V) NIL) 
        ((EQUAL (CAR V) U) T)
     (T (MEMBER U (CDR V)))        )))
   (FLAG (LAMBDA (L FL)
          (PROG (X)
            LOOP (COND ((NULL L) (RETURN NIL)))
                 (SETQ X (CAR L))
                 (SETQ L (CDR L))
                 (COND
                    ((NOT (MEMBER FL (CDR X)))
                      (RPLACD X (CONS FL (CONS NIL (CDR X))))))
                 (GO LOOP))))          
    (REMFLAG (LAMBDA (L FL) (PROG NIL
      LOOP (COND 
              ((NULL L) (RETURN NIL)))
           (REMPROP (CAR L) FL)
           (SETQ L (CDR L))
           (GO LOOP))))
   (TRACE (LAMBDA (L) (FLAG L (QUOTE TRACE))))
   (UNTRACE (LAMBDA (L) (REMFLAG L (QUOTE TRACE))))
   (OPDEFINE1 (LAMBDA (OP VAL) (Prog (x)
        (remprop op (quote sym))
        (attrib op (cons (quote sym) (cons (cdr val) nil)))
        (return op))
   ))
   (OPDEFINEX (LAMBDA (OP VAL) (Prog (x)
        (remprop op (quote sym))
        (setq x (cdr op))
        (rplacd op (cons (quote sym) nil))
        (rplacd (cddr op) val)
        (rplacd val x)
        (return op))
   ))
   (OPDEFINE (LAMBDA (L) 
       (maplist l (function (lambda (j)
             (opdefine1 (caar j) (cadar j)))))))
   (PROG2 (LAMBDA (X Y) Y))
   (PRINTP1 (LAMBDA (L) 
        (COND ((NULL L) NIL) 
              (T (PROG2 
                   (PRINT (CAR L)) 
                 (SEARCH (QUOTE (FLOAT SUBR FSUBR PNAME APVAL FIX))
                     (FUNCTION (LAMBDA (J) (EQUAL ( CAR J) (CAR L))))
                     (FUNCTION (LAMBDA (J) (PRINTP1 (CDR (CDR L)))))
                     (FUNCTION (LAMBDA (J) (PRINTP1 (CDR L))))
                   )
                 )
                )
         )
    ))                                     
(PRINTPROP (LAMBDA (C) (PROG2 (PRINT (LIST (QUOTE PROPERTIES) (QUOTE OF)
 C)) (PRINTP1 (CDR C)))))                                               
  (CSET (LAMBDA (SYM VAL)
          (PROG (TOSTORE)
            (REMPROP SYM (QUOTE APVAL))
            (SETQ TOSTORE (LIST VAL))
            (ATTRIB SYM (LIST (QUOTE APVAL) TOSTORE))
            (RETURN TOSTORE))))
  (EFFACE (LAMBDA (X L) 
             (COND
               ((NULL L) NIL) 
               ((EQUAL X (CAR L)) (CDR L))
               (T RPLACD(L (EFFACE(X CDR L)))))))
(LENGTH(LAMBDA (M) (PROG (N) (SETQ N 0)
A (COND ((NULL M) (RETURN N)) ) (SETQ N (ADD1 N)) (SETQ M (CDR M))
(GO A) )))
(REVERSE (LAMBDA (X) (PROG (Y) A (COND ((NULL X) (RETURN Y))) (SETQ Y (C
ONS (CAR X) Y)) (SETQ X (CDR X)) (GO A))))                              
  (CAAAAR (LAMBDA (X) (CAR (CAR (CAR (CAR X))))))
  (CAAADR (LAMBDA (X) (CAR (CAR (CAR (CDR X))))))
  (CAADAR (LAMBDA (X) (CAR (CAR (CDR (CAR X))))))
  (CAADDR (LAMBDA (X) (CAR (CAR (CDR (CDR X))))))
  (CADAAR (LAMBDA (X) (CAR (CDR (CAR (CAR X))))))
  (CADADR (LAMBDA (X) (CAR (CDR (CAR (CDR X))))))
  (CADDAR (LAMBDA (X) (CAR (CDR (CDR (CAR X))))))
  (CADDDR (LAMBDA (X) (CAR (CDR (CDR (CDR X))))))
  (CDAAAR (LAMBDA (X) (CDR (CAR (CAR (CAR X))))))
  (CDAADR (LAMBDA (X) (CDR (CAR (CAR (CDR X))))))
  (CDADAR (LAMBDA (X) (CDR (CAR (CDR (CAR X))))))
  (CDADDR (LAMBDA (X) (CDR (CAR (CDR (CDR X))))))
  (CDDAAR (LAMBDA (X) (CDR (CDR (CAR (CAR X))))))
  (CDDADR (LAMBDA (X) (CDR (CDR (CAR (CDR X))))))
  (CDDDAR (LAMBDA (X) (CDR (CDR (CDR (CAR X))))))
  (CDDDDR (LAMBDA (X) (CDR (CDR (CDR (CDR X))))))
(PUNCHLAP (LAMBDA NIL (PROG (X L N EXP)
A    (SETQ X (READ))
     (PUNCH BLANK)
     (COND ((NULL X) (RETURN (PUNCH NIL))))
     (SETQ L (LENGTH (CADADR X)))
     (SETQ N (CAR X))
     (SETQ EXP (CADR X))
     (SETQ X (PHASE2 (PASSONE N EXP) N))
     (PUNCH (LIST (CONS (LIST N (QUOTE SUBR) L)         (CAR X))
         (CADR X)))
     (GO A)                )))
(PUNCHDEF (LAMBDA (L) (MAPCON L (FUNCTION (LAMBDA (X) ((LAMBDA (L1) (COND ((NULL L1) (LIST (CAR X))) (T (PROG2 (PUNCH (LIST (CAR X) (CAR L1))) NIL)))) (PROP (CAR X) (QUOTE EXPR) (FUNCTION (LAMBDA NIL NIL)))))))))
))

DEFLIST ((
  (CONC (LAMBDA (ARGS ALIST)
          (MAPCON ARGS 
                  (FUNCTION 
                    (LAMBDA (L) 
                      (EVAL (CAR L) ALIST))))))
  (CSETQ (LAMBDA (ARGS ALIST)
           (CSET (CAR ARGS) (EVAL (CADR ARGS) ALIST))))
  (SELECT (LAMBDA (ARGS ALIST) (PROG (V)
            (SETQ V (PRINT(EVAL (CAR ARGS) ALIST)))
       LOOP (SETQ ARGS (CDR ARGS))
            (COND ((NULL (CDR ARGS)) (RETURN (EVAL (CAR ARGS) ALIST)))
                  ((EQUAL V (EVAL (CAAR ARGS) ALIST)) 
                             (RETURN (EVAL (CADAR ARGS) ALIST))))
            (GO LOOP)
       )))
            
) FEXPR)

OPDEFINE ((
   (AXT 774Q8) (CLA 500Q8) (LDQ 560Q8) (LXA 534Q8)
   (LXD 4534Q8) (PAX 734Q8) (PDX 4734Q8) (PXA 754Q8)
   (PXD 4754Q8) (STD 622Q8) (STO 601Q8) (STQ 4600Q8)
   (STR 5000Q8) (STZ 600Q8) (SUB 402Q8) (SXA 634Q8)
   (SXD 4634Q8) (TIX 2000Q8) (TLQ 40Q8) (TNX 6000Q8)
   (TNZ 4100Q8) (TRA 20Q8) (TSX 74Q8) (TXH 3000Q8)
   (TXI 1000Q8) (TXL 7000Q8) (TZE 100Q8) (XCA 131Q8)
))

LAP (( (GREATER SUBR 2) (TLQ (* 3)) (PXA 0 0)
       (TRA 1 4) (CLA (QUOTE *T*)) (TRA 1 4) ) NIL)

GREATER (200 NIL)

GREATER (NIL 200)


DEFINE((
(THEOREM (LAMBDA (S) (TH1 NIL NIL (CADR S) (CADDR S))))
(TH1 (LAMBDA (A1 A2 A C)(COND ((NULL A)
     (TH2 A1 A2 NIL NIL C)) (T
     (OR (MEMBER (CAR A) C) (COND ((ATOM (CAR A))
     (TH1 (COND ((MEMBER (CAR A) A1) A1)
     (T (CONS (CAR A) A1))) A2 (CDR A) C))
     (T (TH1 A1 (COND ((MEMBER (CAR A) A2) A2)
     (T (CONS (CAR A) A2))) (CDR A) C))))))))

(TH2 (LAMBDA (A1 A2 C1 C2 C) (COND
     ((NULL C) (TH A1 A2 C1 C2))
     ((ATOM (CAR C)) (TH2 A1 A2 (COND
     ((MEMBER (CAR C) C1) C1) (T
     (CONS (CAR C) C1))) C2 (CDR C)))
     (T (TH2 A1 A2 C1 (COND ((MEMBER
     (CAR C) C2) C2) (T (CONS (CAR C) C2)))
     (CDR C))))))

(TH (LAMBDA (A1 A2 C1 C2) (COND ((NULL A2) (AND (NOT (NULL C2))
     (THR (CAR C2) A1 A2 C1 (CDR C2)))) (T (THL (CAR A2) A1 (CDR A2)
     C1 C2)))))

(THL (LAMBDA (U A1 A2 C1 C2) (COND
     ((EQ (CAR U) (QUOTE NOT)) (TH1R (CADR U) A1 A2 C1 C2))
     ((EQ (CAR U) (QUOTE AND)) (TH2L (CDR U) A1 A2 C1 C2))
     ((EQ (CAR U) (QUOTE OR)) (AND (TH1L (CADR U) A1 A2 C1 C2)
     (TH1L (CADDR U) A1 A2 C1 C2) ))
     ((EQ (CAR U) (QUOTE IMPLIES)) (AND (TH1L (CADDR U) A1 A2 C1
     C2) (TH1R (CADR U) A1 A2 C1 C2) ))
     ((EQ (CAR U) (QUOTE EQUIV)) (AND (TH2L (CDR U) A1 A2 C1 C2)
     (TH2R (CDR U) A1 A2 C1 C2) ))
     (T (ERROR (LIST (QUOTE THL) U A1 A2 C1 C2)))
     )))

(THR (LAMBDA (U A1 A2 C1 C2) (COND
     ((EQ (CAR U) (QUOTE NOT)) (TH1L (CADR U) A1 A2 C1 C2))
     ((EQ (CAR U) (QUOTE AND)) (AND (TH1R (CADR U) A1 A2 C1 C2)
     (TH1R (CADDR U) A1 A2 C1 C2) ))
     ((EQ (CAR U) (QUOTE OR)) (TH2R (CDR U) A1 A2 C1 C2))
     ((EQ (CAR U) (QUOTE IMPLIES)) (TH11 (CADR U) (CADDR U)
     A1 A2 C1 C2))
     ((EQ (CAR U) (QUOTE EQUIV)) (AND (TH11 (CADR U) (CADDR U)
     A1 A2 C1 C2) (TH11 (CADDR U) (CADR U) A1 A2 C1 C2) ))
     (T (ERROR (LIST (QUOTE THR) U A1 A2 C1 C2)))
     )))

(TH1L (LAMBDA (V A1 A2 C1 C2) (COND
     ((ATOM V) (OR (MEMBER V C1)
     (TH (CONS V A1) A2 C1 C2) ))
     (T (OR (MEMBER V C2) (TH A1 (CONS V A2) C1 C2) ))
     )))

(TH1R (LAMBDA (V A1 A2 C1 C2) (COND
     ((ATOM V) (OR (MEMBER V A1)
     (TH A1 A2 (CONS V C1) C2) ))
     (T (OR (MEMBER V A2) (TH A1 A2 C1 (CONS V C2))))
     )))


(TH2L (LAMBDA (V A1 A2 C1 C2) (COND
     ((ATOM (CAR V)) (OR (MEMBER (CAR V) C1)
     (TH1L (CADR V) (CONS (CAR V) A1) A2 C1 C2)))
     (T (OR (MEMBER (CAR V) C2) (TH1L (CADR V) A1 (CONS (CAR V)
     A2) C1 C2)))
     )))

(TH2R (LAMBDA (V A1 A2 C1 C2) (COND
     ((ATOM (CAR V)) (OR (MEMBER (CAR V) A1)
     (TH1R (CADR V) A1 A2 (CONS (CAR V) C1) C2)))
     (T (OR (MEMBER (CAR V) A2) (TH1R (CADR V) A1 A2 C1
     (CONS (CAR V) C2))))
     )))

(TH11 (LAMBDA (V1 V2 A1 A2 C1 C2) (COND
     ((ATOM V1) (OR (MEMBER V1 C1) (TH1R V2 (CONS V1 A1) A2 C1
     C2)))
     (T (OR (MEMBER V1 C2) (TH1R V2 A1 (CONS V1 A2) C1 C2)))
     )))
))


THEOREM
((ARROW (P) ((OR P Q))))


THEOREM
((ARROW ((OR A (NOT B))) ((IMPLIES (AND P Q) (EQUIV P Q))) ))

TRACE ((THEOREM TH1 TH2 TH THL THR TH1L TH1R THEL TH2R TH11))
UNTRACE ((THEOREM TH1 TH2 THR THL TH1L TH1R TH2L TH2R TH11))

DEFINE ((
(TRACESET (LAMBDA (L) (TRACSQ L (FUNCTION TRACSS))))                    
                                                                        
(UNTRACESET (LAMBDA (L) (TRACSQ L (FUNCTION TRACSU))))                  
                                                                        
(TRACSQ (LAMBDA (L FN) (MAPCON L (FUNCTION (LAMBDA (J) (PROG (A)        
(SETQ A (PROP (CAR J) (QUOTE EXPR) (FUNCTION (LAMBDA () (PROG2 (PRINT
(CONS (CAR J) (QUOTE (IS NOT EXPR DEFINED)))) NIL)))))                  
(COND((NULL A) (RETURN NIL)))                                           
(SETQ A (CADDAR A))
(COND ((NOT (EQ (CAR A) (QUOTE PROG))) (RETURN(PROG2 (PRINT (CONS(CAR J)
(QUOTE (IS NOT A PROGRAM))))     NIL) )))                               
(SETQ A (CDR A))                                                        
TEST (SETQ A (CDR A))                                                   
(COND ((NULL A) (RETURN (LIST (CAR J))))                                
     ((EQ (CAAR A) (QUOTE SETQ)) (FN A)) )
(GO TEST)  ))) )))                                                      
                                                                        
(TRACSS (LAMBDA (L) (RPLACD L (NCONC (LIST                              
(QUOTE (PRINT BLANK))                                                   
(LIST (QUOTE PRINT)(LIST (QUOTE QUOTE) (LIST (CADAR L) EQSIGN)))
(LIST (QUOTE PRINT) (CADAR L))     )  (CDR L)))))                       
                                                                        
(TRACSU (LAMBDA (L) (RPLACD L (CDDDDR L))))                             
                                                                        
))
DEFINE ((
(LENGTH(LAMBDA (M) (PROG (N) (SETQ N 0)
A (COND ((NULL M) (RETURN N)) ) (SETQ N (ADD1 N)) (SETQ M (CDR M))
(GO A) )))
(REVERSE (LAMBDA (X) (PROG (Y) A (COND ((NULL X) (RETURN Y))) (SETQ Y (C
ONS (CAR X) Y)) (SETQ X (CDR X)) (GO A))))                              
(MEMBER (LAMBDA (U V) (COND ((NULL V) NIL) ((EQUAL (CAR V) U) T)
     (T (MEMBER U (CDR V)))        )))
(COMVAL (LAMBDA (EXP STOMAP NAME) (PROG NIL
(COND     ((OR (ATOM EXP) (MEMBER (CAR EXP) (QUOTE (QUOTE SPECIAL))))
               (LAC EXP))
      ((EQ (CAR EXP) (QUOTE SETQ)) (PROG NIL
           (COMVAL (CADDR EXP) STOMAP NAME)
           (ATTACH (LIST (CONS (QUOTE STO) (LOCATE (CADR EXP)))))  ))
      ((EQ (CAR EXP) (QUOTE COND)) (COMCOND (CDR EXP) T))
      ((EQ (CAR EXP) (QUOTE PROG)) (COMPROG (CDDR EXP) (CADR EXP) NAME))
      ((EQ (CAR EXP) (QUOTE OR)) (COMBOOL F F (CDR EXP) NIL))
      ((EQ (CAR EXP) (QUOTE AND)) (COMBOOL T F (CDR EXP) NIL))
      ((ATOM (CAR EXP)) (CALL (CAR EXP) (COMLIS (CDR EXP))))
      (T (PROG NIL (COMPLY (CAR EXP) (CDR EXP))
           (COMVAL (CADDAR EXP) STOMAP NAME)))          )
(SETQ AC NAME)
(RETURN NAME)                             )))
(COMPLY (LAMBDA (FN ARGS)   (MAP (PAIR (CADR FN) ARGS)
     (FUNCTION (LAMBDA (J) (PROG NIL (COMVAL (CDAR J) STOMAP
          (GENSYM)) (STORE (CAAR J) T)))))   ))
(COMLIS (LAMBDA (EXP) (PROG (X) (RETURN (MAPLIST EXP (FUNCTION (LAMBDA (
J) (COND ((OR (EQ (CAAR J) (QUOTE QUOTE)) (ATOM (CAR J))) (CAR J)) (X (PROG2 (STORE AC T) (COMVAL (CAR J) STOMAP (GENSYM)))) (T (PROG2 (SETQ X T
) (COMVAL (CAR J) STOMAP (GENSYM))))))))))))                            
(LAC (LAMBDA (X) (COND ((EQUAL AC X) NIL) (T (ATTACH (LIST (CONS (QUOTE 
CLA) (LOCATE X))))))))                                                  
(STORE (LAMBDA (X Y) (PROG NIL (COND ((OR (NULL X) (EQ (CAR X) (QUOTE QUOTE))) (RETURN NIL))) (SETQ STOMAP (CONS (CONS X (LIST (LIST (ADD1 (CAADAR STOMAP)) (QUOTE *N)) 1)) STOMAP)) (COND (Y (ATTACH (LIST (CONS (QUOTE
 STO) (LOCATE X)))))) (SETQ LENGTH (MAX LENGTH (CAADAR STOMAP))))))     
(PHASE2X (LAMBDA (J) (AND (EQ (CAADR EXP) (CADAR J)) (EQ (CAAR J) (QUOTE
 NULL)) (EQUAL (CADR J) (QUOTE (QUOTE NIL))))) #;(CADAR (CDDR EXP)))
(PHASE2Y (LAMBDA (J) (LIST (COND ((LESSP J 3) 0) (T (DIFFERENCE (TIMES J
   2) 4)))))) 
(PHASE2 (LAMBDA (EXP NAME) (PROG (AC LISTING STOMAP LENGTH) (COND ((PHASE2X (CADAR (CDDR EXP)))                               (PROG2 (ATTACH (QUOTE ((TZE 1 4)))) (SETQ EXP (LIST (CAR EXP) (CADR EXP) (CONS (QUOTE COND
) (CDDAR (CDDR EXP)))))))) (ATTACH (LIST (LIST (QUOTE TNX) (LIST (QUOTE 
E) NAME) 1 (QUOTE *MN)) (APPEND (QUOTE (TSX *MOVE 1)) (PHASE2Y 
                                                         (LENGTH (CADR EXP)))))) (SETQ LENGTH 0) (SETQ STOMAP (QUOTE ((NIL (0 *N) 1)))) (MAP (CADR EXP) (FUNCTION (LAMBDA (J) (STORE (CAR J) F)))) (SETQ AC NIL) (COMVAL
 (CADDR EXP) STOMAP NIL) (COND ((NOT (MEMBER (CAADDR EXP) (QUOTE (COND PROG)))) (ATTACH (QUOTE ((TXI *RETURN 1 *MN)))))) (SETQ EXP (REVERSE LISTING)) (RETURN (LIST EXP (LIST (CONS (QUOTE *MN) (PLUS LENGTH 2)) (CONS (
QUOTE *N) (DIFFERENCE -2 LENGTH))))))))                                 
(COMPROG (LAMBDA (EXP PROGLIS RETN) (PROG (GOLIST HOLD NAME SETS S) (SETQ HOLD EXP) A (COND ((NULL HOLD) (GO B)) ((ATOM (CAR HOLD)) (SETQ GOLIST
 (CONS (CONS (CAR HOLD) (GENSYM)) GOLIST))) ((NOT SETS) (COND ((EQ (CAAR
 HOLD) (QUOTE SPECBIND)) (SETQ S (CADADR HOLD))) (T (SETQ SETS T))))) (SETQ HOLD (CDR HOLD)) (GO A) B                  (SETQ HOLD PROGLIS) C (COND ((NULL HOLD) (GO G))) (STORE (CAR HOLD) NIL) (COND ((NOT (EQ (CAR HOLD) S)) (ATTACH (LIST (CONS (QUOTE STZ) (LOCATE (CAR HOLD))))))) (SETQ HOLD (CDR HOLD)) (GO C) G (SETQ HOLD EXP) D (SETQ AC NIL) (SETQ NAME (GENSYM)) (COND ((NULL HOLD) (GO E)) ((ATOM (CAR HOLD))                      
(ATTACH (LIST (CDR (SASSOC (CAR HOLD) GOLIST NIL)))) ) ((EQ (CAAR HOLD) 
(QUOTE GO)) (ATTACH (LIST (LIST (QUOTE TRA) (CDR (SASSOC (CADAR HOLD) GO
LIST (FUNCTION (LAMBDA NIL (ERROR (QUOTE GO)))))))))) ((EQ (CAAR HOLD) (
QUOTE COND)) (COMCOND (CDAR HOLD) F)) (T (COMVAL (CAR HOLD) STOMAP NAME)
)) (SETQ HOLD (CDR HOLD)) (GO D) E (COND (RETN (ATTACH (LIST RETN)))))))
(COMPACT (LAMBDA (EXP NAME) (COND 
     ((EQ (CAR EXP) (QUOTE NULL)) (PROG2 (SETQ SWITCH (NOT SWITCH))
               (COMPACT (CADR EXP) NAME)))
     ((EQUAL EXP (QUOTE (QUOTE *T*   ))) (COND (SWITCH (ATTACH (LIST
          (LIST (QUOTE TRA) NAME)))) (T (SETQ FLAG F))))
     ((EQ (CAR EXP) (QUOTE OR)) (COMBOOL F T (CDR EXP) SWITCH))
     ((EQ (CAR EXP) (QUOTE AND)) (COMBOOL T T (CDR EXP) SWITCH))
     (T (PROG2
     (COND ((EQ (CAR EXP) (QUOTE EQ))
          (CEQ EXP STOMAP))
         (T (COMVAL EXP STOMAP (GENSYM))))
          (ATTACH (LIST (LIST (COND (SWITCH (QUOTE TNZ)) (T(QUOTE TZE)))
                    NAME)))        ))         )))
(COMBOOL (LAMBDA (FN MODE EXP A) (PROG (GEN SWITCH)
     (SETQ GEN (GENSYM))
A    (SETQ SWITCH NIL)
     (COND ((NULL EXP) (GO C))
         ((AND MODE (NULL (CDR EXP))      (EQ A FN) ) (GO B)))
     (COMPACT   (COND (FN (CAR EXP)) (T (LIST (QUOTE NULL) (CAR EXP))))
          (COND ((AND MODE (NOT A     )) (COND (FN NAME) (T GEN)))
                    (T (COND ((NOT MODE) GEN)  (FN GEN) (T NAME)))    ))
     (SETQ AC (COND ((EQ (CAAR LISTING) (QUOTE TNZ)) (QUOTE (QUOTE NIL))
            ) (T (QUOTE (QUOTE *T*   )))))
     (SETQ EXP (CDR EXP))
     (GO A)
B    (COMPACT  (COND (FN (LIST (QUOTE NULL) (CAR EXP)))
          (T (CAR EXP))   )         NAME)
C    (COND ((NOT MODE) (ATTACH (LIST (QUOTE (TRA (* 2))) (LIST (QUOTE
          CLA) (LIST (QUOTE QUOTE) FN))       ))))
     (ATTACH (LIST GEN))
     (COND ((NOT MODE) (ATTACH (LIST (LIST (QUOTE CLA) (LIST
          (QUOTE QUOTE) (NOT FN)))))))
      )))
(COMCOND (LAMBDA (EXP MODE)    (PROG (FLAG SWITCH GEN)
     (SETQ FLAG T)
A    (COND ((NULL EXP) (GO B)))
     (SETQ GEN (GENSYM))
     (SETQ SWITCH NIL)
     (COND((AND (NOT MODE) (EQ (CAADAR EXP) (QUOTE GO)))  (GO C)))
     (COMPACT (CAAR EXP) GEN)
     (SETQ AC (COND (SWITCH (QUOTE (QUOTE NIL))) (T NIL)))
     (COMVAL (CADAR EXP) STOMAP NAME)
     (COND ((OR (AND NAME (NULL (CDR EXP)))
          (MEMBER (CAADAR EXP) (QUOTE (RETURN GO))))
          (GO L)))
     (ATTACH (LIST (COND (NAME (LIST (QUOTE TRA) NAME))
          (T (QUOTE (TXI *RETURN 1 *MN)))           )))
L    (ATTACH (LIST GEN))
D    (SETQ EXP (CDR EXP))
     (SETQ AC (COND (SWITCH (QUOTE NIL))  (T (QUOTE (QUOTE NIL)))))
     (GO A)
B    (COND (NAME (ATTACH (LIST NAME))))
     (RETURN NIL)
C    (COMPACT (LIST (QUOTE NULL) (CAAR EXP))
          (CDR (SASSOC (CADR (CADAR EXP)) GOLIST (FUNCTION
                     (LAMBDA (V) (ERROR (QUOTE GO)))))))
     (GO D)            )))
(CEQ (LAMBDA (EXP STOMAP) (PROG (A) (SETQ A (COMLIS (CDR EXP))) (COND ((
EQUAL(CAR A)AC)(ATTACH (LIST (CONS (QUOTE SUB) (LOCATE (CADR A)))))) (T 
(PROG2 (LAC (CADR A)) (ATTACH (LIST (CONS (QUOTE SUB) (LOCATE (CAR A))))
)))) (SETQ SWITCH (NOT SWITCH)))))                                      
(CALL (LAMBDA (FN ARGS)    (PROG (HOLD ITEM NUM)
     (COND ((MEMBER FN (QUOTE(SPECBIND SPECRSTR    LIST RETURN GO)))
               (GO E))
          ((NULL ARGS) (GO D))
          ((NULL (CDR ARGS)) (GO C)))
     (SETQ HOLD (REVERSE (CDDR ARGS)))
     (SETQ NUM (LENGTH ARGS))
     (COND ((GREATERP NUM 20) (ERROR (QUOTE ARGS))))
A    (COND ((NULL HOLD) (GO B)))
     (SETQ ITEM (CAR HOLD))
     (COND ((EQUAL ITEM (QUOTE (QUOTE NIL))) (ATTACH (LIST (LIST
               (QUOTE STZ) (LIST (QUOTE $ALIST) NUM)))))
           ((EQUAL ITEM AC) (ATTACH (LIST (LIST (QUOTE STO)
               (LIST (QUOTE $ALIST) NUM)))))
     (T (ATTACH (LIST (LIST (QUOTE STQ) (LIST (QUOTE $ALIST) NUM))
               (CONS (QUOTE LDQ) (LOCATE ITEM))   ))))
     (SETQ HOLD (CDR HOLD))
     (SETQ NUM (SUB1 NUM))
     (GO A)
B    (COND ((EQUAL AC (CADR ARGS)) (COND ((EQUAL AC (CAR ARGS))
     (ATTACH (QUOTE ((LDQ($ALIST 2)) (STO ($ALIST 2))))))
               (T (ATTACH (QUOTE ((XCA)))))))
          (T (ATTACH (LIST (CONS (QUOTE LDQ) (LOCATE (CADR ARGS)))))))
C    (LAC (CAR ARGS))
D    (ATTACH (LIST (LIST (QUOTE STR) (LIST (QUOTE E) FN) 7 (LENGTH
               ARGS))))
     (RETURN NIL)
E    (COND     ((EQ FN (QUOTE GO)) (ERROR (QUOTE GO)))
     ((EQ FN (QUOTE RETURN)) (PROG NIL (LAC (CAR ARGS)) (ATTACH
(LIST (COND (RETN (LIST (QUOTE TRA) RETN)) (T (QUOTE (TXI *RETURN 1
*MN))))))))
     ((EQ FN (QUOTE LIST)) (PROG (X)
          (COND ((NULL ARGS) (RETURN (ATTACH (QUOTE ((CLA (QUOTE NIL))))
               ))))
     (COND (AC (LOCATE AC)))
          (ATTACH (QUOTE ((TSX *LIST 4))))
          (ATTACH (LIST (CONS (TIMES (LENGTH ARGS) 1Q6) (LOCATE
(CAR ARGS)))))
          (SETQ X (CDR ARGS))
     A    (COND ((NULL X) (RETURN NIL)))
     (ATTACH (LIST (CONS 0 (LOCATE (CAR X)))))
          (SETQ X (CDR X))
          (GO A)                ))
     ((MEMBER FN (QUOTE (SPECBIND SPECRSTR)))    (PROG NIL
          (ATTACH (LIST (LIST (QUOTE TSX) FN 4)))
          (MAPLIST (CADAR ARGS) (FUNCTION (LAMBDA (J)
          (ATTACH (LIST (LIST (COND ((CDR J) 0)(T (QUOTE STR)))
(CAR           (LOCATE (CAR J)))1 (LIST (QUOTE SPECIAL) (CAR J))))))))))
          ))))
(ATTACH (LAMBDA (A) (COND
     ((AND (EQUAL (CAR A) (QUOTE (TXI *RETURN 1 *MN)))
          (MEMBER (CAAR LISTING) (QUOTE (TXI TRA))))     NIL)
     (T (SETQ LISTING (APPEND A LISTING)))      )))
(LOCATE (LAMBDA (X) (COND ((OR (EQ (CAR X) (QUOTE QUOTE)) (EQ (CAR X) (QUOTE SPECIAL)) (EQ X (QUOTE $ALIST))) (LIST X)) (T (CDR (SASSOC X STOMAP
     (FUNCTION (LAMBDA NIL (COND ((EQ X AC) (PROG NIL
     (STORE AC T) (RETURN (SASSOC X STOMAP (FUNCTION NIL)))))
     (T (ERROR (LIST X (QUOTE UNDECLARED))))    )))    )))     )))
(DELETEL (LAMBDA (L M) (MAPCON M (FUNCTION (LAMBDA (J) (COND ((MEMBER (CAR J) L) NIL) (T (LIST (CAR J)))))))))                                  
(PASSONE (LAMBDA (NAME FN) (PALAM (PROGITER NAME FN) NIL)))
(PA1 (LAMBDA (L) (MAPLIST L (FUNCTION (LAMBDA (J) (PAFORM (CAR J) B)))))
)                                                                       
(PA4 (LAMBDA (COMS SPECS G) (COND ((AND (NULL COMS) (NULL SPECS)) (LIST 
(QUOTE LAMBDA) (CADR FN) (PAFORM (CADDR FN) (APPEND (CADR FN) B)))) (T (
LIST (QUOTE LAMBDA) (CADR FN) (CONC (LIST (QUOTE PROG) (LIST G)) (PA11 COMS (QUOTE COMBIND)) (PA9 SPECS (QUOTE SPECBIND)) (LIST (LIST (QUOTE SETQ) G (PAFORM (CADDR FN) (APPEND (CADR FN) B)))) (PA9 SPECS (QUOTE SPECRSTR)) (PA14 COMS) (PA12 G)))))))                                         
(PA3 (LAMBDA (L) (COND ((NULL (CDR L)) (LIST (LIST (QUOTE (QUOTE *T*   )
) (PAFORM (CAR L) B)))) (T (CONS (LIST (LIST (QUOTE EQ) G (PAFORM (CAAR 
L ) B)) (PAFORM (CADAR L) B)) (PA3 (CDR L)))))))                        
(PA5 (LAMBDA (VARS PROP) (COND ((NULL VARS) NIL) ((GET (CAR VARS) PROP) 
(CONS (CAR VARS) (PA5 (CDR VARS) PROP))) (T (PA5 (CDR VARS) PROP)))))   
(PA6 (LAMBDA (KIND VAR) (LIST (LIST KIND (LIST (QUOTE QUOTE) VAR) (CONS 
(QUOTE LIST) VAR)))))                                                   
(PA7 (LAMBDA (L B) (COND ((NULL L) (QUOTE ((RETURN (QUOTE NIL))))) ((AND
 (NULL (CDR L)) (EQ (CAAR L) (QUOTE GO))) L) ((ATOM (CAR L)) (CONS (CAR 
L) (PA7 (CDR L) B))) (T (CONS (PAFORM (CAR L) B) (PA7 (CDR L) B))))))   
(PA11 (LAMBDA (VARS FUNC) (COND (VARS (PA6 FUNC VARS)) (T NIL))))       
(PA14 (LAMDBA (COMS) (COND (COMS (LIST (LIST (QUOTE COMRSTR) (LIST (QUOTE QUOTE) (LENGTH COMS))))) (T NIL))))                                   
(PA12 (LAMDBA (G) (LIST (LIST (QUOTE RETURN) G))))                      
(COMPILE (LAMBDA (L) (MAPLIST L (FUNCTION (LAMBDA (J) (COM1 (CAR J) (GET
 (CAR J) (QUOTE EXPR)) (GET (CAR J) (QUOTE FEXPR))))))))                
(COM1 (LAMBDA (N A B) (PROG2 (COND (A (COM2 (QUOTE SUBR) (LENGTH (CADR A
)) A N)) (B (COM2 (QUOTE FSUBR) (LENGTH (CADR B)) B N)) (T (PRINT (LIST 
N (QUOTE UNDEFINED))))) N)))                                            
(COM2 (LAMBDA (TYPE LENGTH EXP NAME) (PROG (LISTING) (SETQ LISTING (PHASE2 (PASSONE NAME EXP) NAME)) (TERPRI) (TERPRI) (TERPRI) (PRINT (LIST NAME TYPE LENGTH)) (MAP (CAR LISTING) (FUNCTION (LAMBDA (J) (PRINT (CAR J))
))) (TERPRI)                        (LAP (CONS (LIST NAME TYPE LENGTH) (
CAR LISTING)) (CADR LISTING)) (REMPROP NAME (QUOTE EXPR)) (REMPROP NAME 
     (QUOTE FEXPR)) (RETURN NAME))))                                    
(COMMON (LAMBDA (L) (FLAG L (QUOTE COMMON))))                           
(UNCOMMON (LAMBDA (L) (REMFLAG L (QUOTE COMMON))))
(SPECIAL (LAMBDA (X) (MAPLIST  X  (FUNCTION (LAMBDA (J)
     (DEFLIST (LIST (LIST (CAR J) (LIST NIL))) (QUOTE SPECIAL)))))))
(UNSPECIAL (LAMBDA (L) (MAP L (FUNCTION (LAMBDA (J) (REMPROP (CAR J)
(QUOTE SPECIAL)))))))
(progiter1 (LAMBDA (G1 G2 VS GS) (LIST (QUOTE LAMBDA) VS 
    (CONS (QUOTE PROG) (CONS GS (CONS G1 (PI3 (CDADDR EXP) NIL (CONS
     G2 (PAIRMAP VS GS (FUNCTION PI2) (LIST (LIST (QUOTE GO) G1))))
    )))))))
(PROGITER (LAMBDA (NAME EXP) (COND
   ((AND (EQ (CAADDR EXP) (QUOTE COND)) (PI1 (CDADDR EXP)))
(progiter1 (GENSYM) (GENSYM) (CADR EXP)
(MAPLIST (CADR EXP) (FUNCTION GENSYM))))
   (T EXP)  )))
(PI1 (LAMBDA (L) (COND
   ((NULL L) F)
   ((EQ (CAADAR L) NAME) T)
   (T (PI1 (CDR L)))  )))
(PI2 (LAMBDA (J K) (LIST (QUOTE SETQ) J K)))
(PI31 (LAMBDA (G3) (PI3 (CDR L) (NCONC C
(LIST (LIST (CAAR L) (LIST (QUOTE GO) G3))))         (CONS G3
(PAIRMAP GS (CDADAR L)
(FUNCTION PI2) (CONS (LIST (QUOTE GO) G2) S))))))
(PI3 (LAMBDA (L C S) (COND
   ((NULL L) (CONS (CONS (QUOTE COND) C) S))
   ((EQ (CAADAR L) NAME) (PI31 (GENSYM)))
   (T (PI3 (CDR L) (NCONC C (LIST (LIST (CAAR L) (LIST (QUOTE RETURN)
(CADAR L))))) S))   )))
(PALAM (LAMBDA (FN B) (COND ((ATOM FN) FN) ((EQ (CAR FN) (QUOTE LAMBDA))
 (PA4 (PA5 (CADR FN) (QUOTE COMMON)) (PA5 (CADR FN) (QUOTE SPECIAL)) (GE
NSYM))) ((EQ (CAR FN) (QUOTE LABEL)) (COMP (CADR FN) (CADDR FN))) (T (ER
ROR (CONS FN (QUOTE (NOT FUNCTION))))))))
(PAFORM (LAMBDA (FORM B) (COND ((ATOM FORM) (COND ((OR (NUMBERP FORM) (M
EMBER FORM (QUOTE (NIL *T*   )))) (LIST (QUOTE QUOTE) FORM)) ((EQ FORM (
QUOTE T)) (QUOTE (QUOTE *T*   ))) ((EQ FORM (QUOTE F)) (QUOTE (QUOTE NIL
)))
   ((GET FORM (QUOTE COMMON)) (LIST (QUOTE EVAL) (LIST (QUOTE QUOTE)
FORM) (QUOTE $ALIST)))
   ((GET FORM (QUOTE SPECIAL)) (LIST (QUOTE SPECIAL) FORM))
   ((MEMBER FORM B) FORM)
   (T (PROG NIL (PRINT (CONS FORM (QUOTE   (   UNDECLARED     ))))
(RETURN (LIST (QUOTE EVAL)(LIST (QUOTE QUOTE) FORM) (QUOTE $ALIST)))))
                                          )) ((ATOM (CAR FORM)) (COND ((
OR (GET (CAR FORM) (QUOTE FSUBR)) (GET (CAR FORM) (QUOTE FEXPR))) (COND 
((MEMBER (CAR FORM) (QUOTE (AND OR))) (CONS (CAR FORM) (PA1 (CDR FORM)))
) ((MEMBER (CAR FORM) (QUOTE (MAX MIN PLUS TIMES LOGOR LOGAND LOGXOR))) 
(LIST (CAR FORM) (CONS (QUOTE LIST) (PA1 (CDR FORM))) (QUOTE $ALIST))) (
T (SELECT (CAR FORM) ((QUOTE COND) (CONS (QUOTE COND) (MAPLIST (CDR FORM
) (FUNCTION (LAMBDA (J) (LIST (PAFORM (CAAR J) B) (PAFORM (CADAR J) B)))
)))) ((QUOTE LIST) (CONS (QUOTE LIST) (PA1 (CDR FORM)))) ((QUOTE QUOTE) 
FORM) ((QUOTE PROG) (PA8 (PA5 (CADR FORM) (QUOTE COMMON)) (PA5 (CADR FORM) (QUOTE SPECIAL)) (GENSYM))) ((QUOTE FUNCTION) (LIST (QUOTE FUNC) (LIST (QUOTE QUOTE) (COMP (GENSYM) (CADR FORM))) (QUOTE $ALIST))) ((QUOTE SETQ) (COND ((GET (CADR FORM) (QUOTE COMMON)) (LIST (QUOTE SETC) (LIST (QUOTE QUOTE) (CADR FORM)) (PAFORM (CADDR FORM) B)               )) (T (LIST (QUOTE SETQ) (PAFORM (CADR FORM) B) (PAFORM (CADDR FORM) B))))) ((QUOTE GO) FORM) ((QUOTE CSETQ) (LIST (QUOTE CSET) (LIST (QUOTE QUOTE) (CADR 
FORM)) (PAFORM (CADDR FORM) B))) ((QUOTE SELECT) ((LAMBDA (G) (LIST (LIST (QUOTE LAMBDA) (LIST G) (CONS (QUOTE COND) (PA3 (CDDR FORM)))) (PAFORM
 (CADR FORM) B))) (GENSYM))) ((QUOTE CONC) (PA2 (CDR FORM))) (LIST (CAR 
FORM) (LIST (QUOTE QUOTE) (CDR FORM)) (QUOTE $ALIST)))))) ((EQ (CAR FORM
) (QUOTE NOT)) (LIST (QUOTE NULL) (PAFORM (CADR FORM) B))) ((EQ (CAR FORM) (QUOTE SET)) (LIST (QUOTE SETC) (PAFORM (CADR FORM) B) (PAFORM (CADDR
 FORM) B)               )) (T (CONS (CAR FORM) (PA1 (CDR FORM)))))) ((OR
 (EQ (CAAR FORM) (QUOTE LAMBDA)) (EQ (CAAR FORM) (QUOTE LABEL))) (CONS (
PALAM (CAR FORM) B) (PA1 (CDR FORM)))) (T (LIST (QUOTE APPLY) (PAFORM (CAR FORM) B) (CONS (QUOTE LIST) (PA1 (CDR FORM))) (QUOTE $ALIST))))))    
(PAIRMAP (LAMBDA (L M FARG Z) (PROG (A B) 
(COND ((NULL L) (RETURN Z)))
(SETQ A (SETQ B (CONS (FARG (CAR L) (CAR M)) Z)))
A
(SETQ L (CDR L))
(SETQ M (CDR M))
(COND ((NULL L) (RETURN A)))
(SETQ B (CDR (RPLACD B (CONS (FARG (CAR L) (CAR M)) Z))))
(GO A)    )))
(PA8 (LAMBDA (COMS SPECS G) (COND ((AND (NULL COMS) (NULL SPECS)) (CONS 
(QUOTE PROG) (CONS (CADR FORM) (PA7 (CDDR FORM) (APPEND (CADR FORM) B)))
)) (T (CONC (LIST (QUOTE PROG) (CONS G (APPEND COMS SPECS))) (PA11 COMS(
QUOTE COMBIND)) (PA9 SPECS (QUOTE SPECBIND)) (LIST (LIST (QUOTE SETQ) G 
(CONS (QUOTE PROG) (CONS (DELETEL (APPEND COMS SPECS) (CADR FORM)) (PA7 
(CDDR FORM) (APPEND (CADR FORM) B)))))) (PA9 SPECS (QUOTE SPECRSTR)) (PA
14 COMS) (PA12 G))))))                                                  
(COMP (LAMBDA (N E) (COND
   ((ATOM E) E)
   (T (COM2 (QUOTE SUBR) (LENGTH (CADR E)) E N))  )))
(PA9 (LAMBDA (V K) (COND
   (V (LIST (LIST K (LIST (QUOTE QUOTE) V))))
   (T NIL))))
(PA2 (LAMBDA (L) (COND
   ((NULL L) (QUOTE (QUOTE NIL)))
   (T  (LIST (QUOTE APPEND) (PAFORM (CAR L) B) (PA2 (CDR L)))))))
))

DEFINE ((
(TEST(LAMBDA (M) (PROG (N) (SETQ N 7) (SETQ N (ADD1 N)) 
           (return (CONS N M)))))
))

COMPILE ((TEST))

TEST(2)

COMPILE (( REVERSE ))

EXCISABLE (T)

COMPILE ((
    PA5 COMP PA9 PA12 PA7
))

SPECIAL ((
   NAME GS G2 FN B FORM LEN AC STOMAP LISTING SWITCH FLAG RETN GOLIST
   RENAME HOLD EXP
))

COMPILE ((
   COM2 PROGITER PROGITER1 PI1 PI2 PI3 PI31 PALAM PA4 PAFORM PA1 PA2 PA3 PA8
   DELETEL PHASE2 PHASE2Y PHASE2X COMVAL COMPROG COMCOND COMBOOL COMPACT CEQ 
   COMPLY COMLIS STORE CALL LAC ATTACH LOCATE COMPACT COM1 PA6 PA11 PA14
   COMPILE
))

UNSPECIAL ((
   NAME GS G2 FN B FORM LEN AC STOMAP LISTING SWITCH FLAG RETN GOLIST
   RENAME HOLD EXP
))

REVERSE ((A B (C . D)))

printprop (deflist)

PRINTPROP (CAR)

PRINTPROP (SETQ)

PRINTPROP (AXT)

PRINTPROP (PROG2)

PRINTPROP (REVERSE)

LENGTH ((A B C))

MEMBER ( D (A B C D E ))

MEMBER ( G (A B C D E ))

LAP (( (GREATER SUBR 2) (TLQ (* 3)) (PXA 0 0)
       (TRA 1 4) (CLA (QUOTE *T*)) (TRA 1 4) ) NIL)

GREATER (200 NIL)

GREATER (NIL 200)


COMPILE ((MEMBER))
printprop (member)

MEMBER ( D (A B C D E ))

MEMBER ( G (A B C D E ))


DEFINE (( (IMPLIES (LAMBDA (X Y) (SELECT X (Y T) Y)))))

TRACE ((IMPLIES))

PRINTPROP (IMPLIES)

IMPLIES(T T)

IMPLIES(T F)

IMPLIES(F T)
 
IMPLIES(F F)

DEFINE ((
   (REST (LAMBDA (X) (CDR X)))
   (FIRST (LAMBDA (X) (CAR X)))
   (CONNECT (LAMBDA (X Y) (CONS X Y)))
   (ELEMENT (LAMBDA (N X) (COND
          ((EQUAL N 1) (FIRST X))
          (T (ELEMENT (SUB1 N) (REST X))))))
   (UNION (LAMBDA (X Y) (COND
         ((NULL X) Y)
         ((MEMBER (FIRST X) Y)
              (UNION (REST X) Y))
         (T CONNECT X (UNION (REST X) Y))
    )))
   (PATH (LAMBDA (A B C) (COND
         ((MEMBER B (GAMMA A)) (CONNECT B C))
         ((MEMBER B (CLOSURE (FIRST A))) (COND
              ((MEMBER (FIRST A) C) (PATH (REST A) B C ))
              (T (PATH (GAMMA (FIRST A)) B (CONNECT A C))))
         (T (PATH (REST A) B C))))))
   (CLOSURE (LAMBDA (X) (COND
         ((EQUAL (GAMMA X) X) X)
          (T (CLOSURE (UNION X (GAMMA X)))))))
   (GAMMA (LAMBDA (X) (COND
          ((NULL X) NIL)
          (T (UNION (ELEMENT (FIRST A) M) (GAMMA (REST X)))))))
))
TRACE ((COMPLY COMLIS LAC STORE PHASE2 COMPROG COMPACT COMBOOL 
 COMCOND CEQ CALL ATTACH LOCATE DELETEL PASSONE PA1 PA4 PA3 PA5 PA6
 PA7 PA11 PA14 PA12 COMPILE COM1 COM2 COMMON UNCOMMON SPECIAL UNSPECIAL
  PROGITER PI1 PI2 PI3 PALAM PAFORM PAIRMAP PA8 COMP PA9 PA2 COMVAL
  PHASE2X PROGITER1))
UNTRACE ((COMPLY COMLIS LAC STORE PHASE2 COMPROG COMPACT COMBOOL 
 COMCOND CEQ CALL ATTACH LOCATE DELETEL PASSONE PA1 PA4 PA3 PA5 PA6
 PA7 PA11 PA14 PA12 COMPILE COM1 COM2 COMMON UNCOMMON SPECIAL UNSPECIAL
  PROGITER PI1 PI2 PI3 PALAM PAFORM PAIRMAP PA8 COMP PA9 PA2 COMVAL
  PHASE2X PROGITER1))

(CSETQ M (LIST((22) () () (5 6 8) () (7) (6) () (10) (9 11) (10 12)
(13 14 15) (2 19 20) () (16 17 18) () () () () () ()
(3 4 9))))

(PATH (1) (2) NIL)


define((
(macro (lambda (l) (deflist l (quote macro))))

(mdef (lambda (l) (cond
   ((atom l) l)
   ((eq (car l) (quote qoute)) l)
   ((member (car l) (quote (lambda label prog)))
(cons (car l) (cons (cadr l) (cond
      ((eq (car l) (quote prog)) (maplist (cddr l) (function (lambda (j)
(mdef (car j))))))
      (t (mdef (cddr l)))) )))
   ((get (car l) (quote macro )) (mdef ((get (car l) (quote macro))
l)))
   (t (maplist l (function (lambda (j) (mdef (car j))))))) )))
)
LAP (((LAP SUBR 2)     (SXA X 4)      (STO ($ALIST 3))        P
     (XCA)      (LDQ (QUOTE NIL))      (TSX CONS 4)
     (XCA)   (CLA ($ALIST 3))          (TSX CONS 4)
X    (AXT 0 4)    (TRA PUNCH)     ) ())

UNTRACE ((CAR CDR CAADDR AND QUOTE MAPLIST SETQ LIST LAMBDA CONS
         APPEND))

opdefine (((tlq 40q8)))
lap (( (greater subr 2) (tlq (* 3)) (cla (quote nil)) (tra 1 4)
(cla (quote *true*)) (tra 1 4)) nil)
EXCISE (NIL)

define ((
(infix (lambda (l s) (cond ((null l) nil) ((null (cdr l)) (list (makalg 
(car l)))) (t (cons (makalg (car l)) (cons s (infix (cdr l) s)))))))    
(makalg (lambda (e) (cond ((or (numberp e) (atom e)) e) (t (select (car 
e) ((quote plus) (infix (cdr e) pluss)) ((quote prdct) (infix (cdr e) star)) ((quote minus) (list dash (makalg (cdr e)))) ((quote recip) (list 1
 slash (makalg (cdr e)))) ((quote power) (infix (cdr e) starr)) ((quote 
subt) (infix (cdr e) dash)) (infix (cdr e) slash))))))                  
(simpls (lambda (l) (prog (nums negind in divs collst outsw
com prds pwrs gcd)
(setq nums 0)
(setq in l)
test1 (cond
((null in) (go endt1))
((numberp (car in)) (setq nums (cond
      (negind (difference nums (car in)))
      (t (tosm (car in) nums)) )))
((atom (car in)) (subatm collist))
((eq (caar in) (quote minus)) (go mintr))
((eq (caar in) (quote plus)) (go plstr))
((eq (caar in) (quote divide)) (subdiv divs (plotnum (cadar in))))
((eq (caar in) (quote recip)) (prog () (rplaca in (list (quote
divide) 1 (cdar in))) (subdiv divs (cons 1 1)) ))
((eq (caar in) (quote prdct)) ((lambda (a) (subprod collst)) (plotnum
(car in))))
((eq (caar in) (quote subt)) (go substr))
(t (subatm collst)))
(setq in (cdr in))
(setq negind f)
(go test1)
subtr (setq in (append (cdr (unsubt (car in)))(cdr in)))
mintr (setq negind t)
(cond ((eq (cadar in) (quote plus)) (setq in (nconc (concmn (cddar in))
(cdr in))))    )
   (setq in (cons (cdar in) (cdr in)))
(go test1)
plstr (setq in (append (cdar in ) (cdr in)))
(go test1)
endt1 (cond 
       ((null divs) (go test2))     )
(map divs (function (lambda (j) ((lambda (d) (map d (function
(lambda (k) (search com
(function (lambda (i) (equal (caar i) (caar k))))
(function (lambda (i) (cond
   ((greaterp (cdar i) (cdar k)) nil)
   (t (rplacd (car i) (cdar k)))  )))
(function (lambda (i) (setq com (cons (car k) com))))   )))))
(deccmp (caddr (caar j)))   )   )))
(mapreconst collst)
(mapdivconst divs)
(map com (function recom))
(cond ((not (zerop nums)) (setq collst (cons nums collst))))
(return (simdiv (simpls (maplist (nconc divs collst)
(function (lambda (j) (simprd (cons (car j)
com)))))) (cons (quote prdct ) com)))
test2 (cond((zerop nums)(go collect))   )
colnum (cond 
   ((not (and (or (fixp nums) (zerop nums)) (mapand collst (function
(lambda (j) (fixp (cdr j))))))) (go asblot))  )
(setq gcd nums)
(map collst (function (lambda (j) (setq gcd (gcd gcd (cdar j))))))
(cond 
   ((zerop gcd) (return 0))
   ((or (onep gcd) (equal gcd -1)) (go asblot))  )
(map collst (function (lambda (j) (rplacd (car j)
(quotient (cdar j) gcd)))))
(setq nums (quotient nums gcd))
(setq outsw (cons gcd outsw))
asblot (map collst (function (lambda (j) ((lambda (a) (cond
   ((equal a o) nil)
   ((eq (car a) (quote minus)) (setq com (insord (cdr a) com)))
   (t (setq in (insord a in)))))     (reconst (car j))))))
(cond ((zerop nums) nil)
   ((minusp nums) (setq com (cons (minus nums) com)))
   (t (setq in (cons nums in))))
(setq com (resum2 com))
(setq in (resum2 in))
(setq in (resum1 in com))
(cond ((null outsw nil)
      ((null (cdr outsw))(setq outsw (car outsw)))
      (t (setq outsw (simprd outsw))) )
(cond ((null outsw) (return in))
      ((and (numberp in) (onep in)) (return outsw))
      ((and (numberp in) (numberp outsw)) (return totim in outsw))) )
(setq outsw (setneg outsw))
(setq in (setneg in))
(cond ((eq (car outsw) (quote prdct)) (setq outsw (cons (qoute prdct)
(insord in (cdr outsw)))))
      (t (setq outsw (cons (qoute prdct) (insord in (list outsw))))) )
(return (cons
   (negind (simmin outsw))
   (t outsw)))
collect (cond
   ((null collst) (return c))
   ((null (cdr collst)) (return (reconst (car collst)))) )
(setq divs (mapcon collst (function (lambda (i) (cond
   ((zerop (cdar i)) nil)
   (t (list (decomp (caar i)))))))))
(setq outsw (car divs))
test3 (setq divs (cdr divs))
(cond ((null divs) (go cont))   )
(setq outsw (compar (car divs) outsw))
(cond ((null outsw) (go colnum)) )
(go test3)
cont (map outsw (quote recom))
(map collst (function (lambda (j) rplaca (car j) (simprd
(list (caar j) (append (quote (recip prdct)) outsw))))))
(go colnum)  )))

(tosm (lambda (p q) (plus p q)))
(totim (lambda (p q) (times p q)))
(delete (lambda (x y) (cond
     ((null y) nil)
     ((eq x (car y)) (cdr y))
(t (cons (car y) (delete x (cdr y))   ))   )))
(larger (lambda (x y) (cond
   ((null x) f)
   ((null y) t)
((numberp x) (and (numberp y) (greaterp x y)))
((numberp y) t)
   ((atom x) (and (atom y) (greater x y)))
   ((atom y) t)
   ((equal (car x) (car y)) (larger (cdr x) (cdr y)))
   (t (larger (car x) (car y)))  )))
(insord (lambda (x l) (cond
((null l) (list x))
((larger (car l) x) (cons x l))
(t (cons (car l) (insord x (cdr l))))    )))

(ord (lambda (l r) (cond
((null l) r)
(t (ord (cdr l) (insord (car l) r)))    )))
 
(order (lambda (l) (ord l nil)))
(abs (lambda (n) (cond
    ((minusp n) (minus n))
    (t n) )))

(compar (lambda (a b) (mapcon a (function (lambda (j) (search b
(function (lambda (k) (equal (caar k) (caar j))))
(function (lambda (k) (list (cons (caar k) (cond
((lessp (cdar k) (cdar j)) (cdar k)) (t (cdar j)))))))
(quote (lambda (k) nil))  ))))))

(concmn (lambda (l) (maplist l (function (lambda (j)
(cons (quote minus) (car j)))))))
(divp (lambda (x y) (zerop (remainder x y))))
(dvtst (lambda () (cond
   (divind -1)
   (t 1)  )))

(gcd (lambda (m n) (cond
   ((zerop n) m)
   ((zerop m) n) 
   ((greaterp (abs m) (abs n)) (gcd n m))
   ((divp n m) m)
   (t (gcd (remainder n m) m)) )))

(inspwr (lambda (x l fn) (cond
   ((null l) (fn))
   ((equal (caddr x) (caddar l)) (rplaca (cdar l) (cons (quote prdct)
(insord (cadr x) (cond
      ((eq (caadar l) (quote prdct)) (cdadar l))
      (t (list (cadar l))))))))
   (t (inspwr x (cdr l) fn)) )))

(mapand (lambda (l fn) (or (null l) (and (fn (car l)) (mapand (cdr l)
fn)) )))

(mapdivconst (lambda (k) (map k (function (lambda (l) (rplaca l
(list (quote prdct) (cdar l) (cadaar l) (cons (quote recip) (caddr
(caar l)) ))))))))

(mapend (lambda (x fn)(mapcon x (function (lambda (j) (append (fn j)
nil))))))

(mapreconst (lambda (l) (map l (function (lambda (j)
(rplaca j (reconst (car j))))))))

(mpylss (lambda (s sl) (cond
   ((eq (car s) (quote subt)) (mpylss (unsubt s) sl))
   ((null sl) (cdr s))
   (t (mapcon (cdr s) (function (lambda (j) (maplist sl (function
(lambda (k) (list (quote prdct) (car j) (car k))))))))) )))

(plotnum (lambda (x) (cond
   ((and (eq (car x) (quote prdct)) (numberp (cadr x))) (cons (cond
      ((null (cdddr x)) (caddr x))
      (t (cons (quote prdct) (cddr x))) ) (cadr x)))
   (t (cons x 1))  )))

(prdatm (lambda (l fn) (cond
   ((null l) (fn))
   ((equal (caar l) (car in)) (rplacd (car l) (pluspr
(cdar l) (dvtst))))
   ((larger (car in) (caar l)) (rplaca (rplacd l (cons (car l)
(cdr l))) (cons (car in) (dvtst))))
   (t (prdatm (cdr l) fn))  )))

(prdpwr (lambda (l fn) (cond
   ((null l) (fn))
   ((equla (caar l) (cadar in)) (rplacd (car l) (pluspr
(cdar l) (sp4))))
   ((larger (cadar in) (caar l)) (rplaca (rplacd l (cons (car l) (cdr l)
)) (cons (cadar in) (sp4))))
   (t (prdpwr (cdr l) fn)) )))

(recom (lambda (j) (rplaca j (simpwr (caar j) (cdar j)))))

(reconst (lambda (x) (cond
   ((zerop (cdr x)) c)
   ((onep (cdr x)) (car x))
   ((numberp (car x)) (totim (car x) (cdr x)))
   ((minusp (cdr x)) (simmin (reconst (cons (car x)
(minus (cdr x))))))
   ((eq (caar x) (quote prdct )) (cons (quote prdct) (cons
(cdr x) (cdar x))))
   (t (list (quote prdct) (cdr x) (car x)))  )))

(resum (lambda (l p n) (cond
   ((null l) (resum1 (resum2 p) (resum2 n)))
   ((eq (caar l) (quote minus)) (resum (cdr l) p (nconc n (list
(cdar l)))))
   (t (resum (cdr l) (nconc p (list (car l))) n)) )))

(resum1 (lambda (p n) (cond
   ((and n(null n) (null p)) 0)
   ((null n) p)
   ((null p) (simmin n))
   (t (list (quote subt) p n)) )))

(resum2 (lambda (x) (cond
   ((null x) nil)
   ((null (cdr x)) (car x))
   (t (cons (quote plus) x)) )))

(setexp (lambda () (setq exps (nconc exps (list (cons (xadar in)
(sp4)))))))

(setneg (lambda (l) (cond
   ((and (numberp l) (minusp)) (prog2 (setq negind (not negind))
(minus l)))
   ((eq (car l) (quote minus)) (prog2 (setq negind (not negind)) (cdr l)
)) (t l) )))

(setsum (lambda () (setq sums (nconc sums (list
(cons (cadar in) (sp4)))))))

(simdiv (lambda (x y) (simprd (list x (simrcp y)))))

(simmin (lambda (x) (cond
((null x) (erroe (quote simmin)))
((numberp x) (minus x))
((eq (car x) (quote minus)) (cdr x))
((eq (car x) (quote subt)) (list (quote subt) (caddr x) (cadr x)))
(t (cons (quote minus) x))   )))

(simplify (lambda (l) (cond
   ((null l) (error (quote simplify)))
   ((or (atom l) (numberp l) )  l)
   ((eq    (car l) (quote minus)) (simmin (simplify (cdr l))))
   ((eq (car l) (quote plus)) (simpls (maplist (cdr l) (function (lambda
 (j) (simplify (car j)))))))
   ((eq (car l) (quote prdct)) (simprd (maplist (cdr l) (function(lambda
(j) (simplify (car j)))))))
   ((eq (car l) (quote divide)) (simdiv (simplify (cadr l))
(simplify (caddr l))))
   ((eq (car l) (quote subt)) (simsub (simplify (cadr l)) (simplify
(caddr l))))
   ((eq (car l) (quote power)) (simpwr (simplify (cadr l)) (simplify
(caddr l))))
   (t (simrcp (simplify (cdr l))))  )))

(sp3 (lambda (d i n) (cond
   ((null d) (cond
          ((null n) nil)
          ((greaterp i 1) (simpls (maplist n (function
(lambda (j) (simprd (list (car j))))))))
         (t (resum n nil nil)) ))
   ((null n) (cond
         ((null (cdr d)) (car d))
         (t (cons (quote prdct) d))   ))
   (t (simpls (maplist n (function (lambda (j) (simprd
(append d (list (car j)))))))))  )))

(pluspr (lambda (x y) (cond
   ((and (numberp x) (numberp y)) (tosm x y))
   (t (simpls (list x y))) )))

(simpwr (lambda (x y) (cond
   ((or (null x) (null y)) (error nil ))
   ((and (numberp y) (zerop y)) 1)
   ((and (numberp x) (zerop x)) 0)
   ((and (numberp y) (onep y)) x)
   ((and (numberp y) (numberp x)) (cond
      ((not (minusp x)) (exp  x y))
      ((and (minusp x) (divp y 2)) (exp  (minus x) y))
      ((and (minusp x) (divp (add1 y) 2)) (minus (exp  (minus x) y )))
      ((minusp y) (list (quote recip) (quote power) x (minus y)))
      (t (list (quote power) x y))))
   ((and (numberp y) (minusp y)) (simrcp (simpwr x (minus y))))
   ((eq (car y) (quote minus)) (simrcp (simpwr x (crd y))))
   ((or (numberp x) (atom x)) (list (quote power) x y))
   ((eq (car x) (quote recip)) (simrcp (simpwr (cdr x) y)))
   ((eq (car x) (quote divide)) (simdiv              (simpwr (cadr x)
y) (simpwr (caddr x) y)))
((and (eq (car x) (quote minus)) (numberp y (fixp y)) (cond
       ((divp y 2) (simpwr (cdr x) y))
       ((divp (add1 y) 2) (simmin (simpwr (cdr x) y)))
       (t (list (quote power) x y))  ))
   ((eq (car x) (quote power)) (simpwr (cadr x) (simprd (list (caadr
x) y))))
   ((eq (car x)(quote prdct)) (simprd(maplist(cdr x)(function(lambda
(j) (simpw (car j) y)))))))
   (t (list (quote power) x y)) )))

(simrcp (lambda (x) (cond ((numberp x) (quotient   1.0 x))
   ((atom x) (cons (qoute recip) x))
   ((eq (car x) (quote minus)) (simmin (simrcp (cdr x))))
   ((eq (car x) (quote recip)) (cdr x))
   ((eq (car x) (quote divide)) (cond
      ((numberp (cadr x)) (reconst (cons (caddr x) (quotient 1.0 (cadr
x)))))
      (t ((lambda (a) (list (quote divide) (reconst (cons (caddr x)
(quotient 1.0 (cdr a)))) (car a)))  (plotnum (cadr x)) )) ))
   ((eq (car x)(quote prdct))
     (simprd (maplist (cdr x) (function (lambda (j) (simrcp (car j))))))
)
   (t (cons (quote  recip) x)) )))

(simsub (lambda (x y) (simpls (list x (simmin y)))))

(sp1 (lambda (n) (cond
   ((zerop n) nil)
   (t (prog ()
          (setq denind (add1 denind)) 
          (setq densum (mpylss (caar j) densum))
          (sp1 (add1 n)) )) )))

(sp2 (lambda (n) (cond
    ((zerop) nil)
    (t (prog ()
           (setq numind (add1 numind))
           (setq numsum (mpylss (caar j) numsum))
           (sp2 (sub1 n))  ))  )))

(sp4 (lambda () (cond
   (divind (simmin (caddar in)))
   (t (caddar in)) )))

(subatm (lamdba (l) (cond
((null l) (setq collst (cons (cons (car in) (cond (negind -1)
(t 1))) colist)))
((equal(caar l)(car in))(rplacd(car l)(cond (negind (sub1 (cdar l)))
        (t (add1 (cdar l))))))
(t (subatm (cdr l)))  )))

(subdiv (lambda (l a) (cond
   ((null l) (setq divs (cons (cons (cons (quote divide) (cons (car a)
(cddar in))) (cond
      (negind (minus (cdr a)))
      (t (cdr a)))) divs)))
   ((equal (cadr (cdaar l)) (caddar in)) ((lambda (x) (cond
      ((zerop (cdr x)) (rplacd (rplaca l (cadr l)) (cddr l)))
      (t (rplaca l (cons (list (quote divide) (car x) (caddar in))
(cdr x)))) ))
(plotnum (simpls (list (reconst (cons (caddar l) (cdar l))) (reconst
(cond (negind (cons (car x) (minus (cdr a))))      (t a))))))))
   (t (subdiv (cdr l) a))   )))

(subprd (lambda (l) (cond
   ((null l) (setq collst (cons (cond
      (negind (cons (car a) (minus (cdr a))))
      (t a)) collst)))
   ((equal (caar l) (car a)) (rplacd (car l) (tosm (cond
      (negind (minus (cdr a)))
      (t (cdr a)))  (cdar l))))
   (t (subprd (cdr l)))  )))

(unsubt (lambda (a) (cons (quote plus) (nconc (cond
      ((eq (caaddr a) (quote plus)) (concmd (cdaddr a)))
      (t (list (cons (quote minus) (caddr a)))))
(cond  ((eq (caadr a) (quote plus)) (cdadr a))
      (t (list (cadr a))) ) ))))

(simprd (lambda (l) (prog (in exps denom rcppwr nums top sums divind
sign numsum densum numind denind)
 (setq numind 0)
 (setq denind 0)
 (setq nums1)
 (setq in l)
 test1 (cond
    ((null in) (go endt1))
    ((numberp (car in)) (setq nums (cond
             (divind (quotient nums (car in)))
             (t (totim nums (car n))) )))
    ((atom (car in)) (prdatm exps (function (lambda () (setq exps
 (nconc exps (list (cons (car in) (dvtst)))))))))
    ((eq (caar in) (quote minus)) (go mintr))
    ((eq (caar in) (quote prdct)) (go prdtr))
    ((eq (caar in) (quote recip)) (go rcptr))
    ((eq (caar in) (quote power)) (go pwrtr))
    ((eq (caar in) (qoute divide)) (go divtr))
    (t (prdatm sums (function (lambda () (setq sums (nconc sums
 (list (cons (car in) (dvtst))))))))))
reset (setq in (cdr in))
(setq dviind f)
(go test1)
endt1 (map exps (function (lambda (j) ((lambda (x) (cond
     ((numberp x) nil)
     ((eq (car x) (quote power)) (inspwr x in (function (lambda nil
(setq in (cons x in))))))
     ((eq (car x ) (quote recip)) (cond
     ((eq (cadr x) (quote power)) (inspwr (cdr x)
rcppwr (function (lambda () (setq rcppwr (cons (cdr x) rcppwr))))))
      (t (setq denom (cons (cdr x) denom)))))
   (t (setq top (cons x top)))))
   (simpwr (caar j) (cdar j))) )))
(map sums (function (lamdba (j) (cond
     ((minusp (cdar j)) (sp1 (cdar j)))
     (t (sp2 (cdar j))) ))))
(map in (function (lambda (j) (setq top (insord (car j) top)))))
(map rpcppwr (function (lambda (j) (setq denom (insord (car j) denom)))))
(cond ((minusp numss) (prog2 (setq sign (not sign)) (setq numns
(minus nums)))))
(cond ((zerop nums) (return 0))
      ((onep nums) nil)
      (t (setq top (cons nums top))) )
(setq denom (sp3 denom denind densum))
(setq top (sp3 top numind numsum))
(cond ((and (null top) (null denom)) (setq top 1))
      ((null top)(setq top (cons (quote recip) denom)))
      ((null denom) nil)
      (t (setq top (list (quote divide) top denom))))
(cond (sign (setq top (simmin top))) )
(cond ((or (greaterp denind 1) (greaterp numind 1)) (return (simprd
(list top)))) )
(return top)
mintr (setq in (cons (cdar in) (cdr in)))
(setq sign (not sign))
(go test1)
prdtr (setq in (append (cdar in) (cdr in)))
(go test1)
divtr (setq in (cons (cons (quote recip) (caddar in)) (cons (cadar
in) (cdr in))))
rcptr (cond
      ((eq (cadar in) (quote prdct)) (setq in (nconc (maplist (cddar
in) (quote (lambda (j) (cons (quote recip) (car j))))) (cdr in)))) )
(setq in (cons (cdar in) (cdr in)))
(setq divind t)
(go test1)
pwrtr (cond
      ((eq (caadar in) (quote prdct)) ((lambda (x) (map (dadar in)
(function (lambda (j) (prog2 (setq in (cons (list (quote power) (car j)
x) (cdr in))) (prdpwr exps (function  setexp)))))))    (caddar in)))
      ((and (numberp (caddar in)) (fixp (caddar in)) (eq (caadar in)
(qoute plus))) (prdpwr sums(function setsum)))
      (t (prdpwer exps (function setexp))) )
(go reset)
)))
(exp (lambda (x y) (cond
      ((minusp y) (recip (expt x (difference 0.0 y))))
      (t (expt x (difference y 0.0))) )))

(decomp (lambda (e) (cond
   ((eq (car e) (quote prdct)) (mapcon (cdr e) (function (lambda (j)
(decomp (car j))))))
   ((eq (car e) (quote power)) ((lambda (n) (cond
          ((and (numberp n) (fixp n)) (maplist (decomp (cadr e))
(function (lambda (j) (rplacd (car j) n)))))
          ((eq (caadr e) (quote prdct)) (maplist (cdadr e)
(function (lambda (j) (cons (list (quote power) (car j) n) 1)))))
          (t (list (cons e 1))) ))  (caddr e)))
   (t (list (cons e 1)))  )))

(diff (lambda (e x) (cond
   ((or (null e) (not (atom x))) (error (quote diff)))
   ((atom e) (cond
      ((eq x e) 1)
      (t 0) ))
   (t (select (car e)
      ((quote minus) (simmin (diff (cdr e) x)))
      ((quote recip) (simmin (simdiv (diff (cdr e) x) (simpwr (cdr e)
2))))
      ((quote plus) (simpls (maplist (cdr e) (function (lambda (j)
(diff (car j) x))))))
      ((quote prdct) (simpls (maplist (cdr e) (function (lambda (j)
(simprd (cons (diff (car j) x) (delete (car j) (cdr e)))))))))
      ((quote divide) (simdiv (simsub (simprd (list (caddr e) (diff
(cadr e) x))) (simprd (list (cadr e) (diff (caddr e) x)))) (simpwr
(caddr e) 2)))
      ((quote power) (simprd (list (caddr e) (simpwr (cadr e) (simsub
(caddr e) 1)) (diff (cadr e) x))))
      ((quote subt) (simsub (diff (cadr e) x) (diff (caddr e) x)))
      (error (quote diff))  ))  )))
   ))

DEFINE ((
(METEOR
   (LAMBDA (RULES WORKSPACE) (METRIX RULES WORKSPACE NIL NIL
 NIL)))

(METRIX
   (LAMBDA (RULES WORKSPACE SHELF DISPCH TRACK) (METRIX2 RULES
 WORKSPACE)))

(METRIX2 
   (LAMBDA (RULES WORKSPACE) (PROG (PC GT A)
             (SETQ PC RULES)
       START (COND
                ((NULL PC) (RETURN (PROG2 (PRINT (QUOTE (OVER
 END OF PROGRAM))) WORKSPACE))))
             (SETQ GT (DISPATCH (COMITRULE (CAR PC))))
             (COND
                ((EQ GT (QUOTE *)) (GO NEXT))
                ((EQ GT (QUOTE END)) (RETURN WORKSPACE))
                ((EQUAL GT (CAAR PC)) (GO START)))
             (SETQ A (TRANSFER GT RULES))
             (COND 
                ((EQ (CAR A) (QUOTE NONAME)) (RETURN (PROG2
(PRINT (LIST (CADR A) (QUOTE (UNDEFINDED GO-TO IN)) (CAR PC)
)) WORKSPACE))))
             (SETQ PC A)
             (GO START)
       NEXT  (SETQ PC (CDR PC))
             (GO START))))

(COMITRULE
   (LAMBDA (RULE) (PROG (A B C D E F G M LEFT)
            (SETQ G RULE)
      TOP   (SETQ RULE (CDR RULE))
            (SETQ A (CAR RULE))
            (SETQ E (QUOTE *))
            (COND
               ((NOT (ATOM A)) (GO START))
               ((EQ A (QUOTE *)) (GO STAR))
               ((EQ A (QUOTE *M)) (GO *M))
               ((EQ A (QUOTE *T)) (GO *T))
               ((EQ A (QUOTE *U)) (GO *U)))
            (DEFLIST (CDR RULE) A)
            (RETURN (QUOTE *))
      STAR  (SETQ RULE (CDR RULE))
            (SETQ E (FSTATM RULE))
      START (COND 
               ((AND
                  (NULL TRACK)
                  (NULL M)) (GO TRACK)))
            (PRINT (QUOTE WORKSPACE))
            (PRINT WORKSPACE)
            (PRINT (QUOTE RULE))
            (PRINT G)
      TRACK (SETQ LEFT (COMITMATCH (CAR RULE) WORKSPACE))
            (COND 
               ((NULL LEFT) (RETURN E)))
      LOOP  (SETQ RULE (CDR RULE))
            (SETQ A (CAR RULE))
            (COND
               ((NULL RULE) (RETURN E))
               ((EQ A (QUOTE $)) (GO DOLL))
               ((EQUAL A 0) (GO ON))
               ((ATOM A) (GO SW))
               ((EQ (CAR A) (QUOTE /)) (GO SHELVE)))
      ON    (SETQ WORKSPACE (COMITR LEFT A))
            (COND 
               (M (PROG2 (PRINT (QUOTE WORKSPACE)) (PRINT WORKSPACE
))))
            (GO LOOP)
      DOLL  (SETQ A (CAR WORKSPACE))
      SW    (COND
               ((EQ E (QUOTE *)) (RETURN A)))
            (RETURN (QUOTE *))
      SHELVE (SHELVE LEFT A)
            (GO LOOP)
      *M    (SETQ M A)
            (GO TOP)
      *T    (SETQ TRACK A)
            (GO TOP)
      *U    (SETQ TRACK NIL)
            (GO TOP))))

(TRANSFER 
   (LAMBDA (GT RL) (PROG NIL
      START (COND
              ((NULL RL) (RETURN (LIST (QUOTE NONAME) GT))
)
               ((EQ GT (CAAR RL)) (RETURN RL)))
            (SETQ RL (CDR RL))
            (GO START))))

(DISPATCH
  (LAMBDA (GT) (PROG (A)
           (COND
              ((EQ GT (QUOTE *)) (RETURN GT)))
           (SETQ A (GTPAIR GT DISPCH))
           (COND 
              ((NULL A) (RETURN GT)))
           (RETURN (CAR A)))))

(GTPAIR
   (LAMBDA (NAME X) (PROG (A)
      START (COND
               ((NULL X) (RETURN NIL))
               ((EQUAL (CAR X) NAME) (RETURN (CDR X))))
            (SETQ X (CDDR X))
            (GO START))))

(FSTATM
   (LAMBDA (RULE) (PROG (A)
      START (SETQ A (CAR RULE))
            (COND
               ((NULL RULE) (RETURN (QUOTE *)))
               ((EQUAL A 0) (GO ON))
               ((ATOM A) (RETURN A)))
      ON    (SETQ RULE (CDR RULE))
            (GO START))))

(SHELVE
   (LAMBDA (PAIRS INST) (PROG (A B C D)
      START (SETQ INST (CDR INST))
            (COND
               ((NULL INST) (RETURN SHELF)))
            (SETQ A (CAR INST))
            (SETQ B (CAR A))
            (SETQ C (CADR A))
            (SETQ D (CDDR A))
            (COND
               ((EQ B (QUOTE *P)) (GO PR))
               ((EQ B (QUOTE *D)) (RETURN (SETDIS C (CAR D)
)))
               ((NOT (EQ C (QUOTE *))) (GO GETD)))
            (SETQ C (INDIRECT (CAR D) PAIRS))
            (SETQ D (CDR D))
      GETD  (SETQ D (COMITRIN PAIRS D))
            (SETQ A (GTSHLF C))
            (COND
               ((EQ B (QUOTE *S)) (GO ST1))
               ((EQ B (QUOTE *Q)) (GO QU1))
               ((EQ B (QUOTE *X)) (GO EX)))
            (PRINT (LIST (QUOTE (SHELVING ERROR IN)) (CAR INST
)))
            (GO START)
      PR    (COND
               ((EQ C (QUOTE /)) (RETURN (PRINT SHELF))))
      PR1   (PRINT (LIST (QUOTE SHELF) C (QUOTE CONTAINS) (
CAR (GTSHLF C))))
            (COND 
               ((NULL D) (GO START)))
            (SETQ C (CAR D))
            (SETQ D (CDR D))
            (GO PR1)
      EX    (SETQ B (CAR A))
            (RPLACA A WORKSPACE)
            (SETQ WORKSPACE B)
            (GO START)
      QU1   (RPLACA A (NCONC (CAR A) D))
            (GO START)
      ST1   (RPLACA A (APPEND D (CAR A)))
            (GO START))))

(SETDIS
   (LAMBDA (X Y) (PROG (A)
            (SETQ A (GTPAIR X DISPCH))
            (COND
               ((NULL A) (SETQ DISPCH (CONS X (CONS Y DISPCH
))))
               (T (RPLACA A Y)))
            (RETURN DISPCH))))

(GETDCT
   (LAMBDA (X Y) (PROG (A)
           (COND
             ((NOT (ATOM X)) (RETURN (LIST X))))
           (SETQ A (GET X Y))
           (COND
             ((NULL A) (RETURN X)))
           (RETURN A))))

(INDIRECT
   (LAMBDA (X PAIRS) (GTNAME X PAIRS)))
))

DEFINE ((
(COMITR
   (LAMBDA (LEFT ORDER) (PROG (A B C)
            (SETQ A (GTNAME 0 LEFT))
            (COND 
               ((EQUAL A 0) (SETQ A NIL))
               ((NULL A) (GO ON))
               ((ATOM A) (SETQ A (LIST A))))
     ON     (SETQ B (GTNAME (QUOTE WSEND) LEFT))
            (COND
               ((EQUAL ORDER 0) (SETQ C NIL))
               (T (SETQ C (COMITRIN LEFT ORDER))))
            (RETURN (APPEND A (APPEND C B))))))

(COMITRIN
   (LAMBDA (LEFT ORDER) (PROG (A B)
      START (COND
               ((NULL ORDER) (RETURN A)))
            (SETQ B (GTNAME (CAR ORDER) LEFT))
            (COND 
               ((NULL B) (GO ON))
               ((ATOM B) (SETQ B (LIST B))))
            (SETQ A (NCONC A B))
      ON    (SETQ ORDER (CDR ORDER))
            (GO START))))

(GTNAME
   (LAMBDA (NAME PRS) (PROG (A B C)
            (SETQ C (CAR NAME))
            (COND
               ((ATOM NAME) (GO START))
               ((EQ C (QUOTE FN)) (RETURN (COPYTP (APPLY (CADR
NAME) (COMITRIN PRS (CDDR NAME)) NIL))))
               ((EQ C (QUOTE *K)) (RETURN (LIST (COMITRIN PRS
(CDR NAME)))))
               ((EQ C (QUOTE *C)) (RETURN (COMPRESS (COMITRIN 
PRS (CDR NAME)))))
               ((EQ C (QUOTE *)) (RETURN (COPYTP (EVAL (CADR
NAME) NIL))))
               ((EQ C (QUOTE *W)) (RETURN (WRITES (COMITRIN
PRS (CDR NAME)))))
               ((EQ C (QUOTE *E)) (RETURN (EXPAND (GTNAME (
CADR NAME) PRS))))
               ((EQ C (QUOTE */)) (RETURN (LIST (SBMERGE (CDR
NAME)))))
               ((EQ C (QUOTE *N)) (RETURN (NEXT (CDR NAME))
))
               ((EQ C (QUOTE *R)) (RETURN (MTREAD)))
               ((EQ (CADR NAME) (QUOTE /)) (RETURN (LIST (SBMERGE
(LIST (QUOTE MERGE) C (CONS (QUOTE G99999) (CDR NAME)))))))
               ((EQ C (QUOTE *F)) (RETURN (CAAR (GTNAME (CADR
NAME) PRS))))
               ((EQ C (QUOTE *A)) (RETURN (ALL (CDR NAME))))
               ((EQ C (QUOTE QUOTE)) (RETURN (CADR NAME))))
      START (COND
               ((NULL PRS) (RETURN NAME)))
            (SETQ A (CAR PRS))
            (COND
               ((EQUAL NAME (CAR A)) (RETURN (COPYTP (CDR A 
)))))
            (SETQ PRS (CDR PRS))
            (GO START))))

(COPYTP 
   (LAMBDA (X) (COND
            ((ATOM X) X)
            (T (APPEND X NIL)))))

(EXPAND
   (LAMBDA (X) (COND
            ((ATOM X) (MAPCON (GET (CDR X) (QUOTE PNAME)) (FUNCTION
(LAMBDA (Y) (UNPACK (CAR Y))))))
            (T (CAR X)))))

(COMPRESS 
   (LAMBDA (X) (PROG NIL
            (CLEARBUFF)
            (MAP X (FUNCTION (LAMBDA (X) (PACK (CAR X)))))
            (RETURN (INTERN (MKNAM))))))

(MTREAD 
   (LAMBDA NIL (PROG (A B C)
            (SETQ A (STARTREAD))
            (GO A)
      START (SETQ A (ADVANCE))
      A     (COND
               ((EQ A (QUOTE $EOF$)) (RETURN A))
               ((EQ A (QUOTE $EOR$)) (RETURN B))
               ((EQ A (QUOTE  )) (SETQ C (NCONC C (LIST A))
))
               (T (GO B)))
            (GO START)
      B     (SETQ B (NCONC B (NCONC C (LIST A))))
            (SETQ C NIL)
            (GO START))))

(ALL
   (LAMBDA (X) (PROG (A B)
            (COND 
               ((EQ (CAR X) (QUOTE *)) (SETQ X (INDIRECT (CADR
X) PRS)))
               (T (SETQ X (CAR X))))
            (SETQ A (GTSHLF X))
            (SETQ B (CAR A))
            (RPLACA A NIL)
            (RETURN B))))

(NEXT
   (LAMBDA (X) (PROG (A B C)
            (COND 
               ((EQ (CAR X) (QUOTE *)) (SETQ X (INDIRECT (CADR 
X) PRS)))
               (T (SETQ X (CAR X))))
            (SETQ A (GTSHLF X))
            (SETQ C (CAR A))
            (COND
               ((NULL C) (RETURN NIL)))
            (SETQ B (CAR C))
            (RPLACA A (CDR C))
            (RETURN (LIST B)))))

(GTSHLF
   (LAMBDA (X) (PROG (A)
            (SETQ A (GTPAIR X SHELF))
            (COND
               ((NULL A) (GO A)))
            (RETURN A)
      A     (SETQ A (CONS NIL SHELF))
            (SETQ SHELF (CONS X A))
            (RETURN A))))

(SBMERGE
   (LAMBDA (X) (PROG (A B C D E G)
            (SETQ A (CAR X))
            (SETQ B (CADR X))
            (COND
               ((EQ (CADR B) (QUOTE /)) (GO BX)))
            (SETQ B (GTNAME B PRS))
            (COND 
               ((NOT (ATOM B)) (SETQ B (CAR B))))
      BX    (SETQ C (CADDR X))
            (COND
               ((EQ (CADR C) (QUOTE /)) (GO CX)))
            (SETQ C (GTNAME C PRS))
            (COND 
               ((NOT (ATOM X)) (SETQ C (CAR C))))
      CX    (COND
               ((OR
                  (ATOM C)
                  (NOT (EQ (CADR C) (QUOTE /)))) (SETQ C NIL
))
               (T (SETQ C (CDDR C))))
            (COND
               ((OR
                  (ATOM B)
                  (NOT (EQ (CADR B) (QUOTE /)))) (GO B)))
            (SETQ D (LIST (CAR B) (QUOTE /)))
            (SETQ B (CDDR B))
            (GO D)
      B     (SETQ D (LIST B (QUOTE /)))
            (SETQ B NIL)
      D     (COND
               ((EQ A (QUOTE AND)) (GO AND))
               ((EQ A (QUOTE MERGE)) (GO AND))
               ((EQ A (QUOTE OR)) (GO OR))
               ((EQ A (QUOTE SUBST)) (GO SUBST)))
      ERROR (PRINT (QUOTE (SUBSCRIPT ERROR)))
            (PRINT X)
            (RETURN (GTNAME (CADR X) PRS))
      AND   (COND
               ((NULL B) (GO RETURN))
               ((MEMBER (CAR B) C) (SETQ G (CONS (CAR B) G)
)))
            (SETQ B (CDR B))
            (GO AND)
      OR    (SETQ G C)
      OR1   (COND
               ((NULL B) (GO RETURN))
               ((NOT (MEMBER (CAR B) G)) (SETQ G (CONS (CAR
B) G))))
            (SETQ B (CDR B))
            (GO OR1)
      SUBST (SETQ G C)
      RETURN (COND
               ((AND 
                  (EQ A (QUOTE MERGE))
                  (NULL G)) (SETQ G C)))
            (COND
                ((NULL G) (RETURN (CAR D))))
            (RETURN (NCONC D G)))))
))

DEFINE ((
(COMITMATCH
    (LAMBDA (RULE WORKSPACE) (PROG (A B)
            (SETQ A (CMATCH (NAMER RULE) WORKSPACE NIL))
            (COND
               ((NULL A) (RETURN NIL))
               ((EQ A (QUOTE $IMP)) (RETURN NIL)))
            (SETQ B (CONS (QUOTE WSEND) (CDR A)))
            (RETURN (ADDLAST (CAR A) B)))))

(CMATCH
   (LAMBDA (RULE WORKSPACE MPAIRS) (PROG (RNAME A B C D E G
H)
            (SETQ RNAME (CAR RULE))
            (SETQ RULE (CDR RULE))
            (SETQ B (CAR RULE))
            (COND
               ((NULL RULE) (RETURN (CONS MPAIRS WORKSPACE)
))
               ((EQ B (QUOTE $0)) (GO $0))
               ((EQ B (QUOTE $)) (GO PDOLL)))
            (SETQ H (CAR B))
            (COND
               ((EQ H (QUOTE *P)) (GO PRINT))
               ((EQ H (QUOTE FN)) (GO FN))
               ((NULL WORKSPACE) (RETURN (QUOTE $IMP))))
            (SETQ G 0)
            (COND
               ((EQ B (QUOTE $1)) (SETQ G 1))
               ((EQ B (QUOTE $2)) (SETQ G 2))
               ((EQ B (QUOTE $3)) (SETQ G 3)))
            (COND
               ((NOT (EQUAL G 0)) (GO NDOLL2)))
            (GO TEST)
      $0    (COND
               ((AND
                  (NOT (NULL WORKSPACE))
                  (NULL (CDR RULE))) (SETQ B NIL))
               (T (SETQ B (CONS NIL WORKSPACE))))
             (GO WATB)
      TEST   (COND
                ((EQ H (QUOTE $)) (GO NDOLL))
                ((EQ H (QUOTE *)) (GO EVAL))
                ((EQ H (QUOTE QUOTE)) (GO ATB1))
                (T (GO ATB)))
      FN     (SETQ B (CDR B))
             (SETQ E (CONS WORKSPACE (COMITRIN MPAIRS (CDR B
))))
             (SETQ B (COPYTP (APPLY (CAR B) E NIL)))
      WATB   (COND
                ((NULL B) (RETURN NIL))
                ((EQ B (QUOTE $IMP)) (RETURN B))
                (T (RETURN (CMATCH (CONS (CDR RNAME) (CDR RULE
)) (CDR B) (ADDLAST MPAIRS (CONS (CAR RNAME) (CAR B)))))))
      PDOLL  (SETQ D (CDR RNAME))
             (SETQ RULE (CDR RULE))
             (COND
                 ((NULL RULE) (RETURN (LIST (ADDLAST MPAIRS (
CONS (CAR RNAME) WORKSPACE))))))
      DLOOP  (SETQ B (CMATCH (CONS D RULE) WORKSPACE MPAIRS)
)
             (COND
                 ((NULL WORKSPACE) (RETURN NIL))
                 ((EQ B (QUOTE $IMP)) (RETURN B))
                 (B (RETURN (CONS (ADDLAST (CAR B) (CONS (CAR
RNAME) C)) (CDR B)))))
             (SETQ C (ADDLAST C (CAR WORKSPACE)))
             (SETQ WORKSPACE (CDR WORKSPACE))
             (GO DLOOP)
      SUBMCH (SETQ B (SUBMCH B WORKSPACE))
             (GO WATB)
      PRINT  (PRINT (CDR B))
             (PRINT WORKSPACE)
      $IMP   (RETURN (QUOTE $IMP))
      EVAL   (SETQ B (EVAL (CADR B) NIL))
             (GO ATB2)
      ATB1   (SETQ B (CADR B))
             (GO ATB2)
      ATB    (COND 
                 ((ATOM B) (SETQ B (GTNAME B MPAIRS))))
      ATB2   (SETQ H (CAR WORKSPACE))
             (COND
                 ((ATOM B) (GO B))
                 ((EQ (CADR B) (QUOTE /)) (GO SUBMCH))
                 ((EQUAL B H) (SETQ B (CONS (LIST B) (CDR WORKSPACE
))))
                 (T (SETQ B NIL)))
             (GO WATB)
      B      (COND
                ((EQUAL B H) (SETQ B WORKSPACE))
                ((AND
                  (EQUAL B (CAR H))
                (EQ (CADR H) (QUOTE /))) (SETQ B (CONS (LIST
H) (CDR WORKSPACE))))
                (T (SETQ B NIL)))
             (GO WATB)
      NDOLL  (SETQ G (CDR B))
      NDOLL2 (SETQ B (DOLNM G WORKSPACE))
             (GO WATB))))

(NAMER
   (LAMBDA (X) (PROG (A B C D E)
            (SETQ A (CAR X))
            (SETQ D 1)
            (SETQ B X)
            (COND
               ((OR
                  (EQ A (QUOTE $))
                  (EQ A (QUOTE $0))) (GO START)))
            (SETQ B (CONS (QUOTE $) X))
            (SETQ E (LIST 0))
      START (COND
               ((NULL X) (RETURN (CONS E B))))
            (SETQ E (ADDLAST E D))
            (SETQ X (CDR X))
            (SETQ D (ADD1 D))
            (GO START))))

(SUBMCH
   (LAMBDA (X Y) (PROG (A B C)
            (SETQ A (CAR X))
            (SETQ B (CAR Y))
            (COND
               ((NOT (OR
                  (EQ A (QUOTE $1))
                  (EQUAL A (CAR B))
                  (EQUAL A (QUOTE ($ . 1))))) (RETURN NIL))
)
            (COND
               ((EQ (CADR B) (QUOTE /)) (GO ON))
               (T (RETURN NIL)))
      ON    (SETQ A (CDR X))
            (COND
               ((EQ (CAR A) (QUOTE /)) (GO A)))
            (PRINT (LIST (QUOTE (SUBSCRIPT ERROR SUBMCH)) X
))
            (RETURN NIL)
      A     (SETQ A (CDR A))
            (SETQ C (CDDR B))
      START (COND
                  ((NULL A) (RETURN (CONS (LIST B) (CDR Y))))
                  ((MEMBER (CAR A) C) (SETQ A (CDR A)))
                  (T (RETURN NIL)))
            (GO START))))

(DOLNM
   (LAMBDA (NUM WSPACE) (PROG (A B)
            (SETQ B (CAR WSPACE))
            (COND
               ((NUMBERP NUM) (GO NUM))
               ((EQ NUM (QUOTE NUMBER)) (GO NUMBER))
               ((EQ NUM (QUOTE ATOM)) (GO ATOM))
               ((EQ NUM (QUOTE LIST)) (GO LIST)))
            (COND
               ((OR
                  (EQUAL NUM B)
                  (EQUAL NUM (CAR B))) (GO RNIL)))
      $1    (COND
               ((ATOM B) (GO B)))
      LST   (RETURN (CONS (LIST B) (CDR WSPACE)))
      NUMBER (COND
               ((NOT (NUMBERP B)) (GO RNIL)))
      B     (RETURN WSPACE)
      ATOM  (COND
               ((ATOM B) (GO B)))
      RNIL  (RETURN NIL)
      LIST  (COND 
               ((ATOM B) (GO RNIL))
               (T (GO LST)))
      NUM   (COND
               ((EQUAL NUM 1) (GO $1)))
      START (COND
               ((EQUAL NUM 0) (RETURN (CONS A WSPACE)))
               ((NULL WSPACE) (RETURN (QUOTE $IMP))))
            (SETQ A (ADDLAST A (CAR WSPACE)))
            (SETQ WSPACE (CDR WSPACE))
            (SETQ NUM (SUB1 NUM))
            (GO START))))

(ADDLAST
   (LAMBDA (X Y) (APPEND X (LIST Y))))
      
(WRITES
   (LAMBDA (X) (PROG (A)
      START (SETQ A (CAR X))
            (COND
               ((NULL X) (RETURN NIL))
               ((EQ A (QUOTE $EOR$)) (GO ON))
               ((ATOM A) (PRIN1 A))
               (T (PRIN1 (QUOTE ***))))
            (SETQ X (CDR X))
            (GO START)
      ON    (TERPRI)
            (RETURN NIL))))
))


METEOR((
(*   (ROSE) (FLOWER)  * (SIMPLE REPLACEMENT))
(*    ((*P THE WORKSPACE IS))             *  (DEBUG PRINTOUT))
(*   (IS A ROSE)     0    * (DELETION))
(*    (A FLOWER IS) (3 1 2)        * (REARRANGEMENT))
(*   ((*P WS2))      *)
(*   ( FLOWER) ( 1 OF RED)   * (INSERTION) )
(*    (A FLOWER) (THE 2)    * (REPLACEMENT IN CONTEXT))
(*    ((*P WS3))      *)
(*    (FLOWER)             * (NO OPERATION))
(*      (RED) (1 1)      * (DUPLICATION))
(*    ((*P WS4))      *)
(*    (OF ($.1))   (1)  *(SINGLE UNKNOWN CONSTITUENT))
(*     (($.1))   (QUESTION 1)     * (FIRST CONSTITUENT))
(*        ( (*P WS5))   *)
(*    ( ($.2) FLOWER ($.3))   (3 2 1) * (N CONSECTUTIVE CONSTITUENTS))
(*   ((*P WS6))     *)
(*    (FLOWER $ ROSE)  (1 3)  * (UNKNOWN NUM OF CONSTITUENTS))
(*   ( (*P WS7))    *)
(*       ($)  (START C A B D) * (REPLACEING ENTIRE WORKSPACE))
(*    (START ($.1)  $ D)   (1 3 2 4)  *)
(*     ((*P WS8)) *)
(*   ($)     END)
)(A ROSE IS A ROSE IS A ROSE))

METEOR((
(CHANGE   ($ ROSE) (FLOWER) (/ (*Q SHELF1 1 PRETTY)) CHANGE)
(*   ($)  ((*A SHELF1) 1)  (/(*D PNTRET RULE3)) *)
(PRNTWS * ((*P THE WORKSPACE IS)) PNTRET)
(RULE2 ($)         END)
(RULE3  (($.1)  ($.1)) 0 (/(*S ODD 1)(*Q EVEN 2) (*D PNTRET RULE3))
      PRNTWS  (THIS IS A CONTINUATION OF THE PREVIOUS CARD))
(*    ($)   ((*A ODD) (*N EVEN)) (/ (*Q ODD (*N EVEN) ONLY)
      (*P ODD EVEN)   (*D PNTRET RULE2))     PRNTWS)
)(A ROSE IS A ROSE IS A ROSE))

METEOR((
(DEAL ($1 $1) ((FN ADD1 1)) (/(*S * 1 2)) *)
(* * ($2)    PRINT)
(* (5)  ((QUOTE 1))  DEAL)
(*  ($)          DEAL)
(PRINT ($)  (/(*P /))    END)
)(1 H1 H2 H3 H4 C1 C2 C3 C4 D1 D2 D3 D4 S1 S2 S3 S4))

METEOR
(((* DICT (BOY ((BOY / NOUN HE)))
          (GIRL ((GIRL / NOUN SHE))))
(LOOKUP ((WORD ($.1))) 0 (/ (*Q SENT (FN GETDCT WORD DICT))
   (*P SENT)) LOOKUP)
   (* ($) ((*A SENT)) END))
(THE BOY AND THE GIRL))

METEOR
(((* ((BOY / NOUN SING)) ((*/ AND 1 (DOG / NOUN MALE))
(*/ OR 1 (BOY / SMALL MALE)) (*/ SUBST 1 (MAN / MALE)))
END)) (THE (BOY / NOUN SING SMALL) AT HOME))
TRACE ((
METEOR METRIX METRIX2 COMITRULE TRANSFER DISPATCH GTPAIR
FSTATM SHELVE SETDIS GETDCT INDIRECT COMITR COMITRIN
GTNAME COPYTP EXPAND COMPRESS MTREAD ALL NEXT GTSHLF
SBMERGE COMITMATCH CMATCH NAMER SUBMCH DOLNM ADDLAST
WRITES EQ SETQ APPLY LIST ))

METEOR
(((* (($.1) IS ($.2) $ THERE) ((*K 1 2 3 4)) END))
(WHO IT IS AT MY DOOR IS THERE NOW))

SPECIAL ((MPAIRS PRS WORKSPACE DISPCH SHELF TRACK))

EVAL (OBLIST NIL)
MAP ((list(OBLIST NIL)) (PRINTPROP))

define ((
(mathread (lambda () (prog ()
        (startread)
        (clearbuff)
look    (cond ((eq curchar lpar) (go start) ))
        (advance)
        (go look)
start   (return (group (list (list (input) )) (input) (input) ))
            )))

(group (lambda (u h s) (prog (x y z)
(setq x (get h (quote prefix) ))
(setq y (get s (quote pr) ))
(setq z (get (caar u) (quote pl) ))
        (cond ((null x) (go ind))
               ((eq x (qoute yes)) (return
(group (cond ((eq h (quote plus)) u)
        (t (cons (list h) u) )) s (input) ) )))
        (print (list (quote inputerror1) h))
        (return (group (nconc u (list nil)) s (input) ))
ind     (cond ((not (null y)) (go ok)))
        (print (list (quote inputerror2) s))
        (return (group (nconc u (list nil)) h (input) ))
ok      (return (cond
((eq s (quote lpar)) (group (cons (list s) u) h (quote comma) ))
((greaterp y z) (group (cons (list s h) u) (input) (input) ))
((lessp y z) (group (cdr u) (nconc (car u) (list h)) s))
((zerop y) (cond ((null (cdr u)) h)
                ((null (cadr u)) (error h))
                (t (group (cdr u)
       (cond ((eq (car h) (quote comma)) (cdr h)) (t h)) (input) )) ))
(t (group (cons (nconc (car u) (list h)) (cdr u)) (input) (input) ))
            )) )))

(input (lambda ( ) (prog (x)
aa       (cond ((liter curchar) (go let))
               ((digit curchar) (go dig)))
         (setq x (get curchar (quote switch) ))
         (cond ((eq x (quote blank)) (go ig))
               ((eq x (quote star)) (go castor))
               ((eq x (quote difference)) (go sub))
               ((null x) (go err)))
         (advance)
         (return x)
let      (pack curchar)
         (cond ( (or (liter (advance)) (digit curchar)) (go let)))
         (return (intern (mknam)))
dig      (pack curchar)
         (cond ((or (digit (advance))
                    (eq curchar period)
                    (eq curchar (quote e))) (go dig)))
         (return (numob))
ig       (advance) 
         (go aa)
castor   (cond ((eq (advance) star) (go pollux) ))
         (return (quote times) )
pollux   (advance)
         (return (quote expt) )
sub      (csetq curchar (quote minus) )
         (return (qoute plus) )
err      (error1)
         (go ig)
             )) )))
deflist ( ((+ plus) (- difference) (minus minus)
          (* star) (/ quotient) (= equal) (|,| comma)
          (|.| dot) (|(| lpar) (|)| rpar)
          ($EOR$ blank) (| | blank)) switch)

deflist ( ((plus 30) (difference 50) (minus 50) (times 60)
          (quotient 70) (expr 90) (equal 20) (comma 10)
          (dot 110) (lpar 0) (rpar 0) ) pl)

deflist ( ((plus 30) (difference 40) (minus 40) (times 60)
          (quotient 80) (expt 100) (equal 20) (comma 10)
          (dot 120) (lpar 0) (rpar 0) ) pr)

deflist ( ((plus yes) (difference no) (minus yes) (times no)
           (quotient no) (expt no) (equal no) (comma no)
           (dot no) (lpar ya) (rpar no)) prefix)
mathread ( )
mathread ( )
mathread ( )
mathread ( )
mathread ( )
mathread ( )
opdefine1(tlq 40q8)
opdefine1(pxa 754q8)
opdefine1(Tra 20q8)
opdefine1(cla 500q8)
opdefine1(axt 774q8)

